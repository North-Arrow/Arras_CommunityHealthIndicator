const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/geometryEngineJSON-DLOjEJOS.js","assets/_commonjsHelpers-DCkdB7M8.js","assets/intersectsOperator-DEnDli3b.js","assets/OperatorIntersects-C8uYJ3OX.js","assets/ProjectionTransformation-BPiUvETu.js","assets/Envelope2D-DVXJgpa0.js","assets/Point2D-yfRtYBLE.js","assets/Transformation2D-SVwJopg7.js","assets/SimpleGeometryCursor-B92kdZ15.js","assets/MapPage-DGdIpuMu.js","assets/index-DnxlrHRJ.js","assets/index-DydP-41E.css","assets/themeLevelStore-DkxT6lxC.js","assets/MapPage-NuuMBo9V.css","assets/OperatorDefinitions-DP7_WWTp.js","assets/jsonConverter-DsAXjrbI.js","assets/containsOperator-DYjoFewz.js","assets/crossesOperator-Dmr2ZU9D.js","assets/OperatorCrosses-Cs3L2-Gb.js","assets/disjointOperator-DDMZWfQv.js","assets/overlapsOperator-DK4XIwrx.js","assets/OperatorOverlaps-CQAy9wEy.js","assets/touchesOperator-DCQzjOp1.js","assets/OperatorTouches-dVdmKCcd.js","assets/withinOperator-B-oo2j2g.js","assets/OperatorWithin-CVsT71nm.js"])))=>i.map(i=>d[i]);
import{s as b,aU as Fe,aV as Se,aB as X,aH as Ke,bw as H,br as M,at as Me,by as ue,hI as mt,h3 as Qe,hJ as yt,hK as pt,g as Y,ay as gt,dD as ae,hL as _t,hM as xt,al as be,bC as ve,hN as Ft,hO as St,bs as wt,b6 as ee,_ as ce,z as Pe,A as It,i as Tt,eC as de,u as he,hP as Rt,ac as fe,e0 as De,aC as bt,x as ze,V as vt,hQ as V,X as At,b as Be,dV as Et,b2 as $t,dX as Vt,b5 as Gt,b7 as Mt,em as me,dZ as Qt,as as Ne,bD as Pt,b1 as Dt}from"./MapPage-DGdIpuMu.js";import{G as zt}from"./projectionUtils-gkxk0ndP.js";import{P as Ce}from"./normalizeUtils-D7UKNPH6.js";import{d as Bt,$ as Nt,Q as Ct,D as Ot,E as we,g as Ie,G as qt,X as Oe,u as Zt}from"./featureConversionUtils-BWd-ztIP.js";import{WhereClauseCache as jt}from"./WhereClauseCache-Dvbyyx00.js";import{i as qe}from"./fieldType-BCX__Gyj.js";import{e as se}from"./OptimizedFeature-DugQSY51.js";import{g as q,m as kt,n as Lt,a as Ht,b as Ut,h as C,s as Jt,f as le,S as O,x as Wt,B as Xt,w as Ze,M as Yt}from"./FixedIntervalBinParameters-BVsMHjkb.js";import{t as Kt}from"./QueryEngineCapabilities-DJC_YILC.js";import{_ as z}from"./index-DnxlrHRJ.js";import{s as je}from"./quantizationUtils-BwMDcPMG.js";import{b as ei}from"./utils-CeqanpGt.js";import{m as ye,B as ti,d as ii,f as ke,p as Le,C as si,k as ri,$ as ai,E as ni,P as li,U as oi,g as ui,v as ci,L as di,G as He}from"./utils-xXQZsKiB.js";import{Z as hi}from"./FieldsIndex-CKtXi650.js";const Ue=new se,fi=new se,Te=new se,pe={esriGeometryPoint:we,esriGeometryPolyline:Ot,esriGeometryPolygon:Ct,esriGeometryMultipoint:Nt};function ge(n,e,t,i=n.hasZ,s=n.hasM){if(e==null)return null;const r=n.hasZ&&i,a=n.hasM&&s;if(t){const l=Ie(Te,e,n.hasZ,n.hasM,"esriGeometryPoint",t,i,s);return we(l,r,a)}return we(e,r,a)}function Q(n,e,t,i,s,r,a=e,l=t){const o=e&&a,u=t&&l,c=i!=null?"coords"in i?i:i.geometry:null;if(c==null)return null;if(s){let d=Bt(fi,c,e,t,n,s,a,l);return r&&(d=Ie(Te,d,o,u,n,r)),pe[n]?.(d,o,u)??null}if(r){const d=Ie(Te,c,e,t,n,r,a,l);return pe[n]?.(d,o,u)??null}return qt(Ue,c,e,t,a,l),pe[n]?.(Ue,o,u)??null}function te(n){return n&&et in n?JSON.parse(JSON.stringify(n,mi)):n}const et="_geVersion",mi=(n,e)=>n===et?void 0:e,tt=new jt(50,500),ie="unsupported-query",it=" as ",st=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeBigInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong"]),rt=new Set(["esriFieldTypeDate","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]),yi=new Set(["esriFieldTypeString","esriFieldTypeGUID","esriFieldTypeGlobalID",...st,...rt]);function Ae(n,e,t={}){const i=Z(e,n);if(!i){const r=tt.getError(e,n);throw new b(ie,"invalid SQL expression",{expression:e,error:r})}const s=t.expressionName||"expression";if(t.validateStandardized&&!i.isStandardized)throw new b(ie,`${s} is not standard`,{expression:e});if(t.validateAggregate&&!i.isAggregate)throw new b(ie,`${s} does not contain a valid aggregate function`,{expression:e});return i.fieldNames}function pi(n,e,t,i){if(!t)return!0;const s="where clause";return B(n,e,Ae(n,t,{validateStandardized:!0,expressionName:s}),{expressionName:s,query:i}),!0}function gi(n,e,t,i,s){if(!t)return!0;const r="having clause",a=Ae(n,t,{validateAggregate:!0,expressionName:r});if(B(n,e,a,{expressionName:r,query:s}),!Z(t,n)?.getExpressions().every(u=>{const{aggregateType:c,field:d}=u,h=n.get(d)?.name;return i.some(m=>{const{onStatisticField:f,statisticType:y}=m;return n.get(f)?.name===h&&y.toLowerCase().trim()===c})}))throw new b(ie,"expressions in having clause should also exist in outStatistics",{having:t});return!0}function Z(n,e){return n?tt.get(n,e):null}function at(n){return/\((.*?)\)/.test(n)?n:n.split(it)[0]}function _i(n){return n.split(it)[1]}function B(n,e,t,i={}){const s=new Map;if(xi(s,n,e,i.allowedFieldTypes??yi,t),s.size){const r=i.expressionName??"expression";throw new b(ie,`${r} contains invalid or missing fields`,{errors:Array.from(s.values()),query:i.query})}}function xi(n,e,t,i,s){const r=s.includes("*")?[...t,...s.filter(a=>a!=="*")]:s;for(const a of r)if(e.get(a))Je(n,e,t,i,a);else try{const l=Ae(e,at(a),{validateStandardized:!0});for(const o of l)Je(n,e,t,i,o)}catch(l){n.set(a,{type:"expression-error",expression:a,error:l})}}function Je(n,e,t,i,s){const r=e.get(s);r?t.has(r.name)?i!=="all"&&i?.has(r.type)===!1&&n.set(s,{type:"invalid-type",fieldName:r.name,fieldType:qe.fromJSON(r.type),allowedFieldTypes:Array.from(i,a=>qe.fromJSON(a))}):n.set(s,{type:"missing-field",fieldName:r.name}):n.set(s,{type:"invalid-field",fieldName:s})}const Fi=5;let Si=class{constructor(){this._storage=new Map,this._purgeInterval=Fi,this._sweep=()=>{if(this._timer=void 0,!this._storage)return;const e=1e3*this._purgeInterval,t=performance.now()-e;for(const[i,s]of this._storage){if(!(s.time<t))return void(this._storage.size>0&&(this._timer=setTimeout(this._sweep,e)));this._storage.delete(i)}}}destroy(){this._storage?.clear(),this._storage=null,clearTimeout(this._timer)}put(e,t){this._storage?.set(e,new Ii(t)),this._scheduleSweep()}get(e){const t=this._storage?.get(e);if(t)return this._storage?.delete(e),t.time=performance.now(),this._storage?.set(e,t),t.items}clear(){this._storage?.clear()}_scheduleSweep(){this._storage&&(this._timer??=setTimeout(this._sweep,1e3*this._purgeInterval))}get test(){}},wi=0,Ii=class{constructor(e){this.items=e,this.time=performance.now(),this.id=wi++}},J=class{constructor(e,t,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues??!1,this.fieldsIndex=i,this.featureAdapter=t;const s=e.outFields;if(s&&!s.includes("*")){this.outFields=s;let r=0;for(const a of s){const l=at(a),o=this.fieldsIndex.get(l),u=o?null:Z(l,i),c=o?o.name:_i(a)||"FIELD_EXP_"+r++;this._fieldDataCache.set(a,{alias:c,clause:u})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach(t=>this.getAttributes(t)),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,i){const s=i?i.name:t;let r=null;return this._fieldDataCache.has(s)?r=this._fieldDataCache.get(s)?.clause:i||(r=Z(t,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:r})),i?this.featureAdapter.getAttribute(e,s):r?.calculateValue(e,this.featureAdapter)}getDataValues(e,t,i=!0){const s=t.normalizationType,r=t.normalizationTotal,a=this.fieldsIndex.get(t.field),l=Fe(a)||Se(a),o=X(a);return e.map(u=>{let c=t.field&&this.getFieldValue(u,t.field,this.fieldsIndex.get(t.field));if(t.field2?(c=`${ye(c)}${t.fieldDelimiter}${ye(this.getFieldValue(u,t.field2,this.fieldsIndex.get(t.field2)))}`,t.field3&&(c=`${c}${t.fieldDelimiter}${ye(this.getFieldValue(u,t.field3,this.fieldsIndex.get(t.field3)))}`)):typeof c=="string"&&i&&(l?c=c?new Date(c).getTime():null:o&&(c=c?ei(c):null)),s&&Number.isFinite(c)){const d=s==="field"&&t.normalizationField?this.getFieldValue(u,t.normalizationField,this.fieldsIndex.get(t.normalizationField)):null;c=ti(c,s,d,r)}return c})}async getExpressionValues(e,t,i,s,r){const{arcadeUtils:a}=await Ke(),l=a.hasGeometryOperations(t);l&&await a.enableGeometryOperations();const o=a.createFunction(t),u=a.getViewInfo(i),c={fields:this.fieldsIndex.fields};return e.map(d=>{const h={attributes:this.featureAdapter.getAttributes(d),layer:c,geometry:l?{...Q(s.geometryType,s.hasZ,s.hasM,this.featureAdapter.getGeometry(d)),spatialReference:i?.spatialReference}:null},m=a.createExecContext(h,u,r);return a.executeFunction(o,m)})}validateItem(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:Z(t,this.fieldsIndex)}),this._fieldDataCache.get(t)?.clause?.testFeature(e,this.featureAdapter)??!1}validateItems(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:Z(t,this.fieldsIndex)}),this._fieldDataCache.get(t)?.clause?.testSet(e,this.featureAdapter)??!1}_processAttributesForOutFields(e){const t=this.outFields;if(!t?.length)return this.featureAdapter.getAttributes(e);const i={};for(const s of t){const{alias:r,clause:a}=this._fieldDataCache.get(s);i[r]=a?a.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,r)}return i}_processAttributesForDistinctValues(e){if(e==null||!this.returnDistinctValues)return e;const t=this.outFields,i=[];if(t)for(const a of t){const{alias:l}=this._fieldDataCache.get(a);i.push(e[l])}else for(const a in e)i.push(e[a]);const s=`${(t||["*"]).join(",")}=${i.join(",")}`;let r=this._returnDistinctMap.get(s)||0;return this._returnDistinctMap.set(s,++r),r>1?null:e}};function We(n,e,t){return{objectId:n,target:e,distance:t,type:"vertex"}}function Ti(n,e,t,i,s,r=!1){return{objectId:n,target:e,distance:t,type:"edge",start:i,end:s,draped:r}}const L="bin";class A{constructor(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new J(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query;if(!t?.length)return 1;const a=new Map,l=new Map,o=new Set;for(const u of s){const{statisticType:c}=u,d=c!=="exceedslimit"?u.onStatisticField:void 0;if(!l.has(d)){const m=[];for(const f of t){const y=this._getAttributeValues(e,f,this.items,a);m.push(y)}l.set(d,this._calculateUniqueValues(m,this.items,e.returnDistinctValues))}const h=l.get(d);for(const m in h){const{data:f,items:y}=h[m],_=f.join(",");i&&!e.validateItems(y,i)||o.add(_)}}return o.size}async createQueryResponse(){let e;if(this.query.outStatistics?e=this.query.outStatistics.some(t=>t.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse():await this._createStatisticsQueryResponse(this.query,this.items):e=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const t=this.query.geometry;H(this.query.outSR)&&!M(t.spatialReference,this.query.outSR)?e.queryGeometry=te({spatialReference:this.query.outSR,...q(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=te({spatialReference:this.query.outSR,...t})}return e}createSnappingResponse(e,t,i){const s=this.featureAdapter,r=Xe(this.hasZ,this.hasM),{point:a,mode:l}=e,o=typeof e.distance=="number"?e.distance:e.distance.x,u=typeof e.distance=="number"?e.distance:e.distance.y,c={candidates:[]},d=this.geometryType==="esriGeometryPolygon",h=this.geometryType==="esriGeometryPolyline"||this.geometryType==="esriGeometryPoint",m=this._getPointCreator(l,t,this.spatialReference,i),f=new Ye(null,0),y=new Ye(null,0),_={x:0,y:0,z:0};for(const w of this.items){const I=s.getGeometry(w);if(I==null)continue;const{coords:S}=I,x=I.isPoint?bi:I.lengths;if(f.coords=S,y.coords=S,e.returnEdge){let g=0;for(let F=0;F<x.length;F++){const p=x[F],T=g;for(let R=0;R<p;R++,g+=r){if(!d&&R===p-1)continue;const E=f;E.coordsIndex=g;const v=y;v.coordsIndex=R===p-1?T:g+r;const P=_;if(!Ri(_,a,E,v))continue;const $=(a.x-P.x)/o,G=(a.y-P.y)/u,N=$*$+G*G;N<=1&&c.candidates.push(Ti(s.getObjectId(w),m(P),Math.sqrt(N),m(E),m(v)))}}}if(e.vertexMode==="all"){let g=0;for(let F=0;F<x.length;F++){const p=x[F],T=g,R=y;R.coordsIndex=T;for(let E=0;E<p;E++,g+=r){const v=f;if(v.coordsIndex=g,d&&E===p-1&&v.x===R.x&&v.y===R.y)continue;const P=(a.x-v.x)/o,$=(a.y-v.y)/u,G=P*P+$*$;G<=1&&c.candidates.push(We(s.getObjectId(w),m(v),Math.sqrt(G)))}}}else if(h&&e.vertexMode==="ends"){let g=0;const F=[];for(let p=0;p<x.length;p++){F.push(g);const T=x[p];g+=T*r,!d&&T>1&&F.push(g-r)}for(const p of F){const T=f;T.coordsIndex=p;const R=(a.x-T.x)/o,E=(a.y-T.y)/u,v=R*R+E*E;v<=1&&c.candidates.push(We(s.getObjectId(w),m(T),Math.sqrt(v)))}}}return c.candidates.sort((w,I)=>w.distance-I.distance),c}_getPointCreator(e,t,i,s){const r=s==null||M(i,s)?o=>o:o=>q(o,i,s),{hasZ:a}=this,l=0;return e==="3d"?a&&t?({x:o,y:u,z:c})=>r({x:o,y:u,z:c}):({x:o,y:u})=>r({x:o,y:u,z:l}):({x:o,y:u})=>r({x:o,y:u})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:r,normalizationTotal:a,minValue:l,maxValue:o,scale:u,timeZone:c,outStatisticTypes:d}=e,h=this.fieldsIndex.get(t),m=Me(h)||Fe(h)||Se(h),f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:r,normalizationTotal:a,scale:u,timeZone:c},this.items),y=ii({normalizationType:r,normalizationField:s,minValue:l,maxValue:o}),_={value:.5,fieldType:h?.type},w=ue(h)?ke({values:f,supportsNullCount:y,percentileParams:_,outStatisticTypes:d}):Le({values:f,minValue:l,maxValue:o,useSampleStdDev:!r,supportsNullCount:y,percentileParams:_,outStatisticTypes:d});return si(w,d,m)}async createUniqueValuesResponse(e){const{field:t,valueExpression:i,domains:s,returnAllCodedValues:r,scale:a,timeZone:l}=e,o=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:i,scale:a,timeZone:l},this.items,!1),u=ri(o);return ai(u,s,r,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:r,normalizationTotal:a,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numClasses:d,scale:h,timeZone:m}=e,f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:r,normalizationTotal:a,scale:h,timeZone:m},this.items),y=ni(f,{field:t,normalizationField:s,normalizationType:r,normalizationTotal:a,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numClasses:d});return li(y,l)}async createHistogramResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:r,normalizationTotal:a,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numBins:d,scale:h,timeZone:m}=e,f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:r,normalizationTotal:a,scale:h,timeZone:m},this.items);return oi(f,{field:t,normalizationField:s,normalizationType:r,normalizationTotal:a,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numBins:d})}_sortFeatures(e,t,i){if(e.length>1&&t?.length)for(const s of t.slice().reverse()){const r=s.split(" "),a=r[0],l=this.fieldsIndex.get(a),o=!!r[1]&&r[1].toLowerCase()==="desc",u=ui(l?.type,o);e.sort((c,d)=>{const h=i(c,a,l),m=i(d,a,l);return u(h,m)})}}_createFeatureQueryResponse(e){const{items:t,geometryType:i,hasM:s,hasZ:r,objectIdField:a,spatialReference:l}=this,{outFields:o,outSR:u,quantizationParameters:c,resultRecordCount:d,resultOffset:h,returnZ:m,returnM:f}=e,y=d!=null&&t.length>(h||0)+d,_=o&&(o.includes("*")?[...this.fieldsIndex.fields]:o.map(w=>this.fieldsIndex.get(w)));return{exceededTransferLimit:y,features:this._createFeatures(e,t),fields:_,geometryType:i,hasM:s&&f,hasZ:r&&m,objectIdFieldName:a,spatialReference:te(u||l),transform:c&&je(c)||null}}_createFeatures(e,t){const i=new J(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:r}=this,{orderByFields:a,quantizationParameters:l,returnGeometry:o,returnCentroid:u,maxAllowableOffset:c,resultOffset:d,resultRecordCount:h,returnZ:m=!1,returnM:f=!1}=e,y=r&&m,_=s&&f;let w=[],I=0;const S=[...t];if(this._sortFeatures(S,a,(g,F,p)=>i.getFieldValue(g,F,p)),this.geometryType&&(o||u)){const g=je(l)??void 0,F=this.geometryType==="esriGeometryPolygon"||this.geometryType==="esriGeometryPolyline";if(o&&!u)for(const p of S){const T=this.featureAdapter.getGeometry(p),R=this._addFeatureJSONMetadata(p,{attributes:i.getAttributes(p),geometry:Q(this.geometryType,this.hasZ,this.hasM,T,c,g,y,_)});F&&T&&!R.geometry&&(R.centroid=ge(this,this.featureAdapter.getCentroid(p,this),g)),w[I++]=R}else if(!o&&u)for(const p of S)w[I++]=this._addFeatureJSONMetadata(p,{attributes:i.getAttributes(p),centroid:ge(this,this.featureAdapter.getCentroid(p,this),g)});else for(const p of S)w[I++]=this._addFeatureJSONMetadata(p,{attributes:i.getAttributes(p),centroid:ge(this,this.featureAdapter.getCentroid(p,this),g),geometry:Q(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(p),c,g,y,_)})}else for(const g of S){const F=i.getAttributes(g);F&&(w[I++]=this._addFeatureJSONMetadata(g,{attributes:F}))}const x=d||0;if(h!=null){const g=x+h;w=w.slice(x,Math.min(w.length,g))}return w}_addFeatureJSONMetadata(e,t){const i=this.featureAdapter.getMetadata?.(e);return i!==void 0&&(t.metadata=i),t}_createExceedsLimitQueryResponse(){let e=!1,t=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY;for(const r of this.query.outStatistics??[])if(r.statisticType==="exceedslimit"){t=r.maxPointCount!=null?r.maxPointCount:Number.POSITIVE_INFINITY,i=r.maxRecordCount!=null?r.maxRecordCount:Number.POSITIVE_INFINITY,s=r.maxVertexCount!=null?r.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")e=this.items.length>t;else if(this.items.length>i)e=!0;else{const r=Xe(this.hasZ,this.hasM),a=this.featureAdapter;e=this.items.reduce((l,o)=>{const u=a.getGeometry(o);return l+(u!=null&&u.coords.length||0)},0)/r>s}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(e,t,i={attributes:{}}){const s=[],r=new Map,a=new Map,l=new Map,o=new Map,u=new J(e,this.featureAdapter,this.fieldsIndex),c=e.outStatistics,{groupByFieldsForStatistics:d,having:h,orderByFields:m,resultRecordCount:f}=e,y=d?.length,_=!!y,w=_?d[0]:null,I=_&&!this.fieldsIndex.get(w);for(const x of c??[]){const{outStatisticFieldName:g,statisticType:F}=x,p=x,T=F!=="exceedslimit"?x.onStatisticField:void 0,R=F==="percentile_disc"||F==="percentile_cont",E=F==="EnvelopeAggregate"||F==="CentroidAggregate"||F==="ConvexHullAggregate",v=_&&y===1&&(T===w||I)&&F==="count";if(_){if(!l.has(T)){const N=[];for(const oe of d){const re=this._getAttributeValues(u,oe,t,r);N.push(re)}l.set(T,this._calculateUniqueValues(N,t,!E&&u.returnDistinctValues))}const $=l.get(T);if(!$)continue;const G=Object.keys($);for(const N of G){const{count:oe,data:re,items:$e,itemPositions:dt}=$[N],Ve=re.join(",");if(!h||u.validateItems($e,h)){const k=o.get(Ve)||{attributes:{}};if(E){k.aggregateGeometries||(k.aggregateGeometries={});const{aggregateGeometries:D,outStatisticFieldName:U}=await this._getAggregateGeometry(p,$e);k.aggregateGeometries[U]=D}else{let D=null;if(v)D=oe;else{const U=this._getAttributeValues(u,T,t,r),Ge=dt.map(ft=>U[ft]);D=R&&"statisticParameters"in p?this._getPercentileValue(p,Ge):this._getStatisticValue(p,Ge,null,u.returnDistinctValues)}k.attributes[g]=D}let ht=0;d.forEach((D,U)=>k.attributes[this.fieldsIndex.get(D)?D:"EXPR_"+ ++ht]=re[U]),o.set(Ve,k)}}}else if(E){i.aggregateGeometries||(i.aggregateGeometries={});const{aggregateGeometries:$,outStatisticFieldName:G}=await this._getAggregateGeometry(p,t);i.aggregateGeometries[G]=$}else{const $=this._getAttributeValues(u,T,t,r);i.attributes[g]=R&&"statisticParameters"in p?this._getPercentileValue(p,$):this._getStatisticValue(p,$,a,u.returnDistinctValues)}const P=F!=="min"&&F!=="max"||!ue(this.fieldsIndex.get(T))&&!this._isAnyDateField(T)?null:this.fieldsIndex.get(T)?.type;s.push({name:g,alias:g,type:P||"esriFieldTypeDouble"})}const S=_?Array.from(o.values()):[i];return this._sortFeatures(S,m,(x,g)=>x.attributes[g]),f&&(S.length=Math.min(f,S.length)),{fields:s,features:S}}_isAnyDateField(e){const t=this.fieldsIndex.get(e);return Me(t)||Fe(t)||Se(t)||X(t)}async _getAggregateGeometry(e,t){const{convexHull:i,union:s}=await z(()=>import("./geometryEngineJSON-DLOjEJOS.js").then(y=>y.g),__vite__mapDeps([0,1])),{statisticType:r,outStatisticFieldName:a}=e,{featureAdapter:l,spatialReference:o,geometryType:u,hasZ:c,hasM:d}=this,h=t.map(y=>Q(u,c,d,l.getGeometry(y))),m=i(o,h,!0)[0],f={aggregateGeometries:null,outStatisticFieldName:null};if(r==="EnvelopeAggregate"){const y=m?mt(m):Qe(s(o,h));f.aggregateGeometries={...y,spatialReference:o},f.outStatisticFieldName=a||"extent"}else if(r==="CentroidAggregate"){const y=m?yt(m):pt(Qe(s(o,h)));f.aggregateGeometries={x:y[0],y:y[1],spatialReference:o},f.outStatisticFieldName=a||"centroid"}else r==="ConvexHullAggregate"&&(f.aggregateGeometries=m,f.outStatisticFieldName=a||"convexHull");return f}_getStatisticValue(e,t,i,s){const{onStatisticField:r,statisticType:a}=e;let l=null;return l=i?.has(r)?i.get(r):ue(this.fieldsIndex.get(r))||this._isAnyDateField(r)?ke({values:t,returnDistinct:s}):Le({values:s?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(r,l),l[a==="var"?"variance":a]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:r}=e,{value:a,orderBy:l}=s,o=this.fieldsIndex.get(i);return ci(t,{value:a,orderBy:l,fieldType:o?.type,isDiscrete:r==="percentile_disc"})}_getAttributeValues(e,t,i,s){if(s.has(t))return s.get(t);const r=this.fieldsIndex.get(t),a=i.map(l=>e.getFieldValue(l,t,r));return s.set(t,a),a}_calculateUniqueValues(e,t,i){const s={},r=t.length;for(let a=0;a<r;a++){const l=t[a],o=[];for(const c of e)o.push(c[a]);const u=o.join(",");s[u]==null?s[u]={count:1,data:o,items:[l],itemPositions:[a]}:(i||s[u].count++,s[u].items.push(l),s[u].itemPositions.push(a))}return s}async _getDataValues(e,t,i=!0){const s=new J(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:r,scale:a,timeZone:l}=e;return r?s.getExpressionValues(t,r,{viewingMode:"map",scale:a,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},l):s.getDataValues(t,Y(e),i)}_calculateHistogramBins(e,t,i){if(t.min==null&&t.max==null)return[];const s=t.intervals,r=t.min??0,a=t.max??0,l=s.map(([o,u])=>({minValue:o,maxValue:u,count:0,items:[]}));for(let o=0;o<e.length;o++){const u=e[o],c=i[o];if(u!=null&&u>=r&&u<=a){const d=di(s,u);d>-1&&(l[d].count++,l[d].items.push(c))}}return l}async createQueryBinsResponse(e){const t=e.bin?.splitBy;if(!t)return this._createBinsResponse(e);const{value:i,outAlias:s,valueType:r}=t,a=[],l=[{name:s??i,alias:s??i,type:r??"esriFieldTypeString"},{name:L,alias:L,type:"esriFieldTypeInteger"}],o=new J(e,this.featureAdapter,this.fieldsIndex),u=new Map,c=[...this.items];this._sortFeatures(c,[i],(m,f,y)=>o.getFieldValue(m,f,y));const d=this._getAttributeValues(o,i,c,u),h=this._calculateUniqueValues([d],c,o.returnDistinctValues);for(const m in h){const{items:f}=h[m],y=await this._createBinsResponse(e,f);if(a.push(...y.features.map(_=>({..._,attributes:{..._.attributes,[s??i]:m}}))),y.fields)for(const _ of y.fields)l.some(w=>w.name===_.name)||l.push(_)}return{fields:l,features:a}}async _createBinsResponse(e,t){const i=e.bin;switch(t=t??this.items,i.type){case"autoIntervalBin":return this._createAutoIntervalBinsResponse(Ut.fromJSON(i),e,t);case"dateBin":return this._createDateBinsResponse(Ht.fromJSON(i),e,t);case"fixedBoundariesBin":return this._createFixedBoundariesBinsResponse(Lt.fromJSON(i),e,t);case"fixedIntervalBin":return this._createFixedIntervalBinsResponse(kt.fromJSON(i),e,t)}}async _createAutoIntervalBinsResponse(e,t,i){const{field:s,normalizationField:r,numBins:a,normalizationType:l,normalizationTotal:o,start:u,end:c}=e,d=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},i),h=He(d,{field:s,normalizationField:r,normalizationType:l,normalizationTotal:o,numBins:a,minValue:C(u,!1),maxValue:C(c,!1)}),m=this._calculateHistogramBins(d,h,i);return this._createFeaturesFromHistogramBins(m,t)}async _createDateBinsResponse(e,t,i){const{field:s,interval:r,start:a,end:l,snapToData:o,returnFullIntervalBin:u}=e,c=r.unit,d=await this._getDataValues({field:e.field,timeZone:t.outTimeReference?.ianaTimeZone},i),h=X(this.fieldsIndex.get(s)),m=Jt.toJSON(c),f=d.filter(Boolean).sort((S,x)=>S-x),y=a!=null?C(a,h):f[0],_=l!=null?C(l,h):f[f.length-1],w=[];if(y!=null&&_!=null){const S={zone:t.outTimeReference?.ianaTimeZone??gt},x=ae.fromMillis(y,S),g=ae.fromMillis(_,S);if(o==="last"){let F=g;for(;F>x;){const p=F.minus({[m]:r.value});if(p<x){w.unshift([u?p.toMillis():x.toMillis(),F.toMillis()]);break}w.unshift([p.toMillis(),F.toMillis()]),F=p}}else{let F=o==="first"?x:x.startOf(m);for(;F<=g;){const p=F.plus({[m]:r.value});if(p>g){w.push([F.toMillis(),u?p.toMillis():g.toMillis()]);break}w.push([F.toMillis(),p.toMillis()]),F=p}}}const I=this._calculateHistogramBins(d,{intervals:w,min:y,max:_},i);return this._createFeaturesFromHistogramBins(I,t)}async _createFixedBoundariesBinsResponse(e,t,i){const{field:s}=e,r=await this._getDataValues({field:s,timeZone:t.outTimeReference?.ianaTimeZone},i),a=X(this.fieldsIndex.get(s)),l=e.boundaries.map(d=>C(d,a)).sort((d,h)=>d-h),o=[];for(let d=0;d<l.length-1;d++)o.push([l[d],l[d+1]]);const u={intervals:o,min:l.at(0),max:l.at(-1)},c=this._calculateHistogramBins(r,u,i);return this._createFeaturesFromHistogramBins(c,t)}async _createFixedIntervalBinsResponse(e,t,i){const{field:s,interval:r,start:a,end:l}=e,o=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},i),u=X(this.fieldsIndex.get(s)),c=He(o,{field:s,classificationMethod:"defined-interval",definedInterval:r,minValue:C(a,u),maxValue:C(l,u)},!0),d=this._calculateHistogramBins(o,c,i);return this._createFeaturesFromHistogramBins(d,t)}async _createFeaturesFromHistogramBins(e,t){const{upperBoundaryAlias:i,lowerBoundaryAlias:s}=t,r=s||"lowerBoundary",a=i||"upperBoundary",l=[],o=[{name:r,alias:r,type:"esriFieldTypeDouble"},{name:a,alias:a,type:"esriFieldTypeDouble"}],u=t.bin?.stackBy?.value,c=t.bin?.stackBy?.outAlias;u&&o.push({name:L,alias:L,type:"esriFieldTypeInteger"},{name:c??u,alias:c??u,type:"esriFieldTypeString"});let d=0;const h=t.bin.type==="dateBin",m=t.outTimeReference?.ianaTimeZone;for(const f of e){const{minValue:y,maxValue:_,items:w}=f,I={attributes:{}};let S;if(I.attributes[r]=h&&m&&y!=null?ae.fromMillis(y,{zone:m}).toISO():y,I.attributes[a]=h&&m&&_!=null?ae.fromMillis(_,{zone:m}).toISO():_,u?(S=await this._createStatisticsQueryResponse({...t,groupByFieldsForStatistics:[u],orderByFields:[u]},w),I.attributes[L]=++d,t.bin.jsonStyle==="flat"?l.push(...S.features.map(({attributes:{EXPR_1:x,...g},...F})=>({...F,attributes:c??x?{...g,[c??x]:x,...I.attributes}:{...g,...I.attributes}}))):(I.stackedAttributes=S.features.map(({attributes:{EXPR_1:x,...g}})=>c??x?{...g,[c??x]:x}:g),l.push(I))):(t.bin?.splitBy&&(I.attributes[L]=++d),S=await this._createStatisticsQueryResponse(t,w,I),l.push(I)),S.fields)for(const x of S.fields)o.some(g=>g.name===x.name)||o.push(x)}return t.binOrder==="desc"&&l.reverse(),{fields:o,features:l}}}function Ri(n,e,t,i){const s=i.x-t.x,r=i.y-t.y,a=e.x-t.x,l=e.y-t.y,o=s*s+r*r;if(o===0)return!1;const u=a*s+l*r,c=Math.min(1,Math.max(0,u/o));return n.x=t.x+s*c,n.y=t.y+r*c,!0}function Xe(n,e){return n?e?4:3:e?3:2}class Ye{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}const bi=[1];function vi(n){return n==="mesh"?_t:xt(n)}function nt(n,e){return n?e?4:3:e?3:2}function Ai(n,e,t,i){return lt(n,e,t,i.coords[0],i.coords[1])}function Ei(n,e,t,i,s,r){const a=nt(s,r),{coords:l,lengths:o}=i;if(!o)return!1;for(let u=0,c=0;u<o.length;u++,c+=a)if(!lt(n,e,t,l[c],l[c+1]))return!1;return!0}function lt(n,e,t,i,s){if(!n)return!1;const r=nt(e,t),{coords:a,lengths:l}=n;let o=!1,u=0;for(const c of l)o=$i(o,a,r,u,c,i,s),u+=c*r;return o}function $i(n,e,t,i,s,r,a){let l=n,o=i;for(let u=i,c=i+s*t;u<c;u+=t){o=u+t,o===c&&(o=i);const d=e[u],h=e[u+1],m=e[o],f=e[o+1];(h<a&&f>=a||f<a&&h>=a)&&d+(a-h)/(f-h)*(m-d)<r&&(l=!l)}return l}const _e="unsupported-query",Ee={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultiPatch:!1,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultiPatch:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function Vi(n){return n!=null&&Ee.spatialRelationship[n]===!0}function Gi(n){return n!=null&&Ee.queryGeometry[wt(n)]===!0}function Mi(n){return n!=null&&Ee.layerGeometry[n]===!0}const Qi={esriSpatialRelIntersects:()=>z(()=>import("./intersectsOperator-DEnDli3b.js"),__vite__mapDeps([2,3,4,5,6,7,8,9,10,11,12,13,14,15])),esriSpatialRelContains:()=>z(()=>import("./containsOperator-DYjoFewz.js"),__vite__mapDeps([16,4,5,6,7,8,9,10,11,12,13,14,15])),esriSpatialRelCrosses:()=>z(()=>import("./crossesOperator-Dmr2ZU9D.js"),__vite__mapDeps([17,18,4,5,6,7,8,9,10,11,12,13,14,15])),esriSpatialRelDisjoint:()=>z(()=>import("./disjointOperator-DDMZWfQv.js"),__vite__mapDeps([19,4,5,6,7,8,9,10,11,12,13,14,15])),esriSpatialRelEnvelopeIntersects:null,esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:()=>z(()=>import("./overlapsOperator-DK4XIwrx.js"),__vite__mapDeps([20,21,4,5,6,7,8,9,10,11,12,13,14,15])),esriSpatialRelTouches:()=>z(()=>import("./touchesOperator-DCQzjOp1.js"),__vite__mapDeps([22,23,4,5,6,7,8,9,10,11,12,13,14,15])),esriSpatialRelWithin:()=>z(()=>import("./withinOperator-B-oo2j2g.js"),__vite__mapDeps([24,25,4,5,6,7,8,9,10,11,12,13,14,15])),esriSpatialRelRelation:null};function Pi(n){const e=Qi[n];if(e==null)throw new Error(`Cannot load unsupported spatial operator: ${n}`);return e()}async function W(n,e,t,i,s){if(be(e)){if(t==="esriGeometryPoint"&&(n==="esriSpatialRelIntersects"||n==="esriSpatialRelContains")){const a=Oe(new se,e,!1,!1);return l=>Ai(a,!1,!1,l)}if(t==="esriGeometryMultipoint"){const a=Oe(new se,e,!1,!1);if(n==="esriSpatialRelContains")return l=>Ei(a,!1,!1,l,i,s)}}if(ve(e)){if(t==="esriGeometryPoint"&&(n==="esriSpatialRelIntersects"||n==="esriSpatialRelContains"))return a=>Ft(e,Q(t,i,s,a));if(t==="esriGeometryMultipoint"&&n==="esriSpatialRelContains")return a=>St(e,Q(t,i,s,a));if(n==="esriSpatialRelIntersects"){const a=vi(t);return l=>a(e,Q(t,i,s,l))}}n==="esriSpatialRelEnvelopeIntersects"&&(n="esriSpatialRelIntersects");const r=await Pi(n);return a=>r.execute(e,Q(t,i,s,a))}async function ot(n,e,t){const{spatialRel:i,geometry:s}=n;if(s){if(!Vi(i))throw new b(_e,"Unsupported query spatial relationship",{query:n});if(H(s.spatialReference)&&H(t)){if(!Gi(s))throw new b(_e,"Unsupported query geometry type",{query:n});if(!Mi(e))throw new b(_e,"Unsupported layer geometry type",{query:n});if(n.outSR)return le(n.geometry?.spatialReference,n.outSR)}}}function ut(n){if(ve(n))return!0;if(be(n)){for(const e of n.rings)if(e.length!==5||e[0][0]!==e[1][0]||e[0][0]!==e[4][0]||e[2][0]!==e[3][0]||e[0][1]!==e[3][1]||e[0][1]!==e[4][1]||e[1][1]!==e[2][1])return!1;return!0}return!1}const j="unsupported-query";async function Di(n,e){const t=n.bin;if(!t.onField&&!t.onExpression?.value||t.type==="autoIntervalBin"&&t.parameters.numberOfBins==null||t.type==="dateBin"&&(t.parameters.number==null||t.parameters.unit==null)||t.type==="fixedBoundariesBin"&&t.parameters.boundaries==null||t.type==="fixedIntervalBin"&&t.parameters.interval==null)throw new b(j,"Unsupported query options",{query:n});return Re(n,e)}async function Re(n,{fieldsIndex:e,geometryType:t,spatialReference:i,availableFields:s}){if(n.geometryPrecision!=null||n.multipatchOption&&n.multipatchOption!=="xyFootprint"||n.pixelSize||n.relationParam||n.text)throw new b(j,"Unsupported query options",{query:n});return ct(e,s,n),Bi(e,s,n),Promise.all([ot(n,t,i),le(i,n.outSR)]).then(()=>n)}function ct(n,e,t){const{returnDistinctValues:i,outStatistics:s}=t,r=s?s.map(a=>a.outStatisticFieldName&&a.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if("orderByFields"in t&&t.orderByFields&&t.orderByFields.length>0){const a=" asc",l=" desc",o=t.orderByFields.map(u=>{const c=u.toLowerCase();return c.includes(a)?c.split(a)[0]:c.includes(l)?c.split(l)[0]:u}).filter(u=>!r.includes(u));B(n,e,o,{expressionName:"orderByFields",query:t})}if("outFields"in t){if(t.outFields?.length)B(n,e,t.outFields,{expressionName:"outFields",query:t,allowedFieldTypes:"all"});else if(i)throw new b(j,"outFields should be specified for returnDistinctValues",{query:t})}pi(n,e,t.where,t)}const zi=new Set([...st,...rt]);function Bi(n,e,t){const{outStatistics:i,groupByFieldsForStatistics:s,having:r}=t,a=s?.length,l=i?.length;if(r){if(!a||!l)throw new b(j,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:t});gi(n,e,r,i,t)}if(l){if(!Oi(i))return;const o=i.map(u=>u.onStatisticField).filter(Boolean);B(n,e,o,{expressionName:"onStatisticFields",query:t}),a&&B(n,e,s,{expressionName:"groupByFieldsForStatistics",query:t});for(const u of i){const{onStatisticField:c,statisticType:d}=u;if((d==="percentile_disc"||d==="percentile_cont")&&"statisticParameters"in u){const{statisticParameters:h}=u;if(!h)throw new b(j,"statisticParameters should be set for percentile type",{definition:u,query:t})}else n.get(c)&&d!=="count"&&d!=="min"&&d!=="max"&&B(n,e,[c],{expressionName:`outStatistics with '${d}' statistic type`,allowedFieldTypes:zi,query:t})}}}async function Ni(n,e,{fieldsIndex:t,geometryType:i,spatialReference:s,availableFields:r}){if(n.geometryPrecision!=null||n.multipatchOption||n.pixelSize||n.relationParam||n.text||n.outStatistics||n.groupByFieldsForStatistics||n.having||n.orderByFields)throw new b(j,"Unsupported query options",{query:n});return ct(t,r,n),Promise.all([Ci(t,r,e,n),ot(n,i,s),le(s,n.outSR)]).then(()=>n)}async function Ci(n,e,t,i){let s=[];if(t.valueExpression){const{arcadeUtils:r}=await Ke();s=r.extractFieldNames(t.valueExpression)}if(t.field&&s.push(t.field),t.field2&&s.push(t.field2),t.field3&&s.push(t.field3),t.normalizationField&&s.push(t.normalizationField),!s.length&&!t.valueExpression)throw new b(j,"field or valueExpression is required",{params:t});B(n,e,s,{expressionName:"statistics",query:i})}function Oi(n){return n!=null&&n.every(e=>e.statisticType!=="exceedslimit")}async function qi(n,e){if(!n)return null;const t=e.featureAdapter,{startTimeField:i,endTimeField:s}=n;let r=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY;if(i&&s)await e.forEach(l=>{const o=t.getAttribute(ee(l),i),u=t.getAttribute(ee(l),s);o==null||isNaN(o)||(r=Math.min(r,o)),u==null||isNaN(u)||(a=Math.max(a,u))});else{const l=i||s;await e.forEach(o=>{const u=t.getAttribute(ee(o),l);u==null||isNaN(u)||(r=Math.min(r,u),a=Math.max(a,u))})}return{start:r,end:a}}function Zi(n,e,t){if(!e||!n)return null;const{startTimeField:i,endTimeField:s}=n;if(!i&&!s)return null;const{start:r,end:a}=e;if(r===null&&a===null)return null;if(r===void 0&&a===void 0)return Li();const l=t.getAttributeAsTimestamp?.bind(t)??t.getAttribute.bind(t);return i&&s?ji(l,i,s,r,a):ki(l,i||s,r,a)}function ji(n,e,t,i,s){return i!=null&&s!=null?r=>{const a=n(r,e),l=n(r,t);return(a==null||a<=s)&&(l==null||l>=i)}:i!=null?r=>{const a=n(r,t);return a==null||a>=i}:s!=null?r=>{const a=n(r,e);return a==null||a<=s}:void 0}function ki(n,e,t,i){return t!=null&&i!=null&&t===i?s=>n(s,e)===t:t!=null&&i!=null?s=>{const r=n(s,e);return r!=null&&r>=t&&r<=i}:t!=null?s=>{const r=n(s,e);return r!=null&&r>=t}:i!=null?s=>{const r=n(s,e);return r!=null&&r<=i}:void 0}function Li(){return()=>!1}let K=class extends Tt{constructor(){super(...arguments),this.SCHEDULER_LOG_SLOW_TASKS=!1,this.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES=!1}};ce([Pe()],K.prototype,"SCHEDULER_LOG_SLOW_TASKS",void 0),ce([Pe()],K.prototype,"FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES",void 0),K=ce([It("esri.views.support.debugFlags")],K);new K;class Hi{constructor(){this._begin=performance?.now()??0,this._budget=0,this._done=!1,this._progressed=!1,this._enabled=!0}run(e){return!this.done&&(e()===!0&&this.madeProgress(),!0)}get done(){return this._done}get budget(){return this._budget}madeProgress(){return this._progressed=!0,this._done=this.elapsed>=this._budget&&this._enabled,this._done}get enabled(){return this._enabled}set enabled(e){this._enabled=e}reset(e){this._begin=this.now(),this._budget=e,this.resetProgress()}get remaining(){return Math.max(this._budget-this.elapsed,0)}now(){return performance.now()}get elapsed(){return this.now()-this._begin}resetProgress(){this._progressed=!1,this._done=!1}get hasProgressed(){return this._progressed}}const ne=new Hi;ne.enabled=!1;let Ui=class{remove(){}processQueue(){}schedule(e,t,i){try{if(de(t)){const s=he();return i?Promise.resolve(i(s)):Promise.reject(s)}return Rt(e(ne))}catch(s){return Promise.reject(s)}}reschedule(e,t,i){return this.schedule(e,t,i)}async scheduleGenerator(e,t,i){if(de(t)){const r=he();if(i)return i(r);throw r}const s=e(ne);for(;;){const r=s.next(ne),a=fe(r)?await r:r;if(de(t)){const l=he();if(i){const u=i(l),c=s.return(null);return fe(c)&&await De(c),u}const o=s.throw(l);throw fe(o)&&await De(o),l}if(a.done)return a.value}}};const Ji=new Ui,Wi="unsupported-query";class ps{constructor(e){this._changeHandle=null,this.capabilities={query:Kt},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._cache=e.cache??new Si,this.timeInfo=e.timeInfo,this.featureIdInfo=e.featureIdInfo,e.featureIdInfo.type==="object-id"&&(this.objectIdField=e.featureIdInfo.fieldName),this._changeHandle=this.featureStore.events.on("changed",()=>this._clearCache()),this.fieldsIndex=bt(e.fieldsIndex)?e.fieldsIndex:hi.fromJSON(e.fieldsIndex),!e.availableFields||e.availableFields.length===1&&e.availableFields[0]==="*"?this.availableFields=new Set(this.fieldsIndex.fields.map(t=>t.name)):this.availableFields=new Set(e.availableFields.map(t=>this.fieldsIndex.get(t)?.name).filter(t=>t!=null)),e.scheduler&&e.priority?this._frameTask=e.scheduler.registerTask(e.priority):this._frameTask=Ji}destroy(){this._changeHandle=ze(this._changeHandle),this._frameTask=ze(this._frameTask),this._clearCache(),vt(this._cache)}get featureAdapter(){return this.featureStore.featureAdapter}async executeQuery(e,t){const i=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryFeatureSet(e),i)}async executeQueryForCount(e={},t){const i=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForCount(e),i)}async executeQueryForExtent(e,t){const i=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForExtent(e),i)}async executeQueryForIds(e,t){return Array.from(await this.executeQueryForIdSet(e,t))}async executeQueryForIdSet(e,t){const i=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForIdSet(e),i)}async executeQueryForLatestObservations(e,t){const i=V(t);if(!this.timeInfo?.trackIdField)throw new b(Wi,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});return await this._frameTask.scheduleGenerator(()=>this._executeQueryForLatestObservations(e),i)}async executeQueryForOpaqueFeatures(e,t){const i=V(t);return(await this._frameTask.scheduleGenerator(()=>this._executeQuery(e,{}),i)).items}async executeAttributeBinsQuery(e,t){const i=V(t);return e=Y(e),await this._frameTask.scheduleGenerator(()=>this._executeAttributeBinsQuery(e),i)}async executeQueryForSummaryStatistics(e={},t,i){const s=V(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForSummaryStatistics(e,t),s)}async executeQueryForUniqueValues(e={},t,i){const s=V(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForUniqueValues(e,t),s)}async executeQueryForClassBreaks(e={},t,i){const s=V(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForClassBreaks(e,t),s)}async executeQueryForHistogram(e={},t,i){const s=V(i);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForHistogram(e,t),s)}async executeQueryForSnapping(e,t){const i=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForSnapping(e,i),i)}async fetchRecomputedExtents(e){const t=V(e);this._timeExtentPromise||=qi(this.timeInfo,this.featureStore);const[i,s]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return At(t),{fullExtent:i,timeExtent:s}}_clearCache(){this._cache.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async*_executeQueryFeatureSet(e){try{const t=yield*this._executeQuery(e,{});return yield,await t.createQueryResponse()}catch(t){if(t!==O)throw t;return await new A([],e,this).createQueryResponse()}}async*_executeQueryForCount(e){try{const t=yield*this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null});return yield,t.createQueryResponseForCount()}catch(t){if(t!==O)throw t;return 0}}async*_executeQueryForExtent(e){const t=e.outSR;try{const i=yield*this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null});yield;const s=i.size;if(!s)return{count:0,extent:null};const r=await this._getBounds(i.items,i.spatialReference,t??this.spatialReference);return yield,{count:s,extent:r}}catch(i){if(i===O)return{count:0,extent:null};throw i}}async*_executeQueryForIdSet(e){try{const t=yield*this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null});yield;const i=t.items,s=new Set;for(const r of i)s.add(t.featureAdapter.getObjectId(r));return s}catch(t){if(t===O)return new Set;throw t}}async*_executeQueryForLatestObservations(e){try{const t=yield*this._executeQuery(e,{});return yield,this._filterLatest(t),yield,await t.createQueryResponse()}catch(t){if(t!==O)throw t;return await new A([],e,this).createQueryResponse()}}async*_executeAttributeBinsQuery(e){let t;try{e=await Wt(e,this.definitionExpression,this.spatialReference),yield,e=await Di(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const i=yield*this._executeSceneFilterQuery(e);yield,t=yield*this._executeGeometryQuery(e,i),yield,this._executeAggregateIdsQuery(t),yield,this._executeObjectIdsQuery(t),yield,this._executeTimeQuery(t),yield,this._executeAttributesQuery(t),yield}catch(i){if(i!==O)throw i;t=new A([],e,this)}return await t.createQueryBinsResponse(e)}async*_executeQueryForSummaryStatistics(e={},t){const{field:i,normalizationField:s,valueExpression:r}=t,a=yield*this._executeQueryForStatistics(e,{field:i,normalizationField:s,valueExpression:r});return yield,await a.createSummaryStatisticsResponse(t)}async*_executeQueryForUniqueValues(e={},t){const{field:i,field2:s,field3:r,valueExpression:a}=t,l=yield*this._executeQueryForStatistics(e,{field:i,field2:s,field3:r,valueExpression:a});return yield,await l.createUniqueValuesResponse(t)}async*_executeQueryForClassBreaks(e,t){const{field:i,normalizationField:s,valueExpression:r}=t,a=yield*this._executeQueryForStatistics(e,{field:i,normalizationField:s,valueExpression:r});return yield,await a.createClassBreaksResponse(t)}async*_executeQueryForHistogram(e,t){const{field:i,normalizationField:s,valueExpression:r}=t,a=yield*this._executeQueryForStatistics(e,{field:i,normalizationField:s,valueExpression:r});return yield,await a.createHistogramResponse(t)}async*_executeQueryForSnapping(e,t){const{point:i,distance:s,returnEdge:r,vertexMode:a}=e;if(!r&&a==="none")return{candidates:[]};let l=Y(e.query);l=await Xt(l,this.definitionExpression,this.spatialReference),yield,l=await Re(l,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const o=!M(i.spatialReference,this.spatialReference);o&&(await le(i.spatialReference,this.spatialReference),yield);const u=typeof s=="number"?s:s.x,c=typeof s=="number"?s:s.y,d={xmin:i.x-u,xmax:i.x+u,ymin:i.y-c,ymax:i.y+c,spatialReference:i.spatialReference},h=o?q(d,this.spatialReference):d;if(!h)return{candidates:[]};const m=(await Ce(Be(i),null,{signal:t}))[0];yield;const f=(await Ce(Be(h),null,{signal:t}))[0];if(yield,m==null||f==null)return{candidates:[]};const y=await this._searchFeatures(xe(f.toJSON()));yield;const _=new A(y,l,this);this._executeObjectIdsQuery(_),yield,this._executeTimeQuery(_),yield,this._executeAttributesQuery(_),yield,yield*this._executeGeometryQueryForSnapping(_),yield;const w=m.toJSON(),I=o?q(w,this.spatialReference):w,S=o?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:s;return _.createSnappingResponse({...e,point:I,distance:S},l.returnZ,i.spatialReference)}async _getBounds(e,t,i){const s=Et($t(),Qt);return await this.featureStore.forEachBounds(e,r=>Vt(s,r)),Xi(s,t,i,this.spatialReference,this.hasZ)}_getFullExtent(){return this._fullExtentPromise||="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then(e=>this._getBounds(e,this.spatialReference,this.spatialReference)),this._fullExtentPromise}async _getAllFeaturesQueryEngineResult(e){return new A(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(this._allFeaturesPromise==null){const i=[];this._allFeaturesPromise=(async()=>await this.featureStore.forEach(s=>i.push(s)))().then(()=>ee(i))}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async*_executeQuery(e,t){e=Y(e),e=await Ze(e,this.definitionExpression,this.spatialReference),yield,e=await Re(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield,e={...e,...t};const i=yield*this._executeSceneFilterQuery(e);yield;const s=yield*this._executeGeometryQuery(e,i);return yield,this._executeAggregateIdsQuery(s),yield,this._executeObjectIdsQuery(s),yield,this._executeTimeQuery(s),yield,this._executeAttributesQuery(s),s}async*_executeSceneFilterQuery(e){if(e.sceneFilter==null)return null;const{outSR:t,returnGeometry:i,returnCentroid:s}=e,r=this.featureStore.featureSpatialReference,a=e.sceneFilter.geometry,l=r==null||M(r,a.spatialReference)?a:q(a,r);if(!l)return null;const o=i||s,u=H(t)&&!M(this.spatialReference,t)&&o?async f=>this._project(f,t):f=>f;yield;const c=this.featureAdapter,d=await this._searchFeatures(xe(l));if(yield,e.sceneFilter.spatialRelationship==="disjoint"){if(!d.length)return null;const f=new Set;for(const x of d)f.add(c.getObjectId(x));const y=await this._getAllFeatures();yield;const _=await W("esriSpatialRelDisjoint",l,this.geometryType,this.hasZ,this.hasM);yield;const w=x=>!f.has(c.getObjectId(x))||_(c.getGeometry(x)),I=yield*this._runSpatialFilter(y,w);yield;const S=new A(I,e,this);return await u(S)}if(!d.length)return new A([],e,this);if(this._canExecuteSinglePass(l,e))return await u(new A(d,e,this));const h=await W("esriSpatialRelContains",l,this.geometryType,this.hasZ,this.hasM);yield;const m=yield*this._runSpatialFilter(d,f=>h(c.getGeometry(f)));return yield,await u(new A(m,e,this))}async*_executeGeometryQuery(e,t){if(t!=null&&t.items.length===0)return t;const{geometry:i,outSR:s,returnGeometry:r,returnCentroid:a}=e,l=t?null:this._getCacheKey(e),o=l?this._cache.get(l):null;if(o)return new A(o,e,this);const u=H(s)&&!M(this.spatialReference,s),c=r||a,d=async S=>(u&&c&&await this._project(S,s),l&&this._cache.put(l,S.items),S),h=this.featureStore.featureSpatialReference,m=!i||h==null||M(h,i.spatialReference)?i:q(i,h);if(!m)return await d(t??await this._getAllFeaturesQueryEngineResult(e));yield;const f=this.featureAdapter;let y=await this._searchFeatures(xe(i));yield;const _=e.spatialRel??"esriSpatialRelIntersects";if(_==="esriSpatialRelDisjoint"){if(!y.length)return await d(t??await this._getAllFeaturesQueryEngineResult(e));const S=new Set;for(const R of y)S.add(f.getObjectId(R));let x;t!=null?x=t.items:(yield,x=await this._getAllFeatures(),yield);const g=await W(_,m,this.geometryType,this.hasZ,this.hasM);yield;const F=R=>!S.has(f.getObjectId(R))||g(f.getGeometry(R)),p=yield*this._runSpatialFilter(x,F);yield;const T=new A(p,e,this);return await d(T)}if(t!=null){const S=new Mt;y=y.filter(x=>Gt(t.items,x,t.items.length,S)>=0)}if(!y.length){const S=new A([],e,this);return l&&this._cache.put(l,S.items),S}if(this._canExecuteSinglePass(m,e))return await d(new A(y,e,this));const w=await W(_,m,this.geometryType,this.hasZ,this.hasM);yield;const I=yield*this._runSpatialFilter(y,S=>w(f.getGeometry(S)));return yield,await d(new A(I,e,this))}_executeAggregateIdsQuery(e){if(e.items.length===0||!e.query.aggregateIds?.length||this.aggregateAdapter==null)return;const t=new Set;for(const s of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(s).forEach(r=>t.add(r));const i=this.featureAdapter.getObjectId;e.items=e.items.filter(s=>t.has(i(s)))}_executeObjectIdsQuery(e){if(e.items.length===0||!e.query.objectIds?.length)return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter(s=>t.has(i(s)))}_executeTimeQuery(e){if(e.items.length===0)return;const t=Zi(this.timeInfo,e.query.timeExtent,this.featureAdapter);t!=null&&(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(e.items.length===0)return;const t=Z(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter(i=>t.testFeature(i,this.featureAdapter))}}async*_executeGeometryQueryForSnapping(e){const{query:t}=e,{spatialRel:i}=t;if(!e?.items?.length||!t.geometry||!i)return;const s=await W(i,t.geometry,this.geometryType,this.hasZ,this.hasM);yield;const r=this.featureAdapter,a=o=>s(r.getGeometry(o)),l=yield*this._runSpatialFilter(e.items,a);e.items=l}*_runSpatialFilter(e,t){if(!t)return e;if(this._frameTask==null)return e.filter(r=>t(r));let i=yield;const s=new Array;for(const r of e)t(r)&&s.push(r),i.madeProgress(),i.done&&(i=yield);return s}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:s}=this.timeInfo,r=s||i,a=new Map,l=this.featureAdapter.getAttribute;for(const o of e.items){const u=l(o,t),c=l(o,r),d=a.get(u);(!d||c>l(d,r))&&a.set(u,o)}e.items=Array.from(a.values())}_getCacheKey(e){const{geometry:t,spatialRel:i,returnGeometry:s,returnCentroid:r,outSR:a,resultType:l,cacheHint:o}=e;if(l!=="tile"&&!o)return null;const u=s||r;return H(a)&&!M(this.spatialReference,a)&&u?JSON.stringify([t,i,a]):JSON.stringify([t,i])}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return ut(e)&&(i==="esriSpatialRelEnvelopeIntersects"||this.geometryType==="esriGeometryPoint"&&(i==="esriSpatialRelIntersects"||i==="esriSpatialRelContains"))}async _project(e,t){if(!t||M(this.spatialReference,t))return e;const i=this.featureAdapter,s=zt()?await this._getFullExtent():void 0,r=await Yt(e.items.map(a=>Q(this.geometryType,this.hasZ,this.hasM,i.getGeometry(a))),this.spatialReference,t,{areaOfInterestExtent:s});return e.items=ee(r.map((a,l)=>i.cloneWithGeometry(e.items[l],Zt(a,this.hasZ,this.hasM)))),e}async _searchFeatures(e){const t=new Set;await Promise.all(e.map(s=>this.featureStore.forEachInBounds(s,r=>t.add(r))));const i=Array.from(t.values());return t.clear(),i}async*_executeQueryForStatistics(e,t){e=Y(e);try{e=await Ze(e,this.definitionExpression,this.spatialReference),yield,e=await Ni(e,t,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const i=yield*this._executeSceneFilterQuery(e);yield;const s=yield*this._executeGeometryQuery(e,i);return yield,this._executeAggregateIdsQuery(s),yield,this._executeObjectIdsQuery(s),yield,this._executeTimeQuery(s),yield,this._executeAttributesQuery(s),yield,s}catch(i){if(i!==O)throw i;return new A([],e,this)}}get test(){}}function xe(n){if(ut(n)){if(ve(n))return[Ne(Math.min(n.xmin,n.xmax),Math.min(n.ymin,n.ymax),Math.max(n.xmin,n.xmax),Math.max(n.ymin,n.ymax))];if(be(n))return n.rings.map(e=>Ne(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1])))}return[Pt(Dt(),n)]}function Xi(n,e,t,i,s){const r={xmin:n[0],ymin:n[1],xmax:n[3],ymax:n[4],spatialReference:te(i)};s&&isFinite(n[2])&&isFinite(n[5])&&(r.zmin=n[2],r.zmax=n[5],r.hasZ=!0);const a=q(r,e,t);if(a.spatialReference=te(t),a.xmax-a.xmin===0){const l=me(a.spatialReference);a.xmin-=l,a.xmax+=l}if(a.ymax-a.ymin===0){const l=me(a.spatialReference);a.ymin-=l,a.ymax+=l}if(s&&a.zmin!=null&&a.zmax!=null&&a.zmax-a.zmin===0){const l=me(a.spatialReference);a.zmin-=l,a.zmax+=l}return a}export{A as E,W as I,ps as W,Xi as Y,te as h,Zi as l};
