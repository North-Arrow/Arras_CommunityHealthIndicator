import{c3 as j,eb as v,ec as w,ed as B,cU as $,ci as _,B as q,aZ as z,ee as I,bP as P,ef as U,dL as f,_ as n,z as i,A as k}from"./MapPage-B4quncaN.js";import{j as C,P as D,h as F,B as G}from"./mat4-DOVrAuAl.js";import{b as c,x as H,v as M}from"./quat-SrO1bAnD.js";import{e as m}from"./quatf64-aQ5IuZRd.js";import{s as L}from"./vec32-DOjeO21V.js";function s(t=g){return[t[0],t[1],t[2],t[3]]}function u(t,o,r=s()){return L(r,t),r[3]=o,r}function Q(t,o=s()){const r=C(a,t);return N(o,$(M(o,r))),o}function x(t,o,r=s()){return c(a,t,p(t)),c(y,o,p(o)),H(a,y,a),N(r,$(M(r,a)))}function R(t,o,r,h=s()){return u(v,t,l),u(w,o,b),u(B,r,A),x(l,b,l),x(l,A,h),h}function S(t){return t}function T(t){return t[3]}function p(t){return j(t[3])}function N(t,o){return t[3]=o,t}const g=[0,0,1,0],a=m(),y=m();s();const l=s(),b=s(),A=s();let e=class extends _(q){constructor(t){super(t),this.translation=z(),this.rotationAxis=I(g),this.rotationAngle=0,this.scale=P(1,1,1)}get rotation(){return u(this.rotationAxis,this.rotationAngle)}set rotation(t){this.rotationAxis=U(t),this.rotationAngle=T(t)}get localMatrix(){const t=f();return c(d,this.rotation,p(this.rotation)),D(t,d,this.translation,this.scale),t}get localMatrixInverse(){return F(f(),this.localMatrix)}equals(t){return this===t||t!=null&&G(this.localMatrix,t.localMatrix)}};n([i({type:[Number],nonNullable:!0,json:{write:!0}})],e.prototype,"translation",void 0),n([i({type:[Number],nonNullable:!0,json:{write:!0}})],e.prototype,"rotationAxis",void 0),n([i({type:Number,nonNullable:!0,json:{write:!0}})],e.prototype,"rotationAngle",void 0),n([i({type:[Number],nonNullable:!0,json:{write:!0}})],e.prototype,"scale",void 0),n([i()],e.prototype,"rotation",null),n([i()],e.prototype,"localMatrix",null),n([i()],e.prototype,"localMatrixInverse",null),e=n([k("esri.geometry.support.MeshTransform")],e);const d=m();export{R as U,Q as a,e as d,s as j,S as w,p as z};
