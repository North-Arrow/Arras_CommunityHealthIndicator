import{c as $,U as tt,X as et,bQ as G,bR as E}from"./MapPage-ILsU69jC.js";const W=()=>tt.getLogger("esri.views.2d.engine.flow.dataUtils"),nt=10;async function ft(d,n,w,p){const c=performance.now(),g=ot(n,w),a=performance.now(),s=st(n,g,w.width,w.height),e=performance.now(),t=it(s),o=performance.now(),y=d==="Streamlines"?ct(t,nt):at(t),M=performance.now();return $("esri-2d-profiler")&&(W().info("I.1","_createFlowFieldFromData (ms)",Math.round(a-c)),W().info("I.2","_getStreamlines (ms)",Math.round(e-a)),W().info("I.3","createAnimatedLinesData (ms)",Math.round(o-e)),W().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(M-o)),W().info("I.5","createFlowMesh (ms)",Math.round(M-c)),W().info("I.6","Mesh size (bytes)",y.vertexData.buffer.byteLength+y.indexData.buffer.byteLength)),await Promise.resolve(),et(p),y}function ot(d,n){const w=lt(n.data,n.width,n.height,d.smoothing);return d.interpolate?(p,c)=>{const g=Math.floor(p),a=Math.floor(c);if(g<0||g>=n.width)return[0,0];if(a<0||a>=n.height)return[0,0];const s=p-g,e=c-a,t=g,o=a,y=g<n.width-1?g+1:g,M=a<n.height-1?a+1:a,r=w[2*(o*n.width+t)],f=w[2*(o*n.width+y)],A=w[2*(M*n.width+t)],F=w[2*(M*n.width+y)],x=w[2*(o*n.width+t)+1],u=w[2*(o*n.width+y)+1];return[(r*(1-e)+A*e)*(1-s)+(f*(1-e)+F*e)*s,(x*(1-e)+w[2*(M*n.width+t)+1]*e)*(1-s)+(u*(1-e)+w[2*(M*n.width+y)+1]*e)*s]}:(p,c)=>{const g=Math.round(p),a=Math.round(c);return g<0||g>=n.width||a<0||a>=n.height?[0,0]:[w[2*(a*n.width+g)],w[2*(a*n.width+g)+1]]}}function B(d,n,w,p,c,g,a,s){const e=[],{raster:t,width:o,height:y,resolutionFactor:M}=s;let r=p,f=c,A=0,[F,x]=w(r,f);F*=n.velocityScale,x*=n.velocityScale;const u=Math.sqrt(F*F+x*x);let h,m;e.push({x:r,y:f,t:A,speed:u});for(let l=0;l<n.verticesPerLine;l++){let[i,I]=w(r,f);i*=n.velocityScale,I*=n.velocityScale;const v=Math.sqrt(i*i+I*I);if(v<n.minSpeedThreshold)return e;const D=d*i/v,z=d*I/v;if(r+=D*n.segmentLength,f+=z*n.segmentLength,n.wrapAround&&(r=E(r,g[0])),A+=d*n.segmentLength/v,Math.acos(D*h+z*m)>n.maxTurnAngle)return e;if(n.collisions){let q=Math.round(r*M);const P=Math.round(f*M);if(n.wrapAround&&(q=E(q,o)),q<0||q>o-1||P<0||P>y-1)return e;const _=t[P*o+q];if(_!==-1&&_!==a)return e;t[P*o+q]=a}e.push({x:r,y:f,t:A,speed:v}),h=D,m=z}return e}function rt(d,n,w,p,c,g,a,s){const e=Math.round((.2+.6*a.getFloat())*d.verticesPerLine),t=d.verticesPerLine-e,o=B(-1,{...d,verticesPerLine:t},n,w,p,c,g,s),y=B(1,{...d,verticesPerLine:e},n,w,p,c,g,s),M=o.reverse();return M.splice(-1,1),M.concat(y)}function st(d,n,w,p,c={positions:[]}){if(d.density<=0)return[];const{positions:g}=c,a=[],s=new G,e=1/Math.max(d.lineCollisionWidth,1),t=Math.round(w*e),o=Math.round(p*e),y=new Int32Array(t*o);for(let u=0;u<y.length;u++)y[u]=-1;const M={raster:y,width:t,height:o,resolutionFactor:e},r={},f=d.lineSpacing/Math.sqrt(d.density),A=Math.floor(p/f),F=Math.floor(w/f);for(let u=0;u<A;u++){const h=u*f;for(let m=0;m<F;m++){const l=m*f;r[`${m}-${u}`]={x:l,y:h,positions:[]}}}for(const{x:u,y:h}of g){const m=r[`${Math.floor(u/f)}-${Math.floor(h/f)}`];m&&m.positions.push([u,h])}const x=[];for(const u in r){const h=r[u];if(h.positions.length===0)x.push({x:h.x+f/2,y:h.y+f/2,sort:.66+.33*s.getFloat(),stage:0});else{const[m]=h.positions.splice(0,1);x.push({x:m[0],y:m[1],sort:.33*s.getFloat(),stage:1});for(const[l,i]of h.positions)x.push({x:l,y:i,sort:.33+.33*s.getFloat(),stage:2})}}x.sort((u,h)=>u.sort-h.sort);for(const{x:u,y:h,stage:m}of x){const l=d.onlyForwardTracing?B(1,d,n,u,h,[w,p],a.length,M):rt(d,n,u,h,[w,p],a.length,s,M);l.length<2||a.push({stage:m,vertices:l})}return a}function lt(d,n,w,p){if(p===0)return d;const c=Math.round(3*p),g=new Array(2*c+1);let a=0;for(let t=-c;t<=c;t++){const o=Math.exp(-t*t/(p*p));g[t+c]=o,a+=o}for(let t=-c;t<=c;t++)g[t+c]/=a;const s=new Float32Array(d.length);for(let t=0;t<w;t++)for(let o=0;o<n;o++){let y=0,M=0;for(let r=-c;r<=c;r++){if(o+r<0||o+r>=n)continue;const f=g[r+c];y+=f*d[2*(t*n+(o+r))],M+=f*d[2*(t*n+(o+r))+1]}s[2*(t*n+o)]=y,s[2*(t*n+o)+1]=M}const e=new Float32Array(d.length);for(let t=0;t<n;t++)for(let o=0;o<w;o++){let y=0,M=0;for(let r=-c;r<=c;r++){if(o+r<0||o+r>=w)continue;const f=g[r+c];y+=f*s[2*((o+r)*n+t)],M+=f*s[2*((o+r)*n+t)+1]}e[2*(o*n+t)]=y,e[2*(o*n+t)+1]=M}return e}function it(d,n){const w=new G,p=d.reduce((e,t)=>e+t.vertices.length,0),c=new Float32Array(4*p),g=new Array(d.length);let a=0,s=0;for(const{vertices:e}of d){const t=a;for(const o of e)c[4*a]=o.x,c[4*a+1]=o.y,c[4*a+2]=o.t,c[4*a+3]=o.speed,a++;g[s++]={startVertex:t,numberOfVertices:e.length,totalTime:e[e.length-1].t,timeSeed:w.getFloat()}}return{lineVertices:c,lineDescriptors:g}}function ct(d,n){const{lineVertices:p,lineDescriptors:c}=d;let g=0,a=0;for(const r of c)g+=2*r.numberOfVertices,a+=6*(r.numberOfVertices-1);const s=new Float32Array(g*9),e=new Uint32Array(a);let t=0,o=0;function y(){e[o++]=t-2,e[o++]=t,e[o++]=t-1,e[o++]=t,e[o++]=t+1,e[o++]=t-1}function M(r,f,A,F,x,u,h,m){const l=t*9;let i=0;s[l+i++]=r,s[l+i++]=f,s[l+i++]=1,s[l+i++]=A,s[l+i++]=u,s[l+i++]=h,s[l+i++]=F/2,s[l+i++]=x/2,s[l+i++]=m,t++,s[l+i++]=r,s[l+i++]=f,s[l+i++]=-1,s[l+i++]=A,s[l+i++]=u,s[l+i++]=h,s[l+i++]=-F/2,s[l+i++]=-x/2,s[l+i++]=m,t++}for(const r of c){const{totalTime:f,timeSeed:A}=r;let F=null,x=null,u=null,h=null,m=null,l=null;for(let i=0;i<r.numberOfVertices;i++){const I=p[4*(r.startVertex+i)],v=p[4*(r.startVertex+i)+1],D=p[4*(r.startVertex+i)+2],z=p[4*(r.startVertex+i)+3];let q=null,P=null,_=null,Q=null;if(i>0){q=I-F,P=v-x;const b=Math.sqrt(q*q+P*P);if(q/=b,P/=b,i>1){let V=q+m,S=P+l;const L=Math.sqrt(V*V+S*S);V/=L,S/=L;const k=Math.min(1/(V*q+S*P),n);V*=k,S*=k,_=-S,Q=V}else _=-P,Q=q;_!==null&&Q!==null&&(M(F,x,u,_,Q,f,A,z),y())}F=I,x=v,u=D,m=q,l=P,h=z}M(F,x,u,-l,m,f,A,h)}return{vertexData:s,indexData:e}}function at(d){const{lineVertices:c,lineDescriptors:g}=d;let a=0,s=0;for(const b of g){const V=b.numberOfVertices-1;a+=4*V*2,s+=6*V*2}const e=new Float32Array(a*16),t=new Uint32Array(s);let o,y,M,r,f,A,F,x,u,h,m,l,i,I,v=0,D=0;function z(){t[D++]=v-8,t[D++]=v-7,t[D++]=v-6,t[D++]=v-7,t[D++]=v-5,t[D++]=v-6,t[D++]=v-4,t[D++]=v-3,t[D++]=v-2,t[D++]=v-3,t[D++]=v-1,t[D++]=v-2}function q(b,V,S,L,k,R,U,C,X,j,H,J,K,N){const O=v*16;let T=0;for(const Y of[1,2])for(const Z of[1,2,3,4])e[O+T++]=b,e[O+T++]=V,e[O+T++]=S,e[O+T++]=L,e[O+T++]=U,e[O+T++]=C,e[O+T++]=X,e[O+T++]=j,e[O+T++]=Y,e[O+T++]=Z,e[O+T++]=K,e[O+T++]=N,e[O+T++]=k/2,e[O+T++]=R/2,e[O+T++]=H/2,e[O+T++]=J/2,v++}function P(b,V){let S=u+m,L=h+l;const k=Math.sqrt(S*S+L*L);S/=k,L/=k;const R=u*S+h*L;S/=R,L/=R;let U=m+i,C=l+I;const X=Math.sqrt(U*U+C*C);U/=X,C/=X;const j=m*U+l*C;U/=j,C/=j,q(o,y,M,r,-L,S,f,A,F,x,-C,U,b,V),z()}function _(b,V,S,L,k,R){if(u=m,h=l,m=i,l=I,u==null&&h==null&&(u=m,h=l),f!=null&&A!=null){i=b-f,I=V-A;const U=Math.sqrt(i*i+I*I);i/=U,I/=U}u!=null&&h!=null&&P(k,R),o=f,y=A,M=F,r=x,f=b,A=V,F=S,x=L}function Q(b,V){u=m,h=l,m=i,l=I,u==null&&h==null&&(u=m,h=l),u!=null&&h!=null&&P(b,V)}for(const b of g){o=null,y=null,M=null,r=null,f=null,A=null,F=null,x=null,u=null,h=null,m=null,l=null,i=null,I=null;const{totalTime:V,timeSeed:S}=b;for(let L=0;L<b.numberOfVertices;L++)_(c[4*(b.startVertex+L)],c[4*(b.startVertex+L)+1],c[4*(b.startVertex+L)+2],c[4*(b.startVertex+L)+3],V,S);Q(V,S)}return{vertexData:e,indexData:t}}export{ft as c,st as d,ot as f};
