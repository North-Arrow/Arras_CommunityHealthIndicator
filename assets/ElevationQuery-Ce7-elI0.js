import{_ as ue}from"./asyncUtils-7u0K-vRc.js";import{gp as fe,gq as B,cH as V,b9 as he,aK as z,fK as pe,bN as me,U as H,_ as y,A as M,fg as J,S as de,b1 as ye,em as E,f1 as xe,z as R,s as v,gr as ve,ao as Q,fB as C,f as X}from"./MapPage-bO_zd9Tg.js";import{N as S,W as b}from"./projectionUtils-EGAhLdsv.js";import{e as k}from"./TileInfo-C2T9GIaa.js";import"./index-zO8SwWrM.js";import"./themeLevelStore-Cm1Q3Xu0.js";class Y{constructor(e,i){this.layer=e,this.parameters=i}}let we=class extends Y{constructor(e,i,n){super(e,n),this.outSpatialReference=i,this.type="geometry"}selectTilesAtLOD(e){if(e<0)this.geometry.coordinates.forEach(i=>i.tile=null);else{const{tileInfo:i,tilemapCache:n}=this.layer,a=I(i,n)[e].level;this.geometry.coordinates.forEach(l=>l.tile=i.tileAt(a,l.x,l.y))}}allElevationTilesFetched(){return!this.geometry.coordinates.some(e=>!e.elevationTile)}clearElevationTiles(){for(const e of this.geometry.coordinates)e.elevationTile!==this.outsideExtentTile&&(e.elevationTile=null)}populateElevationTiles(e){for(const i of this.geometry.coordinates)!i.elevationTile&&i.tile?.id&&(i.elevationTile=e[i.tile.id])}remapTiles(e){for(const i of this.geometry.coordinates){const n=i.tile?.id;i.tile=n?e[n]:null}}getTilesToFetch(){return fe(this.geometry.coordinates.filter(({tile:e,elevationTile:i})=>e?.id&&!i),(e,i)=>e.tile?.id===i.tile?.id).map(({tile:e})=>e)}forEachTileToFetch(e){for(const i of this.geometry.coordinates)i.tile&&!i.elevationTile&&e(i.tile,()=>i.tile=null)}};class ge extends Y{constructor(e,i,n,a){super(e,n),this.maskExtents=a,this.type="extent",this.elevationTiles=[],this._candidateTiles=[],this._fetchedCandidates=new Set,this.extent=i.clone().intersection(e.fullExtent)}selectTilesAtLOD(e,i){const n=this._maximumLodForRequests(i),a=Math.min(n,e);a<0?this._candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(a)}_maximumLodForRequests(e){const{tileInfo:i,tilemapCache:n}=this.layer,a=I(i,n);if(!e)return a.length-1;const l=this.extent;if(l==null)return-1;for(let s=a.length-1;s>=0;s--){const o=a[s],r=o.resolution*i.size[0],u=o.resolution*i.size[1];if(Math.ceil(l.width/r)*Math.ceil(l.height/u)<=e)return s}return-1}allElevationTilesFetched(){return this._candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this._fetchedCandidates.clear()}populateElevationTiles(e){for(const i of this._candidateTiles){const n=i.id&&e[i.id];n&&(this._fetchedCandidates.add(i),this.elevationTiles.push(n))}}remapTiles(e){this._candidateTiles=U(this._candidateTiles.map(i=>e[i.id]))}getTilesToFetch(){return this._candidateTiles}forEachTileToFetch(e,i){const n=this._candidateTiles;this._candidateTiles=[],n.forEach(a=>{if(this._fetchedCandidates.has(a))return void i?.(a);let l=!1;e(a,()=>l=!0),l?i?.(a):this._candidateTiles.push(a)}),this._candidateTiles=U(this._candidateTiles,i)}_selectCandidateTilesCoveringExtentAt(e){this._candidateTiles.length=0;const i=this.extent;if(i==null)return;const{tileInfo:n,tilemapCache:a}=this.layer,l=I(n,a)[e],s=n.tileAt(l.level,i.xmin,i.ymin),o=s.extent,r=l.resolution*n.size[0],u=l.resolution*n.size[1],c=Math.ceil((i.xmax-o[0])/r),f=Math.ceil((i.ymax-o[1])/u);for(let p=0;p<f;p++)for(let h=0;h<c;h++){const w=new k(s.level,s.row-p,s.col+h);n.updateTileInfo(w),this._tileIsMasked(w)||this._candidateTiles.push(w)}}_tileIsMasked(e){return this.maskExtents?.some(i=>B(i,e.extent))??!1}}function F(t){return t?.tileInfo!=null}function I(t,e){const i=t.lods;if(F(e)){const{effectiveMinLOD:n,effectiveMaxLOD:a}=e;return i.filter(l=>l.level>=n&&l.level<=a)}return i}function U(t,e){const i={},n=[];for(const l of t){const s=l.id;s&&!i[s]?(i[s]=l,n.push(l)):e?.(l)}const a=n.sort((l,s)=>l.level-s.level);return a.filter((l,s)=>{for(let o=0;o<s;o++){const r=a[o].extent;if(r&&B(r,l.extent))return e?.(l),!1}return!0})}let Te=class{constructor(e,i){this.data=e,this.safeWidth=.99999999*(e.width-1),this.dx=(e.width-1)/(i[2]-i[0]),this.dy=(e.width-1)/(i[3]-i[1]),this.x0=i[0],this.y1=i[3]}};class ee{constructor(e,i=null){if(this.key=e,i!=null){const n=e.extent;this._samplerData=new Te(i,n)}}get zmin(){return this._samplerData!=null?this._samplerData.data.minValue:0}get zmax(){return this._samplerData!=null?this._samplerData.data.maxValue:0}get hasNoDataValues(){return!!this._samplerData?.data.hasNoDataValues}sample(e,i){if(this._samplerData==null)return;const{safeWidth:n,data:a,dx:l,dy:s,y1:o,x0:r}=this._samplerData,{width:u,values:c,noDataValue:f}=a,p=K(s*(o-i),0,n),h=K(l*(e-r),0,n),w=Math.floor(p),Z=Math.floor(h),A=w*u+Z,j=A+u,$=c[A],q=c[j],N=c[A+1],G=c[j+1];if($!==f&&q!==f&&N!==f&&G!==f){const P=h-Z,W=$+(N-$)*P;return W+(q+(G-q)*P-W)*(p-w)}}}function K(t,e,i){return t<e?e:t>i?i:t}class x{constructor(e){this.geometry=e,this.spatialReference=e.spatialReference}export(){return this._exporter(this.coordinates,this.spatialReference)}clone(e){const i=new x(this.geometry);return i.spatialReference=this.spatialReference,i.coordinates=e??this.coordinates.map(n=>n.clone()),i._exporter=this._exporter,i}async project(e,i){if(this.spatialReference.equals(e))return this.clone();await S([{source:this.spatialReference,dest:e}],{signal:i});const n=new V({spatialReference:this.spatialReference,points:this.coordinates.map(o=>[o.x,o.y])}),a=b(n,e);if(!a)return null;const l=this.coordinates.map((o,r)=>{const u=o.clone(),c=a.points[r];return u.x=c[0],u.y=c[1],u}),s=this.clone(l);return s.spatialReference=e,s}static fromGeometry(e){const i=new x(e);if(e instanceof x)return i.coordinates=e.coordinates.map(n=>n.clone()),i._exporter=(n,a)=>{const l=e.clone(n);return l.spatialReference=a,l},i;switch(e.type){case"point":{const n=e,{hasZ:a,hasM:l}=n;return i.coordinates=a&&l?[new m(n.x,n.y,n.z,n.m)]:a?[new m(n.x,n.y,n.z)]:l?[new m(n.x,n.y,null,n.m)]:[new m(n.x,n.y)],i._exporter=(s,o)=>e.hasM?new z(s[0].x,s[0].y,s[0].z,s[0].m,o):new z(s[0].x,s[0].y,s[0].z,o),i}case"multipoint":{const n=e,{hasZ:a,hasM:l}=n;return i.coordinates=a&&l?n.points.map(s=>new m(s[0],s[1],s[2],s[3])):a?n.points.map(s=>new m(s[0],s[1],s[2])):l?n.points.map(s=>new m(s[0],s[1],null,s[2])):n.points.map(s=>new m(s[0],s[1])),i._exporter=(s,o)=>e.hasM?new V({points:s.map(r=>[r.x,r.y,r.z??0,r.m??0]),hasZ:!0,hasM:!0,spatialReference:o}):new V({points:s.map(r=>[r.x,r.y,r.z??0]),spatialReference:o}),i}case"polyline":{const n=e,a=[],l=[],{hasZ:s,hasM:o}=e;let r=0;for(const u of n.paths)if(l.push([r,r+u.length]),r+=u.length,s&&o)for(const c of u)a.push(new m(c[0],c[1],c[2],c[3]));else if(s)for(const c of u)a.push(new m(c[0],c[1],c[2]));else if(o)for(const c of u)a.push(new m(c[0],c[1],null,c[2]));else for(const c of u)a.push(new m(c[0],c[1]));return i.coordinates=a,i._exporter=(u,c)=>{const f=e.hasM?u.map(h=>[h.x,h.y,h.z??0,h.m??0]):u.map(h=>[h.x,h.y,h.z??0]),p=l.map(h=>f.slice(h[0],h[1]));return new he({paths:p,hasM:e.hasM,hasZ:!0,spatialReference:c})},i}}}}let m=class te{constructor(e,i,n=null,a=null,l=null,s=null){this.x=e,this.y=i,this.z=n,this.m=a,this.tile=l,this.elevationTile=s}clone(){return new te(this.x,this.y,this.z,this.m)}},D=class extends pe{queryElevation(t){const e=this.projectIfRequired(t,this.spatialReference);if(!e)return null;switch(t.type){case"point":return Re(t,e,this);case"polyline":return Ie(t,e,this);case"multipoint":return De(t,e,this);default:return null}}projectIfRequired(t,e){if(t==null)return null;const i=t.spatialReference;if(i.equals(e))return t;const n=me(t,e);return n||H.getLogger(this).error(`Cannot project geometry spatial reference (wkid:${i.wkid}) to elevation sampler spatial reference (wkid:${e.wkid})`),n}};function Re(t,e,i){return t.hasZ=!0,t.z=i.elevationAt(e.x,e.y),t}function Ie(t,e,i){d.spatialReference=e.spatialReference;const n=t.hasM&&!t.hasZ;for(let a=0;a<t.paths.length;a++){const l=t.paths[a],s=e.paths[a];for(let o=0;o<l.length;o++){const r=l[o],u=s[o];d.x=u[0],d.y=u[1],n&&(r[3]=r[2]),r[2]=i.elevationAt(d.x,d.y)}}return t.hasZ=!0,t}function De(t,e,i){d.spatialReference=e.spatialReference;const n=t.hasM&&!t.hasZ;for(let a=0;a<t.points.length;a++){const l=t.points[a],s=e.points[a];d.x=s[0],d.y=s[1],n&&(l[3]=l[2]),l[2]=i.elevationAt(d.x,d.y)}return t.hasZ=!0,t}D=y([M("esri.layers.support.ElevationSampler")],D);const d=new z;let T=class extends D{get spatialReference(){return this.extent.spatialReference}constructor(t){const e=t.noDataValue,i="tiles"in t?t.tiles.map(a=>new g({tile:a,tileInfo:t.tileInfo,noDataValue:e})):t.samplers;super({noDataValue:e,samplers:i});const n=i[0];if(n){this.extent=n.extent.clone();const{min:a,max:l}=n.demResolution;this.demResolution={min:a,max:l};for(let s=1;s<i.length;s++){const o=i[s];this.extent.union(o.extent),this.demResolution.min=Math.min(this.demResolution.min,o.demResolution.min),this.demResolution.max=Math.max(this.demResolution.max,o.demResolution.max)}}else{const a="tileInfo"in t?t.tileInfo:null;this.extent=J(ye(),a?.spatialReference??de.WGS84),this.demResolution={min:0,max:0}}}elevationAt(t,e){let i;for(const n of this.samplers)if(n.containsAt(t,e)&&(i=n.elevationAt(t,e),i!==n.noDataValue))return i;return i??(H.getLogger(this).warn("#elevationAt()",`Point used to sample elevation (${t}, ${e}) is outside of the sampler`),this.noDataValue)}};y([R({constructOnly:!0})],T.prototype,"noDataValue",void 0),y([R({constructOnly:!0})],T.prototype,"samplers",void 0),T=y([M("esri.layers.support.TileElevationSampler")],T);let g=class extends D{get spatialReference(){return this.extent.spatialReference}constructor(t){super(t);const e=t.tile.key.extent;this.extent=J(e,t.tileInfo.spatialReference),this.extent.zmin=t.tile.zmin,this.extent.zmax=t.tile.zmax;const i=E(t.tileInfo.spatialReference),n=t.tileInfo.lodAt(t.tile.key.level).resolution*i;this.demResolution={min:n,max:n}}contains(t){const e=this.projectIfRequired(t,this.spatialReference);return e!=null&&this.containsAt(e.x,e.y)}containsAt(t,e){return xe(this.tile.key.extent,t,e)}elevationAt(t,e){return this.containsAt(t,e)?this.tile.sample(t,e)??this.noDataValue:this.noDataValue}};y([R({constructOnly:!0})],g.prototype,"tile",void 0),y([R({constructOnly:!0})],g.prototype,"noDataValue",void 0),y([R({constructOnly:!0})],g.prototype,"tileInfo",void 0),g=y([M("esri.layers.support.TileElevationSampler.SingleTileElevationSampler")],g);async function Pe(t,e,i){if(t=i?.ignoreInvisibleLayers?t.filter(r=>r.visible):t.slice(),!t.length)throw new v(O,"Elevation queries require at least one elevation layer to fetch tiles from");const n=x.fromGeometry(e),a={...L,...i,returnSampleInfo:!0},l=t.pop(),s=await ie(l,n,a),o=await se(t,s,a);return o.geometry=o.geometry.export(),i?.returnSampleInfo||delete o.sampleInfo,o}async function ie(t,e,i){if(!t)throw new v(O,"Elevation queries require an elevation layer to fetch tiles from");if(!e||!(e instanceof x)&&e.type!=="point"&&e.type!=="multipoint"&&e.type!=="polyline")throw new v("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");const n={...L,...i},a=new we(t,e.spatialReference,n),l=n.signal;return await t.load({signal:l}),await Ae(a,e,l),await le(a,l),await _(a,l),Ce(a),Se(a,l)}async function We(t,e,i){if(t=Array.isArray(t)?t:[t],(t=i?.ignoreInvisibleLayers?t.filter(l=>l.visible):t.slice()).length===0)throw new v(O,"Elevation queries require at least one elevation layer to fetch tiles from");if(!e||e.type!=="extent")throw new v("elevation-query:invalid-extent","Invalid or undefined extent");const n={...L,...i,returnSampleInfo:!0},a=ne(t[t.length-1],e,n);return t.length===1?a:ae(t,e,await a,n)}async function ne(t,e,i,n){const a=i.signal;await t.load({signal:a});const l=e.spatialReference,s=t.tileInfo.spatialReference;l.equals(s)||(await S([{source:l,dest:s}],{signal:a}),e=b(e,s));const o=new ge(t,e,i,n);await le(o,a),await _(o,a);const r=o.elevationTiles,u=o.layer.tileInfo,c=o.parameters.noDataValue;return new T({noDataValue:c,tiles:r,tileInfo:u})}async function ae(t,e,i,n){if(t.pop(),!t.length)return i;const a=i.samplers.filter(r=>!r.tile.hasNoDataValues).map(r=>ve(r.extent)),l=await ne(t[t.length-1],e,n,a);if(l.samplers.length===0)return i;const s=i.samplers.concat(l.samplers),o=n.noDataValue;return ae(t,e,new T({samplers:s,noDataValue:o}),n)}async function se(t,e,i){const n=e.geometry.coordinates,a=e.sampleInfo;Q(a);const l=new Array,s=new Array;for(let f=0;f<n.length;f++)a[f].demResolution<0&&t.length&&(l.push(n[f]),s.push(f));const o=t.pop();if(o==null||l.length===0)return e;const r=e.geometry.clone(l),u=await ie(o,r,i),c=u.sampleInfo;if(!c)throw new Error("no sampleInfo");return s.forEach((f,p)=>{n[f].z=u.geometry.coordinates[p].z,a[f].demResolution=c[p].demResolution,a[f].source=c[p].source}),se(t,e,i)}async function le(t,e){t.type==="geometry"&&$e(t);const i=t.parameters.demResolution;if(typeof i=="number")Ve(t,i);else if(i==="finest-contiguous")await Ee(t,e);else{if(i!=="auto")throw new v("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${i}', expected a number, "finest-contiguous" or "auto"`);await _e(t,e)}}async function Ee(t,e){const{tileInfo:i,tilemapCache:n}=t.layer,a=ce(i,n,t.parameters.minDemResolution);await oe(t,a,e)}async function oe(t,e,i){const n=t.layer;if(t.selectTilesAtLOD(e),e<0)return;const a=n.tilemapCache,l=t.getTilesToFetch();try{if(a&&!F(a))await C(Promise.all(l.map(s=>a.fetchAvailability(s.level,s.row,s.col,{signal:i}))),i);else if(await _(t,i),!t.allElevationTilesFetched())throw t.clearElevationTiles(),new v("elevation-query:has-unavailable-tiles","Some elevation tiles are unavailable")}catch(s){X(s),await oe(t,e-1,i)}}async function _e(t,e){ze(t),Me(t);const i=t.layer.tilemapCache;if(!i||F(i))return re(t,e);const n=t.getTilesToFetch(),a={},l=n.map(async s=>{const o=new k(0,0,0),r=await ue(i.fetchAvailabilityUpsample(s.level,s.row,s.col,o,{signal:e}));r.ok!==!1?s.id!=null&&(a[s.id]=o):X(r.error)});await C(Promise.all(l),e),t.remapTiles(a)}async function re(t,e){const i=t.layer.tileInfo;await _(t,e);let n=!1;t.forEachTileToFetch((a,l)=>{i.upsampleTile(a)?n=!0:l()}),n&&await re(t,e)}function ce(t,e,i=0){const n=I(t,e);let a=n.length-1;if(i>0){const l=i/E(t.spatialReference),s=n.findIndex(o=>o.resolution<l);s===0?a=0:s>0&&(a=s-1)}return a}const L={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0,signal:null};async function Ae(t,e,i){let n;const a=t.layer.tileInfo.spatialReference;if(e instanceof x?n=await e.project(a,i):(await S([{source:e.spatialReference,dest:a}],{signal:i}),n=b(e,a)),!n)throw new v("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${e.spatialReference.wkid}' on an elevation service in '${a.wkid}'`);t.geometry=x.fromGeometry(n)}function $e(t){if(t.layer.fullExtent==null)return;const e=new ee(new k(-1,-1,-1));e.sample=()=>t.parameters.noDataValue,t.outsideExtentTile=e;const i=t.layer.fullExtent;t.geometry.coordinates.forEach(n=>{const a=n.x,l=n.y;(a<i.xmin||a>i.xmax||l<i.ymin||l>i.ymax)&&(n.elevationTile=e)})}function qe(t,e){const{tileInfo:i,tilemapCache:n}=t.layer,a=e/E(i.spatialReference),l=I(i,n);let s=l[0],o=0;for(let r=1;r<l.length;r++){const u=l[r];Math.abs(u.resolution-a)<Math.abs(s.resolution-a)&&(s=u,o=r)}return o}function Ve(t,e){const i=qe(t,e);t.selectTilesAtLOD(i)}function ze(t){const{tileInfo:e,tilemapCache:i}=t.layer,n=ce(e,i,t.parameters.minDemResolution);t.selectTilesAtLOD(n,t.parameters.maximumAutoTileRequests)}async function _(t,e){const i=t.getTilesToFetch(),n={},a=t.parameters.cache,l=t.parameters.noDataValue,s={noDataValue:l,signal:e},o=i.map(async r=>{if(r.id==null)return;const u=`${t.layer.uid}:${r.id}:${l}`,c=a?.get(u),f=c??await t.layer.fetchTile(r.level,r.row,r.col,s);a?.put(u,f),n[r.id]=new ee(r,f)});await C(Promise.allSettled(o),e),t.populateElevationTiles(n)}function Me(t){const e=t.layer.tileInfo;let i=0;const n={},a=o=>{o.id!=null&&(o.id in n?n[o.id]++:(n[o.id]=1,i++))},l=o=>{if(o.id==null)return;const r=n[o.id];r===1?(delete n[o.id],i--):n[o.id]=r-1};t.forEachTileToFetch(a,l);let s=!0;for(;s&&(s=!1,t.forEachTileToFetch(o=>{i<=t.parameters.maximumAutoTileRequests||(l(o),e.upsampleTile(o)&&(s=!0),a(o))},l),s););}function Ce(t){t.geometry.coordinates.forEach(e=>{const i=e.elevationTile;let n=t.parameters.noDataValue;if(i){const a=i.sample(e.x,e.y);a==null?e.elevationTile=null:n=a}e.z=n})}async function Se(t,e){const i=await t.geometry.project(t.outSpatialReference,e);Q(i);const n={geometry:i.export(),noDataValue:t.parameters.noDataValue};return t.parameters.returnSampleInfo&&(n.sampleInfo=be(t)),t.geometry.coordinates.forEach(a=>{a.tile=null,a.elevationTile=null}),n}function be(t){const e=t.layer.tileInfo,i=E(e.spatialReference);return t.geometry.coordinates.map(n=>{let a=-1;return n.elevationTile&&n.elevationTile!==t.outsideExtentTile&&(a=e.lodAt(n.elevationTile.key.level).resolution*i),{demResolution:a,source:a===-1?void 0:t.layer}})}const O="elevation-query:invalid-layer";export{O as InvalidLayerError,We as createSampler,L as defaultOptions,ce as getFinestLodIndex,ie as query,Pe as queryAll};
