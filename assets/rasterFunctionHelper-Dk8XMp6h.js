const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/intersectsOperator-J0XqM1FG.js","assets/ProjectionTransformation-BobSRxDZ.js","assets/Envelope2D-DVXJgpa0.js","assets/Point2D-yfRtYBLE.js","assets/Transformation2D-SVwJopg7.js","assets/SimpleGeometryCursor-B92kdZ15.js","assets/MapPage-E_im4B_H.js","assets/index-D8BwMS9q.js","assets/index-C4cPEJr5.css","assets/themeLevelStore-ESnsmRpw.js","assets/MapPage-6SJY3axd.css","assets/OperatorDefinitions-DP7_WWTp.js","assets/jsonConverter-BZNaVLtF.js","assets/OperatorIntersects-BijqnThf.js","assets/apiConverter-CO8c7uxo.js","assets/containsOperator-DEZdXPN2.js","assets/projectOperator-CK80jXlK.js","assets/operatorProject-OvbFsTE6.js","assets/geographicTransformationUtils-C6N8q82i.js","assets/projectionUtils-BVHLMza8.js"])))=>i.map(i=>d[i]);
import{U as ds}from"./colorUtils-bZ_cvlhJ.js";import{_ as h,z as d,A as N,B as Hs,dc as Js,aE as ot,aW as rt,g as K,b as wn,cq as bn,c1 as Gt,em as zt,aK as X,cI as Ks,$ as vn,a$ as An,aJ as Tn,s as Et,j6 as st,j7 as et,S as Pn,j8 as Rn,j9 as gs,ja as $n,P as ie,N as Ae,iq as pe}from"./MapPage-E_im4B_H.js";import{c as R,f as Nn,a as Xs,u as dt,r as W,l as Pe,i as Re}from"./PixelBlock-BCc4vHpl.js";import{m as Fn,X as In,Z as kn,_ as jt,$ as _n,a0 as Ys,B as Me,a1 as Zs,a2 as Qs,a3 as tn,a4 as Mn,a5 as Sn,a6 as us,a7 as ae,a8 as Cn,a9 as de,aa as en,ab as sn,ac as Bn,ad as Qt,ae as jn,af as Gn,ag as zn,ah as En,ai as On,aj as Dn,ak as Vn,al as Un,am as $e,an as Ln,ao as Wn,ap as qn}from"./RasterSymbolizer-Cad3j1Bl.js";import{_ as ge}from"./index-D8BwMS9q.js";import{Q as Hn}from"./projectionUtils-BVHLMza8.js";import{m as Jn,p as nn}from"./colorRamps-Dhu3D7L8.js";import{m as ct}from"./Field-CWTSU1v6.js";let he=class extends Hs{constructor(){super(...arguments),this.raster=void 0}};h([d({json:{write:!0}})],he.prototype,"raster",void 0),he=h([N("esri.layers.support.rasterFunctions.BaseFunctionArguments")],he);const O=he;var Se;let Vt=Se=class extends O{constructor(){super(...arguments),this.raster2=void 0}get rasters(){return[this.raster,this.raster2]}clone(){return new Se({raster:this.raster,raster2:this.raster2,operation:this.operation})}};h([d({json:{write:!0}})],Vt.prototype,"operation",void 0),h([d({json:{write:!0}})],Vt.prototype,"raster2",void 0),h([d({readOnly:!0})],Vt.prototype,"rasters",null),Vt=Se=h([N("esri.layers.support.rasterFunctions.ArithmeticFunctionArguments")],Vt);const Kn=Vt,Xn=new Set(["slope","aspect","curvature","hillshade","shadedrelief","statistics"]);let E=class extends Hs{constructor(){super(...arguments),this.functionArguments=null,this.readingBufferSize=0,this.id=-1,this.isNoopProcess=!1,this.rawInputBandIds=[],this.rawSourceRasterInfos=null,this.isInputBandIdsSwizzled=!1,this.swizzledBandSelection=[],this.isBranch=!1,this.isRoot=!1,this._bindingResult=null}get supportsGPU(){return this._bindingResult.supportsGPU}get flatWebGLFunctionChain(){const t=this.getWebGLProcessorDefinition();if(!t)return null;const e=[t],{parameters:s}=t;let r=s.rasters||s.raster&&[s.raster];for(;r?.length;){e.unshift(...r);const u=[];for(let l=0;l<r.length;l++){const{parameters:c}=r[l],p=c.rasters||c.raster&&[c.raster];p?.length&&u.push(...p)}r=u}for(let u=e.length-1;u>=0;u--)e[u].isNoopProcess&&e.splice(u,1);let n=!1;for(let u=0;u<e.length;u++){const l=e[u];l.id=e.length-u-1;const{rasters:c}=l.parameters;n=n||c!=null&&c.length>1}const a=e.some(({name:u})=>Xn.has(u.toLowerCase())),{rawSourceRasterInfos:i}=this;return{functions:e,hasBranches:n,hasFocalFunction:a,isSourceSingleBand:i?.[0]?.bandCount===1}}bind(t,e=!1,s=-1){this.id=s+1;const r=this._getRasterValues();let n=!0;for(let a=0;a<r.length;a++){const i=r[a];if(i!=null&&this._isRasterFunctionValue(i)){const u=i.bind(t,e,this.id+a);if(!u.success)return this._bindingResult=u,u;n=n&&u.supportsGPU}}return!this.rasterInfo||e?(this.sourceRasterInfos=this._getSourceRasterInfos(t),this._bindingResult=this._bindSourceRasters(),n&&=this._bindingResult.supportsGPU,this._bindingResult.success&&(this._patchRasterInfo(),n&&this.isRoot)&&(this.processInputBandIds(),this.swizzleInputBandIds(this.rawInputBandIds)||(n=this.rawInputBandIds.length<=3)),this._bindingResult.supportsGPU=n,this._bindingResult):(this._bindingResult={success:!0,supportsGPU:!0},this._bindingResult)}process(t){const e=this._getRasterValues(),s=e.length===0?t.pixelBlocks??t.primaryPixelBlocks:e.map(r=>this._readRasterValue(r,t));return this._processPixels({...t,pixelBlocks:s})}processInputBandIds(){const t=this._getRasterValues().filter(this._isRasterFunctionValue);if(t.length>1){const n=t.map(a=>a.processInputBandIds());return this.rawInputBandIds=[...new Set(n.flat())],this.rawInputBandIds}const e=t[0];if(e)return this.rawInputBandIds=e.processInputBandIds(),this.rawInputBandIds;const{bandCount:s}=this.sourceRasterInfos[0],r=Array.from({length:s},(n,a)=>a);return this.rawInputBandIds=this._getInputBandIds(r),this.rawInputBandIds}swizzleInputBandIds(t){const e=this._getRasterValues().filter(this._isRasterFunctionValue);let s=!0;for(const r of e)s=r.swizzleInputBandIds(t)&&s;return!!s&&this._swizzleBandIds(t)}getPrimaryRasters(){const t=[],e=[];return this._getPrimaryRasters(this,t,e),{rasters:t,rasterIds:e}}getWebGLProcessorDefinition(){const t=this._getWebGLParameters(),{raster:e,rasters:s}=this.functionArguments;return s&&Array.isArray(s)&&s.length?(t.rasters=s.map(r=>this._isRasterFunctionValue(r)?r.getWebGLProcessorDefinition():typeof r=="number"?{name:"Constant",parameters:{value:r},pixelType:"f32",id:-1,isNoopProcess:!1}:{name:"Identity",parameters:{value:r},pixelType:"f32",id:-1,isNoopProcess:!1}),t.rasters.some(r=>r!=null)||(t.rasters=null)):this._isRasterFunctionValue(e)&&(t.raster=e.getWebGLProcessorDefinition()),{name:this.functionName,parameters:t,pixelType:this.outputPixelType,id:this.id,isNoopProcess:this.isNoopProcess}}getClippingGeometries(){const t=[];this.functionName==="Clip"&&t.push(this.functionArguments);const{raster:e,rasters:s}=this.functionArguments;if(s&&Array.isArray(s)&&s.length)s.forEach(r=>{if(this._isRasterFunctionValue(r)){const n=r.getClippingGeometries();t.push(...n)}});else if(this._isRasterFunctionValue(e)){const r=e.getClippingGeometries();t.push(...r)}return t}_getOutputPixelType(t){return this.outputPixelType==="unknown"?t:this.outputPixelType??t}_getWebGLParameters(){return{}}_getInputBandIds(t){return t}_swizzleBandIds(t){return!0}_isInputRasterPrimaryOrConstant(){return!this._getRasterValues().some(t=>t&&typeof t=="object"&&"rasterFunction"in t&&t.rasterFunction)}_removeStatsHistColormapVAT(t){t.statistics=null,t.histograms=null,t.colormap=null,t.attributeTable=null,t.multidimensionalInfo?.variables.forEach(e=>{e.statistics=void 0,e.histograms=void 0})}_getRasterValues(){const{rasterArgumentNames:t}=this;return t[0]==="rasters"?this.functionArguments.rasters??[]:t.flatMap(e=>this.functionArguments[e])}_getSourceRasterInfos(t){const e=this._getRasterValues(),{rasterInfos:s,rasterIds:r}=t;if(e.length===0)return s;const n=e.map(i=>i&&typeof i=="object"&&"bind"in i&&i.rasterInfo?i.rasterInfo:typeof i=="string"&&r.includes(i)?s[r.indexOf(i)]:typeof i!="number"?s[0]:void 0),a=n.find(i=>i)??s[0];return n.forEach((i,u)=>{i===void 0&&(n[u]=a)}),n}_getPrimaryRasterId(t){return t?.rasterId}_getPrimaryRasters(t,e=[],s=[]){for(let r=0;r<t.sourceRasters.length;r++){const n=t.sourceRasters[r];if(typeof n!="number")if("bind"in n)this._getPrimaryRasters(n,e,s);else{const a=n,i=this._getPrimaryRasterId(a);if(i==null)continue;s.includes(i)||(this.mainPrimaryRasterId===i?(e.unshift(a),s.unshift(i)):(e.push(a),s.push(i)))}}}_isRasterFunctionValue(t){return t!=null&&typeof t=="object"&&"getWebGLProcessorDefinition"in t}_readRasterValue(t,e){const{primaryPixelBlocks:s}=e;if(t==null||t==="$$"){const r=s[0];return r==null?null:r.clone()}if(typeof t=="string"){const r=e.primaryRasterIds.indexOf(t);return r===-1?null:s[r]}if(typeof t=="number"){const r=s[0];if(r==null)return null;const{width:n,height:a,pixelType:i}=r,u=new Float32Array(n*a);u.fill(t);const l=this.sourceRasterInfos[0].bandCount,c=new Array(l).fill(u);return new R({width:n,height:a,pixelType:i,pixels:c})}return t.process(e)}_patchRasterInfo(){const{rasterInfo:t}=this;if(!t?.keyProperties)return;const{bandCount:e,keyProperties:s,statistics:r,histograms:n}=t,a=s.BandProperties;a&&a.length!==e&&(t.keyProperties={...s,BandProperties:void 0}),r&&r.length!==e&&(t.statistics=r.length>e?r.slice(0,e):null),n&&n.length!==e&&(t.histograms=n.length>e?n.slice(0,e):null),s.BAND_COUNT&&Number(s.BAND_COUNT)!==e&&(t.keyProperties={...s,BAND_COUNT:typeof s.BAND_COUNT=="string"?String(e):e})}};h([d({json:{write:!0}})],E.prototype,"functionName",void 0),h([d({json:{write:!0}})],E.prototype,"functionArguments",void 0),h([d()],E.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}}),Js(o=>o?.toLowerCase())],E.prototype,"outputPixelType",void 0),h([d({json:{write:!0}})],E.prototype,"mainPrimaryRasterId",void 0),h([d()],E.prototype,"sourceRasters",void 0),h([d({type:[Fn],json:{write:!0}})],E.prototype,"sourceRasterInfos",void 0),h([d({json:{write:!0}})],E.prototype,"rasterInfo",void 0),h([d({json:{write:!0}})],E.prototype,"readingBufferSize",void 0),h([d({json:{write:!0}})],E.prototype,"id",void 0),h([d()],E.prototype,"isNoopProcess",void 0),h([d()],E.prototype,"supportsGPU",null),h([d({json:{write:!0}})],E.prototype,"rawInputBandIds",void 0),h([d()],E.prototype,"rawSourceRasterInfos",void 0),h([d({json:{write:!0}})],E.prototype,"isInputBandIdsSwizzled",void 0),h([d({json:{write:!0}})],E.prototype,"swizzledBandSelection",void 0),h([d()],E.prototype,"isBranch",void 0),h([d()],E.prototype,"isRoot",void 0),h([d({readOnly:!0})],E.prototype,"flatWebGLFunctionChain",null),h([d()],E.prototype,"_bindingResult",void 0),E=h([N("esri.layers.support.rasterFunctions.BaseRasterFunction")],E);const z=E,S={userDefined:-1,lineDetectionHorizontal:0,lineDetectionVertical:1,lineDetectionLeftDiagonal:2,lineDetectionRightDiagonal:3,gradientNorth:4,gradientWest:5,gradientEast:6,gradientSouth:7,gradientNorthEast:8,gradientNorthWest:9,smoothArithmeticMean:10,smoothing3x3:11,smoothing5x5:12,sharpening3x3:13,sharpening5x5:14,laplacian3x3:15,laplacian5x5:16,sobelHorizontal:17,sobelVertical:18,sharpen:19,sharpen2:20,pointSpread:21,none:255},Yn={plus:1,minus:2,times:3,sqrt:4,power:5,abs:10,divide:23,exp:25,exp10:26,exp2:27,int:30,float:32,ln:35,log10:36,log2:37,mod:44,negate:45,roundDown:48,roundUp:49,square:53,floatDivide:64,floorDivide:65},H={bitwiseAnd:11,bitwiseLeftShift:12,bitwiseNot:13,bitwiseOr:14,bitwiseRightShift:15,bitwiseXOr:16,booleanAnd:17,booleanNot:18,booleanOr:19,booleanXOr:20,equalTo:24,greaterThan:28,greaterThanEqual:29,lessThan:33,lessThanEqual:34,isNull:31,notEqual:46},Z={acos:6,asin:7,atan:8,atanh:9,cos:21,cosh:22,sin:51,sinh:52,tan:56,tanh:57,acosh:59,asinh:60,atan2:61},Zn={majority:38,max:39,mean:40,med:41,min:42,minority:43,range:47,stddev:54,sum:55,variety:58,majorityIgnoreNoData:66,maxIgnoreNoData:67,meanIgnoreNoData:68,medIgnoreNoData:69,minIgnoreNoData:70,minorityIgnoreNoData:71,rangeIgnoreNoData:72,stddevIgnoreNoData:73,sumIgnoreNoData:74,varietyIgnoreNoData:75},rn={setNull:50,conditional:78},ys={...Yn,...H,...Z,...Zn,...rn},on=new Map([[Z.acos,{domain:[0,Math.PI],isInteger:!1}],[Z.asin,{domain:[-Math.PI/2,Math.PI/2],isInteger:!1}],[Z.atan,{domain:[-Math.PI/2,Math.PI/2],isInteger:!1}],[Z.cos,{domain:[-1,1],isInteger:!1}],[Z.sin,{domain:[-1,1],isInteger:!1}],[H.booleanAnd,{domain:[0,1],isInteger:!0}],[H.booleanNot,{domain:[0,1],isInteger:!0}],[H.booleanOr,{domain:[0,1],isInteger:!0}],[H.booleanXOr,{domain:[0,1],isInteger:!0}],[H.equalTo,{domain:[0,1],isInteger:!0}],[H.notEqual,{domain:[0,1],isInteger:!0}],[H.greaterThan,{domain:[0,1],isInteger:!0}],[H.greaterThanEqual,{domain:[0,1],isInteger:!0}],[H.lessThan,{domain:[0,1],isInteger:!0}],[H.lessThanEqual,{domain:[0,1],isInteger:!0}],[H.isNull,{domain:[0,1],isInteger:!0}]]);function xs(o){return on.get(o)}const ws=[0,2,2,2,1,2,1,1,1,1,1,2,2,1,2,2,2,2,1,2,2,1,1,2,2,1,1,1,2,2,1,1,1,2,2,1,1,1,999,999,999,999,999,999,2,1,2,999,1,1,2,1,1,1,999,999,1,1,999,1,1,2,999,999,2,2,999,999,999,999,999,999,999,999,999,999,3,999,3];function Qn(o,t=!1){const e=o.map(i=>i.mask),s=e.filter(i=>i!=null),r=o[0].pixels[0].length;if(s.length===0||t&&s.length!==e.length)return new Uint8Array(r).fill(255);const n=s[0],a=new Uint8Array(n);if(s.length===1)return a;if(!t){for(let i=1;i<s.length;i++){const u=s[i];for(let l=0;l<a.length;l++)a[l]&&(a[l]=u[l]?255:0)}return a}for(let i=1;i<s.length;i++){const u=s[i];for(let l=0;l<a.length;l++)a[l]===0&&(a[l]=u[l]?255:0)}return a}function tr(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]+r[i]);return a}function er(o,t,e){const[s]=o,r=s.length,n=R.createEmptyBand("f32",r);return n.set(s),n}function sr(o,t,e){const[s]=o,r=s.length,n=R.createEmptyBand(e,r);for(let a=0;a<r;a++)t&&!t[a]||(n[a]=s[a]*s[a]);return n}function nr(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]-r[i]);return a}function rr(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]*r[i]);return a}function or(o,t,e){const[s]=o,r=s.length,n=R.createEmptyBand(e,r);for(let a=0;a<r;a++)t&&!t[a]||(n[a]=Math.sign(s[a])*Math.floor(Math.abs(s[a])));return n}function an(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]/r[i]);return a}function ir(o,t,e){return an(o,t,"f32")}function ar(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=Math.floor(s[i]/r[i]));return a}function ur(o,t,e,s){const r=o[0],n=r.length,a=R.createEmptyBand(e,n);if(s===Z.atanh){for(let u=0;u<n;u++)if(t[u]){const l=r[u];Math.abs(l)>=1?t[u]=0:a[u]=Math.atanh(l)}return a}const i=s===Z.asin?Math.asin:Math.acos;for(let u=0;u<n;u++)if(t[u]){const l=r[u];Math.abs(l)>1?t[u]=0:a[u]=i(l)}return a}function lr(o,t,e,s){const[r]=o,n=r.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s(r[i]));return a}function cr(o,t,e,s){const[r,n]=o,a=r.length,i=R.createEmptyBand(e,a);for(let u=0;u<a;u++)t&&!t[u]||(i[u]=s(r[u],n[u]));return i}function pr(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]&r[i]);return a}function hr(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]<<r[i]);return a}function mr(o,t,e){const[s]=o,r=s.length,n=R.createEmptyBand(e,r);for(let a=0;a<r;a++)t&&!t[a]||(n[a]=~s[a]);return n}function fr(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]|r[i]);return a}function dr(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]>>r[i]);return a}function gr(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]^r[i]);return a}function yr(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]&&r[i]?1:0);return a}function xr(o,t,e){const[s]=o,r=s.length,n=R.createEmptyBand(e,r);for(let a=0;a<r;a++)t&&!t[a]||(n[a]=s[a]?0:1);return n}function wr(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]||r[i]?1:0);return a}function br(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=(s[i]?1:0)^(r[i]?1:0));return a}function vr(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]===r[i]?1:0);return a}function ls(o,t,e,s){const[r]=o,n=r.length,a=R.createEmptyBand(e,n),i=s===Math.E;for(let u=0;u<n;u++)t&&!t[u]||(a[u]=i?Math.exp(r[u]):s**r[u]);return a}function Ar(o,t,e){return ls(o,t,e,10)}function Tr(o,t,e){return ls(o,t,e,2)}function Pr(o,t,e){return ls(o,t,e,Math.E)}function cs(o,t,e,s){const[r]=o,n=r.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(r[i]<=0?t[i]=0:a[i]=s(r[i]));return a}function Rr(o,t,e){return cs(o,t,e,Math.log10)}function $r(o,t,e){return cs(o,t,e,Math.log2)}function Nr(o,t,e){return cs(o,t,e,Math.log)}function Fr(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]>r[i]?1:0);return a}function Ir(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]>=r[i]?1:0);return a}function kr(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]<r[i]?1:0);return a}function _r(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]<=r[i]?1:0);return a}function Mr(o,t,e){const[s]=o,r=s.length,n=R.createEmptyBand(e,r);if(!t)return n;for(let a=0;a<r;a++)n[a]=t[a]?0:1;return n}function Sr(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]%r[i]);return a}function Cr(o,t,e){const[s]=o,r=s.length,n=R.createEmptyBand(e,r);for(let a=0;a<r;a++)t&&!t[a]||(n[a]=-s[a]);return n}function Br(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]===r[i]?0:1);return a}function jr(o,t,e){const[s,r]=o,n=s.length,a=R.createEmptyBand(e,n),i=new Uint8Array(n);for(let u=0;u<n;u++)t!=null&&!t[u]||s[u]!==0||(a[u]=r[u],i[u]=255);return{band:a,mask:i}}function bs(o,t,e){const[s,r,n]=o,a=s.length,i=R.createEmptyBand(e,a);for(let u=0;u<a;u++)t&&!t[u]||(i[u]=s[u]?r[u]:n[u]);return i}function vs(o,t,e){const s=o.length;if(s<2)return o[0];const[r]=o,n=r.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)if(!t||t[i]){let u=r[i];for(let l=1;l<s;l++){const c=o[l][i];u<c&&(u=c)}a[i]=u}return a}function As(o,t,e){const s=o.length;if(s<2)return o[0];const[r]=o,n=r.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)if(!t||t[i]){let u=r[i];for(let l=1;l<s;l++){const c=o[l][i];u>c&&(u=c)}a[i]=u}return a}function Ts(o,t,e){const s=o.length;if(s<2)return o[0];const[r]=o,n=r.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)if(!t||t[i]){let u=r[i],l=u;for(let c=1;c<s;c++){const p=o[c][i];l<p?l=p:u>p&&(u=p)}a[i]=l-u}return a}function Ps(o,t,e){const s=o.length;if(s<2)return o[0];const[r]=o,n=r.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)if(!t||t[i]){let u=0;for(let l=0;l<s;l++)u+=o[l][i];a[i]=u/s}return a}function Rs(o,t,e){const s=o.length;if(s<2)return o[0];const[r]=o,n=r.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)if(!t||t[i])for(let u=0;u<s;u++){const l=o[u];a[i]+=l[i]}return a}function $s(o,t,e){const s=o.length;if(s<2)return o[0];const[r]=o,n=r.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)if(!t||t[i]){const u=new Float32Array(s);let l=0;for(let p=0;p<s;p++){const m=o[p];l+=m[i],u[p]=m[i]}l/=s;let c=0;for(let p=0;p<s;p++)c+=(u[p]-l)**2;a[i]=Math.sqrt(c/s)}return a}function Ns(o,t,e){const s=o.length;if(s<2)return o[0];const r=Math.floor(s/2),[n]=o,a=n.length,i=R.createEmptyBand(e,a),u=new Float32Array(s),l=s%2==1;for(let c=0;c<a;c++)if(!t||t[c]){for(let p=0;p<s;p++)u[p]=o[p][c];u.sort(),i[c]=l?u[r]:(u[r]+u[r-1])/2}return i}function un(o,t,e){const[s,r]=o;if(r==null)return s;const n=s.length,a=R.createEmptyBand(e,n);for(let i=0;i<n;i++)t&&!t[i]||(a[i]=s[i]<r[i]?s[i]:r[i]);return a}function Fs(o,t,e){const s=o.length;if(s<=2)return un(o,t,e);const r=o[0].length,n=R.createEmptyBand(e,r),a=new Map;for(let i=0;i<r;i++)if(!t||t[i]){a.clear();for(let p=0;p<s;p++){const m=o[p][i];a.set(m,a.has(m)?a.get(m)+1:1)}let u=0,l=0;const c=[];for(const p of a.keys())u=a.get(p),u>l?(l=u,c.length=0,c.push(p)):u===l&&c.push(p);c.length>1&&c.sort((p,m)=>p-m),n[i]=c[0]}return n}function Is(o,t,e){const s=o.length;if(s<=2)return un(o,t,e);const r=o[0].length,n=R.createEmptyBand(e,r),a=new Map;for(let i=0;i<r;i++)if(!t||t[i]){a.clear();for(let p=0;p<s;p++){const m=o[p][i];a.set(m,a.has(m)?a.get(m)+1:1)}let u=0,l=o.length;const c=[];for(const p of a.keys())u=a.get(p),u<l?(l=u,c.length=0,c.push(p)):u===l&&c.push(p);c.length>1&&c.sort((p,m)=>p-m),n[i]=c[0]}return n}function ks(o,t,e){const s=o.length;if(s<2)return o[0];const[r]=o,n=r.length,a=R.createEmptyBand(e,n),i=new Set;for(let u=0;u<n;u++)if(!t||t[u]){let l;i.clear();for(let c=0;c<s;c++)l=o[c][u],i.add(l);a[u]=i.size}return a}const D=new Map,ye=new Map,M=new Map,G=new Map;function Gr(){D.size||(D.set(4,Math.sqrt),D.set(6,Math.acos),D.set(7,Math.asin),D.set(8,Math.atan),D.set(9,Math.atanh),D.set(10,Math.abs),D.set(21,Math.cos),D.set(22,Math.cosh),D.set(48,Math.floor),D.set(49,Math.ceil),D.set(51,Math.sin),D.set(52,Math.sinh),D.set(56,Math.tan),D.set(57,Math.tanh),D.set(59,Math.acosh),D.set(60,Math.asinh),D.set(65,Math.floor),ye.set(5,Math.pow),ye.set(61,Math.atan2),M.set(1,tr),M.set(2,nr),M.set(3,rr),M.set(11,pr),M.set(12,hr),M.set(13,mr),M.set(14,fr),M.set(15,dr),M.set(16,gr),M.set(17,yr),M.set(18,xr),M.set(19,wr),M.set(20,br),M.set(23,an),M.set(24,vr),M.set(25,Pr),M.set(26,Ar),M.set(27,Tr),M.set(28,Fr),M.set(29,Ir),M.set(30,or),M.set(31,Mr),M.set(32,er),M.set(33,kr),M.set(34,_r),M.set(35,Nr),M.set(36,Rr),M.set(37,$r),M.set(44,Sr),M.set(45,Cr),M.set(46,Br),M.set(53,sr),M.set(64,ir),M.set(65,ar),M.set(76,bs),M.set(78,bs),G.set(38,Fs),G.set(39,vs),G.set(40,Ps),G.set(41,Ns),G.set(42,As),G.set(43,Is),G.set(47,Ts),G.set(54,$s),G.set(55,Rs),G.set(58,ks),G.set(66,Fs),G.set(67,vs),G.set(68,Ps),G.set(69,Ns),G.set(70,As),G.set(71,Is),G.set(72,Ts),G.set(73,$s),G.set(74,Rs),G.set(75,ks))}function ln(o,t,e={}){Gr();let s=Qn(o,t>=66&&t<=75);const{outputPixelType:r="f32"}=e,n=!G.has(t)||e.processAsMultiband,a=n?o[0].pixels.length:1,i=[];for(let l=0;l<a;l++){const c=G.has(t)&&!n?o.flatMap(f=>f.pixels):o.map(f=>f.pixels[l]);let p,m=!0;if(t===rn.setNull){const f=jr(c,s,r);p=f.band,s=f.mask,m=!1}else M.has(t)?p=M.get(t)(c,s,"f64"):D.has(t)?p=t===Z.asin||t===Z.acos||t===Z.atanh?ur(c,s,"f64",t):lr(c,s,"f64",D.get(t)):ye.has(t)?p=cr(c,s,"f64",ye.get(t)):G.has(t)?p=G.get(t)(c,s,"f64"):(p=c[0],m=!1);if(m&&t!==H.isNull&&!on.has(t)){const f=R.createEmptyBand(r,p.length);s||(s=new Uint8Array(p.length).fill(255)),Nn(p,s),Xs(p,s,r,f),p=f}i.push(p)}const u=o[0];return new R({width:u.width,height:u.height,pixelType:r,mask:t===H.isNull?null:s,pixels:i})}function zr(o,t,e){return ln(o,t=[null,1,2,3,23,5,44][t]??1,{outputPixelType:e})}let Ut=class extends z{constructor(){super(...arguments),this.functionName="Arithmetic",this.functionArguments=null,this.rasterArgumentNames=["raster","raster2"]}_bindSourceRasters(){const{operation:t}=this.functionArguments;if(t<1||t>6)return{success:!1,supportsGPU:!1,error:"unsupported operation"};const e=this.sourceRasterInfos[0].clone();return this.outputPixelType=this._getOutputPixelType(e.pixelType),e.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(e),this.rasterInfo=e,{success:!0,supportsGPU:e.bandCount<=3}}_processPixels(t){const{pixelBlocks:e}=t;return e?.[0]==null||e?.[1]==null?null:zr(e,this.functionArguments.operation,this.outputPixelType)}_getWebGLParameters(){const{operation:t}=this.functionArguments,e=["","plus","minus","times","divide","power","mod"][t],s=this.outputPixelType??"f32";let[r,n]=dt(s);const a=W(s);return a&&(r-=1e-4,n+=1e-4),{imageCount:2,operationName:e,domainRange:[r,n],isOutputRounded:a}}};h([d({json:{write:!0,name:"rasterFunction"}})],Ut.prototype,"functionName",void 0),h([d({type:Kn,json:{write:!0,name:"rasterFunctionArguments"}})],Ut.prototype,"functionArguments",void 0),h([d()],Ut.prototype,"rasterArgumentNames",void 0),Ut=h([N("esri.layers.support.rasterFunctions.ArithmeticFunction")],Ut);const Er=Ut;var Ce;let Be=Ce=class extends O{clone(){return new Ce({raster:this.raster})}};Be=Ce=h([N("esri.layers.support.rasterFunctions.AspectFunctionArguments")],Be);const Or=Be;let yt=class extends z{constructor(){super(...arguments),this.functionName="Aspect",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){const t=this.sourceRasterInfos[0];this.isGCS=t.spatialReference?.isGeographic??!1,this.outputPixelType=this._getOutputPixelType("f32");const e=t.clone();return e.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(e),e.statistics=[{min:-1,max:360,avg:180,stddev:30}],e.bandCount=1,this.rasterInfo=e,{success:!0,supportsGPU:!0}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return null;const{extent:s,primaryPixelSizes:r}=t,n=r?.[0],a=n??(s?{x:s.width/e.width,y:s.height/e.height}:{x:1,y:1});return In(e,{resolution:a})}};h([d({json:{write:!0,name:"rasterFunction"}})],yt.prototype,"functionName",void 0),h([d({type:Or,json:{write:!0,name:"rasterFunctionArguments"}})],yt.prototype,"functionArguments",void 0),h([d()],yt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],yt.prototype,"isGCS",void 0),yt=h([N("esri.layers.support.rasterFunctions.AspectFunction")],yt);const Dr=yt,Vr=new Set(["+","-","*","/","(",")"]);function Ur(o,t){(o=o.replaceAll(" ","")).startsWith("-")&&(o="0"+o),o.startsWith("+")&&(o=o.slice(1));const e=o.split(""),s=[],r=[];let n="";for(let a=0;a<e.length;a++){const i=e[a];Vr.has(i)?(n.length&&r.push(_s(n,t)),s.push(i),n=""):n=n.concat(i)}return n.length&&r.push(_s(n,t)),{ops:s,nums:r}}function _s(o,t){return o.toLowerCase().startsWith("b")?t[parseInt(o.slice(1),10)-1]:parseFloat(o)}function Lr(o,t,e,s){if(typeof e=="number"&&typeof s=="number")return e+s;let r,n,a;typeof e=="number"?(a=s,r=a.length,n=new Float32Array(r),n.fill(e)):(r=e.length,n=e,s.constructor===Number?(a=new Float32Array(r),a.fill(s)):a=s);const i=new Float32Array(r);switch(t){case"+":for(let u=0;u<r;u++)(o==null||o[u])&&(i[u]=n[u]+a[u]);break;case"-":for(let u=0;u<r;u++)(o==null||o[u])&&(i[u]=n[u]-a[u]);break;case"*":for(let u=0;u<r;u++)(o==null||o[u])&&(i[u]=n[u]*a[u]);break;case"/":for(let u=0;u<r;u++)(o==null||o[u])&&a[u]&&(i[u]=n[u]/a[u]);break;case"(":case")":throw new Error("encountered error with custom band index equation")}return i}function Wr(o,t){o.splice(t,1);let e=0,s=0;do{e=0,s=0;for(let r=0;r<o.length;r++)if(o[r]==="(")e=r;else if(o[r]===")"){s=r;break}s===e+1&&o.splice(e,2)}while(s===e+1);return o}function qr(o){if(o.length===1)return{opIndex:0,numIndex:0};let t=0,e=0;for(let a=0;a<o.length;a++)if(o[a]==="(")t=a;else if(o[a]===")"){e=a;break}const s=e===0?o:o.slice(t+1,e);let r=-1;for(let a=0;a<s.length;a++)if(s[a]==="*"||s[a]==="/"){r=a;break}if(r>-1)e>0&&(r+=t+1);else{for(let a=0;a<s.length;a++)if(s[a]==="+"||s[a]==="-"){r=a;break}e>0&&(r+=t+1)}let n=0;for(let a=0;a<r;a++)o[a]==="("&&n++;return{opIndex:r,numIndex:r-n}}function Hr(o,t,e){let s,{ops:r,nums:n}=Ur(e,t);if(r.length===0){const a=n.length===1?n[0]:t[0];if(a instanceof Float32Array)return[a];const i=new Float32Array(t[0].length);return typeof a=="number"?i.fill(a):i.set(a),[i]}for(;r.length>0;){const{numIndex:a,opIndex:i}=qr(r);if(s=Lr(o,r[i],n[a],n[a+1]),r.length===1)break;r=Wr(r,i),n.splice(a,2,s)}return[s]}const Jr=new ot({0:"custom",1:"ndvi",2:"savi",3:"tsavi",4:"msavi",5:"gemi",6:"pvi",7:"gvitm",8:"sultan",9:"vari",10:"gndvi",11:"sr",12:"ndvi-re",13:"sr-re",14:"mtvi2",15:"rtvi-core",16:"ci-re",17:"ci-g",18:"ndwi",19:"evi",20:"iron-oxide",21:"ferrous-minerals",22:"clay-minerals",23:"wndwi",24:"bai",25:"nbr",26:"ndbi",27:"ndmi",28:"ndsi",29:"mndwi"},{useNumericKeys:!0});function Kr(o,t){if(!kn(o))return o;const{equation:e,method:s}=t,r=t.bandIndexes.map(m=>m-1),{pixels:n,mask:a}=o;let i;switch(s){case"gndvi":case"nbr":case"ndbi":case"ndvi":case"ndvi-re":case"ndsi":case"ndmi":case"mndwi":i=Ms(a,n[r[0]],n[r[1]]);break;case"ndwi":i=Ms(a,n[r[1]],n[r[0]]);break;case"sr":case"sr-re":case"iron-oxide":case"ferrous-minerals":case"clay-minerals":i=Yr(a,n[r[0]],n[r[1]]);break;case"ci-g":case"ci-re":i=Zr(a,n[r[0]],n[r[1]]);break;case"savi":i=Qr(a,n[r[0]],n[r[1]],r[2]+1);break;case"tsavi":i=to(a,n[r[0]],n[r[1]],r[2]+1,r[3]+1,r[4]+1);break;case"msavi":i=eo(a,n[r[0]],n[r[1]]);break;case"gemi":i=so(a,n[r[0]],n[r[1]]);break;case"pvi":i=no(a,n[r[0]],n[r[1]],r[2]+1,r[3]+1);break;case"gvitm":i=ro(a,[n[r[0]],n[r[1]],n[r[2]],n[r[3]],n[r[4]],n[r[5]]]);break;case"sultan":i=oo(a,[n[r[0]],n[r[1]],n[r[2]],n[r[3]],n[r[4]]]);break;case"vari":i=io(a,[n[r[0]],n[r[1]],n[r[2]]]);break;case"mtvi2":i=ao(a,[n[r[0]],n[r[1]],n[r[2]]]);break;case"rtvi-core":i=uo(a,[n[r[0]],n[r[1]],n[r[2]]]);break;case"evi":i=lo(a,[n[r[0]],n[r[1]],n[r[2]]]);break;case"wndwi":i=co(a,[n[r[0]],n[r[1]],n[r[2]]],r[3]?r[3]+1:.5);break;case"bai":i=po(a,n[r[0]],n[r[1]]);break;case"custom":i=Hr(a,n,e);break;default:return o}const{outputPixelType:u="f32"}=t,l=u!=null&&W(u);let c;a?(c=new Uint8Array(o.width*o.height),c.set(a)):l&&(c=new Uint8Array(o.width*o.height).fill(255)),l&&(i=i.map(m=>{const f=R.createEmptyBand(u,m.length);return Xs(m,c,u,f),f}));const p=new R({width:o.width,height:o.height,pixelType:u,pixels:i,mask:c});return p.updateStatistics(),p}function Xr(o,t,e,s){const{mask:r,pixels:n,width:a,height:i}=o,u=n[e],l=n[t],c=l.length,p=s?new Uint8Array(c):new Float32Array(c),m=s?100:1,f=s?100.5:0;for(let x=0;x<c;x++)if(r==null||r[x]){const y=u[x],v=l[x],w=y+v;w&&(p[x]=(y-v)/w*m+f)}const g=new R({width:a,height:i,mask:r,pixelType:s?"u8":"f32",pixels:[p]});return g.updateStatistics(),g}function U(o){const t=new Float32Array(9);return t[3*o[0]]=1,t[3*o[1]+1]=1,t[3*o[2]+2]=1,t}function Ms(o,t,e){const s=e.length,r=new Float32Array(s);for(let n=0;n<s;n++)if(o==null||o[n]){const a=t[n],i=e[n],u=a+i;u&&(r[n]=(a-i)/u)}return[r]}function Yr(o,t,e){const s=e.length,r=new Float32Array(s);for(let n=0;n<s;n++)if(o==null||o[n]){const a=t[n],i=e[n];i&&(r[n]=a/i)}return[r]}function Zr(o,t,e){const s=t.length,r=new Float32Array(s);for(let n=0;n<s;n++)if(o==null||o[n]){const a=t[n],i=e[n];i&&(r[n]=a/i-1)}return[r]}function Qr(o,t,e,s){const r=e.length,n=new Float32Array(r);for(let a=0;a<r;a++)if(o==null||o[a]){const i=e[a],u=t[a],l=u+i+s;l&&(n[a]=(u-i)/l*(1+s))}return[n]}function to(o,t,e,s,r,n){const a=e.length,i=new Float32Array(a),u=-r*s+n*(1+s*s);for(let l=0;l<a;l++)if(o==null||o[l]){const c=e[l],p=t[l],m=r*p+c+u;m&&(i[l]=s*(p-s*c-r)/m)}return[i]}function eo(o,t,e){const s=e.length,r=new Float32Array(s);for(let n=0;n<s;n++)if(o==null||o[n]){const a=e[n],i=t[n],u=2*i+1;r[n]=.5*(u-Math.sqrt(u*u-8*(i-a)))}return[r]}function so(o,t,e){const s=e.length,r=new Float32Array(s);for(let n=0;n<s;n++)if(o==null||o[n]){const a=e[n],i=t[n];if(a!==1&&i+a+.5!==0){const u=(2*(i*i-a*a)+1.5*i+.5*a)/(i+a+.5);r[n]=u*(1-.25*u)-(a-.125)/(1-a)}}return[r]}function no(o,t,e,s,r){const n=e.length,a=new Float32Array(n),i=1/Math.sqrt(1+s*s);for(let u=0;u<n;u++)if(o==null||o[u]){const l=e[u],c=t[u];a[u]=(c-s*l-r)*i}return[a]}function ro(o,t){const[e,s,r,n,a,i]=t,u=e.length,l=new Float32Array(u);for(let c=0;c<u;c++)(o==null||o[c])&&(l[c]=-.2848*e[c]-.2435*s[c]-.5436*r[c]+.7243*n[c]+.084*a[c]-.18*i[c]);return[l]}function oo(o,t){const[e,s,r,n,a]=t,i=e.length,u=new Float32Array(i),l=new Float32Array(i),c=new Float32Array(i);for(let p=0;p<i;p++)(o==null||o[p])&&(u[p]=a[p]?n[p]/a[p]*100:0,l[p]=e[p]?n[p]/e[p]*100:0,c[p]=r[p]?s[p]/r[p]*(n[p]/r[p])*100:0);return[u,l,c]}function io(o,t){const[e,s,r]=t,n=e.length,a=new Float32Array(n);for(let i=0;i<n;i++)if(o==null||o[i])for(i=0;i<n;i++){const u=e[i],l=s[i],c=l+u-r[i];c&&(a[i]=(l-u)/c)}return[a]}function ao(o,t){const[e,s,r]=t,n=e.length,a=new Float32Array(n);for(let i=0;i<n;i++)if(o==null||o[i])for(i=0;i<n;i++){const u=e[i],l=s[i],c=r[i],p=Math.sqrt((2*u+1)**2-(6*u-5*Math.sqrt(l))-.5);if(p){const m=1.5*(1.2*(u-c)-2.5*(l-c));a[i]=m/p}}return[a]}function uo(o,t){const[e,s,r]=t,n=e.length,a=new Float32Array(n);for(let i=0;i<n;i++)if(o==null||o[i])for(i=0;i<n;i++){const u=e[i],l=s[i],c=r[i];a[i]=100*(u-l)-10*(u-c)}return[a]}function lo(o,t){const[e,s,r]=t,n=e.length,a=new Float32Array(n);for(let i=0;i<n;i++)if(o==null||o[i])for(i=0;i<n;i++){const u=e[i],l=s[i],c=u+6*l-7.5*r[i]+1;c&&(a[i]=2.5*(u-l)/c)}return[a]}function co(o,t,e=.5){const[s,r,n]=t,a=r.length,i=new Float32Array(a);for(let u=0;u<a;u++)if(o==null||o[u])for(u=0;u<a;u++){const l=s[u],c=r[u],p=n[u],m=l+e*c+(1-e)*p;m&&(i[u]=(l-e*c-(1-e)*p)/m)}return[i]}function po(o,t,e){const s=e.length,r=new Float32Array(s);for(let n=0;n<s;n++)if(o==null||o[n])for(n=0;n<s;n++){const a=(.1-t[n])**2+(.06-e[n])**2;a&&(r[n]=1/a)}return[r]}var je;let se=je=class extends O{constructor(){super(...arguments),this.method="custom"}clone(){return new je({method:this.method,bandIndexes:this.bandIndexes,raster:K(this.raster)})}};h([d({json:{type:String,write:!0}})],se.prototype,"bandIndexes",void 0),h([rt(Jr)],se.prototype,"method",void 0),se=je=h([N("esri.layers.support.rasterFunctions.BandArithmeticFunctionArguments")],se);const ho=se,Ss=new Set(["vari","mtvi2","rtvi-core","evi"]);let Lt=class extends z{constructor(){super(...arguments),this.functionName="BandArithmetic",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){this.outputPixelType=this._getOutputPixelType("f32");const t=this.sourceRasterInfos[0];if(t.bandCount<2)return{success:!1,supportsGPU:!1,error:"band-arithmetic-function: source raster has insufficient amount of raster bands"};const e=t.clone();return e.pixelType=this.outputPixelType,e.bandCount=this.functionArguments.method==="sultan"?3:1,this._removeStatsHistColormapVAT(e),e.keyProperties={...e.keyProperties,BandProperties:void 0},this.rasterInfo=e,{success:!0,supportsGPU:!["custom","gvitm","sultan"].includes(this.functionArguments.method)}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return e;const{method:s,bandIndexes:r}=this.functionArguments,n=r.split(" ").map(a=>parseFloat(a));if(this.rasterInfo.storageInfo.isBsqTile){const{rawInputBandIds:a}=this,i=Ss.has(this.functionArguments.method)?3:2,u=n.slice(0,i).map(l=>a.indexOf(l-1));n.splice(0,i,...u)}return Kr(e,{method:s,bandIndexes:n,equation:r,outputPixelType:this.outputPixelType})}_getWebGLParameters(){const t=this.functionArguments.bandIndexes.split(" ").map(i=>parseFloat(i)-1);t.length===2&&t.push(0);const e=this.isInputBandIdsSwizzled?[0,1,2]:t;let s,r;const n=new Float32Array(3),{method:a}=this.functionArguments;switch(a){case"gndvi":case"nbr":case"ndbi":case"ndvi":case"ndvi-re":case"ndsi":case"ndmi":case"mndwi":s=U([e[0],e[1],0]),r="ndxi";break;case"ndwi":s=U([e[1],e[0],0]),r="ndxi";break;case"sr":case"sr-re":case"iron-oxide":case"ferrous-minerals":case"clay-minerals":s=U([e[0],e[1],0]),r="sr";break;case"ci-g":case"ci-re":s=U([e[0],e[1],0]),r="ci";break;case"savi":s=U([e[0],e[1],0]),r="savi",n[0]=t[2]+1;break;case"tsavi":s=U([e[0],e[1],0]),r="tsavi",n[0]=t[2]+1,n[1]=t[3]+1,n[2]=t[4]+1;break;case"msavi":s=U([e[0],e[1],0]),r="msavi";break;case"gemi":s=U([e[0],e[1],0]),r="gemi";break;case"pvi":s=U([e[0],e[1],0]),r="tsavi",n[0]=t[2]+1,n[1]=t[3]+1;break;case"vari":s=U([e[0],e[1],e[2]]),r="vari";break;case"mtvi2":s=U([e[0],e[1],e[2]]),r="mtvi";break;case"rtvi-core":s=U([e[0],e[1],e[2]]),r="rtvicore";break;case"evi":s=U([e[0],e[1],e[2]]),r="evi";break;case"wndwi":s=U([e[0],e[1],0]),r="wndwi",n[0]=t[3]?t[3]+1:.5;break;case"bai":s=U([e[1],e[0],0]),r="bai";break;default:s=U([0,1,2]),r="custom"}return{bandIndexMat3:s,indexType:r,adjustments:n,isOutputRounded:W(this.outputPixelType)}}_getInputBandIds(t){if(this.functionArguments.method==="custom")return t;const e=this.functionArguments.bandIndexes.split(" ").map(i=>parseFloat(i)-1),s=t.length,r=e.map(i=>i>=s?s-1:i),n=Ss.has(this.functionArguments.method)?3:2,a=r.slice(0,n).map(i=>t[i]);return a.length===2&&a.push(0),a}_swizzleBandIds(t){const e=this.functionArguments.bandIndexes.split(" ").map(n=>parseFloat(n)-1);e.length===2&&e.push(0);const{method:s}=this.functionArguments,r=(["vari","mtvi2","rtvi-core","evi"].includes(s)?e.slice(0,3):s==="bai"||s==="ndwi"?[e[1],e[0]]:e.slice(0,2)).map(n=>t.indexOf(n));return r[2]??=r[1],this.isInputBandIdsSwizzled=!0,this.swizzledBandSelection=r,!1}};h([d({json:{write:!0,name:"rasterFunction"}})],Lt.prototype,"functionName",void 0),h([d({type:ho,json:{write:!0,name:"rasterFunctionArguments"}})],Lt.prototype,"functionArguments",void 0),h([d()],Lt.prototype,"rasterArgumentNames",void 0),Lt=h([N("esri.layers.support.rasterFunctions.BandArithmeticFunction")],Lt);const mo=Lt;var Ge;const Cs=new ot({1:"outside",2:"inside"},{useNumericKeys:!0});let ne=Ge=class extends O{constructor(){super(...arguments),this.clippingType="outside"}clone(){return new Ge({clippingGeometry:this.clippingGeometry.clone(),clippingType:this.clippingType})}};h([d({types:bn,json:{read:wn,write:!0}})],ne.prototype,"clippingGeometry",void 0),h([d({json:{read:Cs.read,write:Cs.write}})],ne.prototype,"clippingType",void 0),ne=Ge=h([N("esri.layers.support.rasterFunctions.ClipFunctionArguments")],ne);const fo=ne;function go(o,t){if(o.spatialReference.equals(t))return o;const e=zt(o.spatialReference),s=zt(t);if(e===s)return o;const r=e/s;return{x:o.x*r,y:o.y*r}}async function ba(o,t,e){if(e.type==="extent")return bo(o,t,e);const{width:s,height:r}=o,n=new Uint8Array(s*r);return(await ge(async()=>{const{execute:a}=await import("./intersectsOperator-J0XqM1FG.js").then(i=>i.i);return{execute:a}},__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]))).execute(t,e)?e.type==="polyline"?vo(o,t,e):(await ge(async()=>{const{execute:a}=await import("./containsOperator-DEZdXPN2.js").then(i=>i.c);return{execute:a}},__vite__mapDeps([15,1,2,3,4,5,6,7,8,9,10,11,12,14]))).execute(e,t)?o:yo(o,t,e):new R({pixelType:o.pixelType,width:s,height:r,mask:n,maskIsAlpha:!1,pixels:[...o.pixels]})}function yo(o,t,e){if(!o)return o;const{width:s,height:r}=o,n=xo({geometry:e,size:[s,r],srcExtent:t,srcMask:o.mask});return new R({pixelType:o.pixelType,width:s,height:r,mask:n,maskIsAlpha:!1,pixels:[...o.pixels]})}function xo(o){const{geometry:t,size:e,srcExtent:s,srcMask:r}=o,[n,a]=e;let i;const u=s.width/n,l=s.height/a,{xmin:c,ymax:p}=s;if(t.type==="extent"){const m=(t.xmin-c)/u,f=(t.xmax-c)/u,g=(p-t.ymax)/l,x=(p-t.ymin)/l;i=[[[m,g],[m,x],[f,x],[f,g],[m,g]]]}else i=t.rings.map(m=>m.map(([f,g])=>[(f-c)/u,(p-g)/l]));return wo(i,e,r)}function wo(o,t,e){const[s,r]=t,n=new OffscreenCanvas(s,r).getContext("2d");n.fillStyle="#f00",n.beginPath(),o.forEach(c=>{n.moveTo(c[0][0],c[0][1]);for(let p=0;p<c.length;p++)n.lineTo(c[p][0],c[p][1]);n.closePath()}),n.fill();const a=n.getImageData(0,0,s,r).data,i=s*r,u=new Uint8Array(i);let l=!1;for(let c=0;c<i;c++)e&&!e[c]||(a[4*c+3]>127?u[c]=255:l=!0);return l||e?u:void 0}function bo(o,t,e){const{width:s,height:r}=o,n=new Uint8Array(s*r),a=t.width/s,i=t.height/r;if(e.width/a<.5||e.height/i<.5)return new R({pixelType:o.pixelType,width:s,height:r,mask:n,pixels:[...o.pixels]});const{xmin:u,xmax:l,ymin:c,ymax:p}=t,{xmin:m,xmax:f,ymin:g,ymax:x}=e,y=Math.max(u,m),v=Math.min(l,f),w=Math.max(c,g),A=Math.min(p,x),b=.5*a,T=.5*i;if(v-y<b||A-w<T||v<u+b||y>l-b||w>p-T||A<c+T)return new R({pixelType:o.pixelType,width:s,height:r,mask:n,pixels:[...o.pixels]});const P=Math.max(0,(y-u)/a),$=Math.min(s,Math.max(0,(v-u)/a)),F=Math.max(0,(p-A)/i),I=Math.min(r,Math.max(0,(p-w)/i)),k=Math.round(P),_=Math.round($)-1,C=Math.round(F),q=Math.round(I)-1;if(k===_&&P%1>.5&&$%1<.5||C===q&&F%1>.5&&I%1<.5)return new R({pixelType:o.pixelType,width:s,height:r,mask:n,pixels:[...o.pixels]});if(k===0&&C===0&&_===s&&q===r)return o;const gt=o.mask;for(let Q=C;Q<=q;Q++)for(let Dt=k;Dt<=_;Dt++){const le=Q*s+Dt;n[le]=gt?gt[le]:255}return new R({pixelType:o.pixelType,width:s,height:r,mask:n,pixels:[...o.pixels]})}function vo(o,t,e){const{width:s,height:r}=o,n=new Uint8Array(s*r),a=t.width/s,i=t.height/r,{xmin:u,ymax:l}=t,{paths:c}=e,p=o.mask;for(let m=0;m<c.length;m++){const f=c[m];for(let g=0;g<f.length-1;g++){const[x,y]=f[g],[v,w]=f[g+1],A=Math.min(y,w),b=Math.max(y,w),T=Math.max(0,Math.floor((l-b)/i)),P=Math.min(r-1,Math.floor((l-A)/i));if(!(P<T))if(T===P){const $=Math.min(x,v),F=Math.max(x,v),I=Math.max(0,Math.floor(($-u)/a)),k=Math.min(s-1,Math.floor((F-u)/a));if(k<I)continue;const _=T*s;for(let C=_+I;C<=_+k;C++)n[C]=p?p[C]:255}else{const $=(x-u)/a,F=(v-x)/(w-y)/a,I=i*F;for(let k=T;k<=P;k++){const _=F*(l-k*i-y)+$,C=Math.max(0,Math.floor(I>0?_-I:_)),q=Math.min(s-1,Math.floor(I>0?_:_-I));if(q<C)continue;const gt=k*s;for(let Q=gt+C;Q<=gt+q;Q++)n[Q]=p?p[Q]:255}}}}return new R({pixelType:o.pixelType,width:s,height:r,mask:n,pixels:[...o.pixels]})}function Ao(o,t){const{extent:e}=To(o,t,new X({x:o.pixelSize.x,y:o.pixelSize.y,spatialReference:o.spatialReference})),{extent:s}=o.extent;if(e.xmax=Math.min(e.xmax,s.xmax),e.ymax=Math.min(e.ymax,s.ymax),e.xmin<e.xmax&&e.ymin<e.ymax){const{x:r,y:n}=o.pixelSize,a=Math.round(e.width/r),i=Math.round(e.height/n);o.extent=e,o.width=a,o.height=i}}function To(o,t,e,s=!0){const{spatialReference:r}=o,{x:n,y:a}=go(e,r);let i,u,l;const c=t.type==="extent"?t:t.extent;let{xmin:p,xmax:m,ymax:f,ymin:g}=c;const{xmin:x,ymax:y}=o.extent;return s?(p=x+(p>x?n*Math.round((p-x)/n):0),f=y-(f<y?a*Math.round((y-f)/a):0),m=x+(m>x?n*Math.round((m-x)/n):0),g=y-(g<y?a*Math.round((y-g)/a):0),i=new Gt({xmin:p,ymax:f,xmax:m,ymin:g,spatialReference:r}),u=Math.round(i.width/n),l=Math.round(i.height/a)):(u=Math.floor((m-p)/n+.8),l=Math.floor((f-g)/a+.8),p=x+(p>x?n*Math.floor((p-x)/n+.1):0),f=y-(f<y?a*Math.floor((y-f)/a+.1):0),m=p+u*n,g=f-l*a,i=new Gt({xmin:p,ymax:f,xmax:m,ymin:g,spatialReference:r})),{extent:i,width:u,height:l}}function ue(){if(!cn)throw new Et("rasterprojectionhelper-project","projection operator is not loaded")}const Bs=(o,t,e,s=0)=>{if(e[0]===1)return[0,0];let r=1,n=-1,a=1,i=-1;for(let y=0;y<o.length;y+=2)isNaN(o[y])||(r=r>o[y]?o[y]:r,n=n>o[y]?n:o[y],a=a>o[y+1]?o[y+1]:a,i=i>o[y+1]?i:o[y+1]);const{cols:u,rows:l}=t,c=(n-r)/u/e[0],p=(i-a)/l/e[1],m=2*s;let f=0,g=!1,x=[0,0];for(let y=0;y<u-3;y++){for(let v=0;v<l-3;v++){const w=y*l*2+2*v,A=(o[w]+o[w+4]+o[w+4*l]+o[w+4*l+4])/4,b=(o[w+1]+o[w+5]+o[w+4*l+1]+o[w+4*l+5])/4,T=Math.abs((A-o[w+2*l+2])/c),P=Math.abs((b-o[w+2*l+3])/p);if(T+P>f&&(f=T+P,x=[T,P]),m&&f>m){g=!0;break}}if(g)break}return x},Po={3395:20037508342789244e-9,3410:17334193943686873e-9,3857:20037508342788905e-9,3975:17367530445161372e-9,4087:20037508342789244e-9,4088:20015108787169147e-9,6933:17367530445161372e-9,32662:20037508342789244e-9,53001:2001508679602057e-8,53002:1000754339801029e-8,53003:2001508679602057e-8,53004:2001508679602057e-8,53016:14152803599503474e-9,53017:17333573624304302e-9,53034:2001508679602057e-8,53079:20015114352186374e-9,53080:20015114352186374e-9,54001:20037508342789244e-9,54002:10018754171394624e-9,54003:20037508342789244e-9,54004:20037508342789244e-9,54016:14168658027268292e-9,54017:1736753044516137e-8,54034:20037508342789244e-9,54079:20037508342789244e-9,54080:20037508342789244e-9,54100:20037508342789244e-9,54101:20037508342789244e-9},xe=32,we=4,Ne=we,Fe=new Map,Ie=new Map,be=500;let ce,nt,ke,cn=!1;async function va(){return ce||(ce=vn(),nt=await ge(()=>import("./projectOperator-CK80jXlK.js"),__vite__mapDeps([16,7,8,17,5,6,9,10])),ke=await ge(()=>import("./geographicTransformationUtils-C6N8q82i.js"),__vite__mapDeps([18,7,8,6,9,10,19])),nt.isLoaded()||await nt.load(),ke.isLoaded()||await ke.load(),cn=!0,ce.resolve()),ce.promise}function Aa(o,t,e,s){const r=o.spatialReference;if(!r||!t||r.equals(t))return o;ue();const n=e.center,a=new Gt({xmin:n.x-o.x/2,xmax:n.x+o.x/2,ymin:n.y-o.y/2,ymax:n.y+o.y/2,spatialReference:r}),i=nt.execute(a,t,{geographicTransformation:s}),u=lt(t);return i==null||u!=null&&i.width>=u?Ro(o,r,t):{x:i.width,y:i.height}}function Ro(o,t,e){const s=zt(t)/zt(e);return{x:o.x*s,y:o.y*s}}function J(o,t=.01){return zt(o)?t/zt(o):0}function js(o,t,e,s=!0){const r=o.spatialReference;if(r.equals(t))return o;ue();const n=nt.execute(o,t,{geographicTransformation:e});return s&&n&&pn([o],[n],r,t),n}function pn(o,t,e,s){const r=ve(e,!0),n=ve(s,!0),a=J(e,be),i=J(s,be);if(a&&r!=null&&n!=null)for(let u=0;u<o.length;u++){const l=t[u];if(!l)continue;const{x:c}=o[u],{x:p}=l;p>=n[1]-i&&Math.abs(c-r[0])<a?l.x-=n[1]-n[0]:p<=n[0]+i&&Math.abs(c-r[1])<a&&(l.x+=n[1]-n[0])}}function $o(o){const{inSR:t,outSR:e,preferPE:s}=o;if(t.equals(e)){const{points:r}=ps(o,null);return r}return t.isWebMercator&&e.isWGS84||t.isWGS84&&e.isWebMercator?Fo(o):s&&(t.isGeographic||Ot(t)!=null)?Gs(o):No(o)}function No(o){const{points:t}=ps(o,null),{inSR:e,outSR:s,datumTransformation:r}=o,n=t.map(i=>new X(i[0],i[1],e)),a=nt.executeMany(n,s,{geographicTransformation:r});return r&&pn(n,a,e,s),a.map(i=>i?[i.x,i.y]:[NaN,NaN])}function Gs(o){const{inSR:t,outSR:e,datumTransformation:s}=o,r=Ot(t),{points:n,mask:a}=ps(o,r);if(!t.isGeographic){const u=t.wkid?st.coordsys(t.wkid):st.fromString(t.isGeographic?et.PE_TYPE_GEOGCS:et.PE_TYPE_PROJCS,t.wkt2||t.wkt);gs.projToGeog(u,n.length,n)}if(s!=null&&s.steps.length){let u;if(e.isGeographic&&(u=n.map(([c])=>c>179.9955?1:c<-179.9955?-1:0)),s.steps.forEach(c=>{const p=c.wkid?st.geogtran(c.wkid):st.fromString(et.PE_TYPE_GEOGTRAN,c.wkt);$n.geogToGeog(p,n.length,n,null,c.isInverse?et.PE_TRANSFORM_2_TO_1:et.PE_TRANSFORM_1_TO_2)}),u)for(let c=0;c<n.length;c++){const p=u[c],m=n[c][0],f=m>179.9955?1:m<-179.9955?-1:0;p&&f&&p!==f&&(n[c][0]=p>0?m+360:m-360)}}if(!e.isGeographic){const u=Ot(e,!0),l=u!=null&&u.isEnvelope?[u.bbox[1],u.bbox[3]]:[-90,90];Io(n,l);const c=e.wkid?st.coordsys(e.wkid):st.fromString(e.isGeographic?et.PE_TYPE_GEOGCS:et.PE_TYPE_PROJCS,e.wkt2||e.wkt);gs.geogToProj(c,n.length,n)}let i=n;if(a&&n.length!==a.length){i=[];for(let u=0,l=0;u<a.length;u++)a[u]?i.push(n[l++]):i.push([NaN,NaN])}return i}function Fo(o){const{cols:t,rows:e,xres:s,yres:r,usePixelCenter:n,inSR:a,outSR:i}=o;let{xmin:u,ymax:l}=o;n&&(u+=s/2,l-=r/2);const c=[],p=[],m=Math.max(t,e);for(let g=0;g<m;g++){const x=u+s*Math.min(t,g),y=l-r*Math.min(e,g),v=Hn(new X({x,y,spatialReference:a}),a,i);g<=t&&c.push(v.x),g<=e&&p.push(v.y)}const f=[];for(let g=0;g<t;g++)for(let x=0;x<e;x++)f.push([c[g],p[x]]);return f}function Ot(o,t=!1){let e=o.wkid||o.wkt2||o.wkt;if(!e||o.isGeographic)return null;if(e=String(e),Fe.has(e)){const a=Fe.get(e);return t?a?.gcs:a?.pcs}const s=o.wkid?st.coordsys(o.wkid):st.fromString(o.isGeographic?et.PE_TYPE_GEOGCS:et.PE_TYPE_PROJCS,o.wkt2||o.wkt),r=zs(s,J(o,1e-4)),n=zs(s,0,!0);return Fe.set(e,{pcs:r,gcs:n}),t?n:r}function zs(o,t=0,e=!1){const s=Rn.generate(o),r=e?o.horizonGcsGenerate():o.horizonPcsGenerate();if(!s||!r?.length)return null;let n=!1,a=r.find(y=>y.getInclusive()===1&&y.getKind()===1);if(!a){if(a=r.find(y=>y.getInclusive()===1&&y.getKind()===0),!a)return null;n=!0}const i=e?0:(s.getNorthPoleLocation()===2?1:0)|(s.getSouthPoleLocation()===2?2:0),u=s.isPannableRectangle(),l=a.getCoord();if(n)return{isEnvelope:n,isPannable:u,vertices:l,coef:null,bbox:[l[0][0]-t,l[0][1]-t,l[1][0]+t,l[1][1]+t],poleLocation:i};let c=0;const p=[];let[m,f]=l[0],[g,x]=l[0];for(let y=0,v=l.length;y<v;y++){c++,c===v&&(c=0);const[w,A]=l[y],[b,T]=l[c];if(T===A)p.push([w,b,A,T,2]);else{const P=(b-w)/(T-A||1e-4),$=w-P*A;A<T?p.push([P,$,A,T,0]):p.push([P,$,T,A,1])}m=m<w?m:w,f=f<A?f:A,g=g>w?g:w,x=x>A?x:A}return{isEnvelope:!1,isPannable:u,vertices:l,coef:p,bbox:[m,f,g,x],poleLocation:i}}function ps(o,t){const e=[],{cols:s,rows:r,xres:n,yres:a,usePixelCenter:i}=o;let{xmin:u,ymax:l}=o;if(i&&(u+=n/2,l-=a/2),t==null){for(let f=0;f<s;f++)for(let g=0;g<r;g++)e.push([u+n*f,l-a*g]);return{points:e}}const c=new Uint8Array(s*r);if(t.isEnvelope){const{bbox:[f,g,x,y]}=t;for(let v=0,w=0;v<s;v++){const A=u+n*v,b=t.isPannable||A>=f&&A<=x;for(let T=0;T<r;T++,w++){const P=l-a*T;b&&P>=g&&P<=y&&(e.push([A,P]),c[w]=1)}}return{points:e,mask:c}}const p=t.coef,m=[];for(let f=0;f<r;f++){const g=l-a*f,x=[],y=[];for(let w=0;w<p.length;w++){const[A,b,T,P,$]=p[w];if(g===T&&T===P)x.push(A),x.push(b),y.push(2),y.push(2);else if(g>=T&&g<=P){const F=A*g+b;x.push(F),y.push($)}}let v=x;if(x.length>2){let w=y[0]===2?0:y[0],A=x[0];v=[];for(let b=1;b<y.length;b++)y[b]===2&&b!==y.length-1||(y[b]!==w&&(v.push(w===0?Math.min(A,x[b-1]):Math.max(A,x[b-1])),w=y[b],A=x[b]),b===y.length-1&&v.push(y[b]===0?Math.min(A,x[b]):Math.max(A,x[b])));v.sort((b,T)=>b-T)}else x[0]>x[1]&&(v=[x[1],x[0]]);m.push(v)}for(let f=0,g=0;f<s;f++){const x=u+n*f;for(let y=0;y<r;y++,g++){const v=l-a*y,w=m[y];if(w.length===2)x>=w[0]&&x<=w[1]&&(e.push([x,v]),c[g]=1);else if(w.length>2){let A=!1;for(let b=0;b<w.length;b+=2)if(x>=w[b]&&x<=w[b+1]){A=!0;break}A&&(e.push([x,v]),c[g]=1)}}}return{points:e,mask:c}}function Io(o,t){const[e,s]=t;for(let r=0;r<o.length;r++){const n=o[r][1];(n<e||n>s)&&(o[r]=[NaN,NaN])}}function ko(o,t){const e=lt(o[0].spatialReference);if(o.length<2||e==null||(t=t??J(o[0].spatialReference),(o=o.filter(i=>i.width>t)).length===1))return o[0];let{xmin:s,xmax:r,ymin:n,ymax:a}=o[0];for(let i=1;i<o.length;i++){const u=o[i];r=u.xmax+e*i,n=Math.min(n,u.ymin),a=Math.max(a,u.ymax)}return new Gt({xmin:s,xmax:r,ymin:n,ymax:a,spatialReference:o[0].spatialReference})}function hn(o,t,e=null,s=!0){const r=o.spatialReference;if(r.equals(t)||!t)return o;const n=So(o),a=lt(r,!0),i=lt(t);if(n===0||a==null||i==null){const c=Es(o,t,e,s);if(c&&a==null&&i!=null&&Math.abs(c.width-i)<J(t)&&nt.isLoaded()){const p=Ot(r);if(p!=null&&p.poleLocation===0&&o.width<(p.bbox[2]-p.bbox[0])/2)return Mo(o,t)||c}return c}const u=o.clone().normalize();if(u.length===1&&o.xmax<a&&o.xmax-a/2>J(r)){const{xmin:c,xmax:p}=o;for(let m=0;m<=n;m++){const f=m===0?c:-a/2,g=m===n?p-a*m:a/2;u[m]=new Gt({xmin:f,xmax:g,ymin:o.ymin,ymax:o.ymax,spatialReference:r})}}const l=u.map(c=>Es(c,t,e,s)).filter(An);return l.length===0?null:ko(l)}function _o(o,t,e){if(o.type==="extent"){const{xmin:s,ymin:r,xmax:n,ymax:a,spatialReference:i}=o;o=new Ks({rings:[[[s,a],[n,a],[n,r],[s,r],[s,a]]],spatialReference:i})}return o.spatialReference.equals(t)?o:(ue(),nt.execute(o,t,{geographicTransformation:e}))}function Mo(o,t){const e=lt(t);if(e==null)return null;let{xmin:s,ymin:r,xmax:n,ymax:a}=o;const i=o.spatialReference,u=new Ks({spatialReference:i,rings:[[[s,r],[n,r],[n,a],[s,a],[s,r]]]}),l=nt.execute(u,t);if(l.rings.length!==2||!l.rings[0].length||!l.rings[1].length)return null;const{rings:c}=l,p=J(i),m=new Gt({spatialReference:t});for(let f=0;f<2;f++){s=n=c[f][0][0],r=a=c[f][0][1];for(let g=0;g<c[f].length;g++)s=s>c[f][g][0]?c[f][g][0]:s,n=n<c[f][g][0]?c[f][g][0]:n,r=r>c[f][g][1]?c[f][g][1]:r,a=a<c[f][g][1]?c[f][g][1]:a;if(f===0)m.ymin=r,m.ymax=a,m.xmin=s,m.xmax=n;else if(m.ymin=Math.min(m.ymin,r),m.ymax=Math.max(m.ymax,a),Math.abs(n-e/2)<p)m.xmin=s,m.xmax=m.xmax+e;else{if(!(Math.abs(s+e/2)<p))return null;m.xmax=n+e}}return m}function Es(o,t,e,s=!0,r=!0){const n=o.spatialReference;if(n.equals(t)||!t)return o;ue();const a=nt.execute(o,t,{geographicTransformation:e});if(r&&t.isWebMercator&&a&&(a.ymax=Math.min(20037508342787e-6,a.ymax),a.ymin=Math.max(-20037508342787e-6,a.ymin),a.ymin>=a.ymax))return null;if(!s||!a)return a;const i=ve(n,!0),u=ve(t,!0);if(i==null||u==null)return a;const l=J(n,.001),c=J(n,be),p=J(t,.001);if(Math.abs(a.xmin-u[0])<p&&Math.abs(a.xmax-u[1])<p){const m=Math.abs(o.xmin-i[0]),f=Math.abs(i[1]-o.xmax);if(m<l&&f>c){a.xmin=u[0];const g=[];g.push(new X(o.xmax,o.ymin,n)),g.push(new X(o.xmax,(o.ymin+o.ymax)/2,n)),g.push(new X(o.xmax,o.ymax,n));const x=g.map(y=>js(y,t,e)).filter(y=>!isNaN(y?.x)).map(y=>y.x);a.xmax=Math.max.apply(null,x)}if(f<l&&m>c){a.xmax=u[1];const g=[];g.push(new X(o.xmin,o.ymin,n)),g.push(new X(o.xmin,(o.ymin+o.ymax)/2,n)),g.push(new X(o.xmin,o.ymax,n));const x=g.map(y=>js(y,t,e)).filter(y=>!isNaN(y?.x)).map(y=>y.x);a.xmin=Math.min.apply(null,x)}}else{const m=J(t,.001);Math.abs(a.xmin-u[0])<m&&(a.xmin=u[0]),Math.abs(a.xmax-u[1])<m&&(a.xmax=u[1])}return a}function lt(o,t=!1){if(!o)return null;const e=t?20037508342787e-6:20037508342788905e-9;return o.isWebMercator?2*e:o.wkid&&o.isGeographic?360:2*Po[o.wkid]||null}function ve(o,t=!1){if(o.isGeographic)return[-180,180];const e=lt(o,t);return e!=null?[-e/2,e/2]:null}function Os(o,t,e,s){let r=(o-t)/e;return r-Math.floor(r)!==0?r=Math.floor(r):s&&(r-=1),r}function So(o,t=!1){const e=lt(o.spatialReference);if(e==null)return 0;const s=t?0:-(e/2),r=J(o.spatialReference),n=!t&&Math.abs(o.xmax-e/2)<r?e/2:o.xmax,a=!t&&Math.abs(o.xmin+e/2)<r?-e/2:o.xmin;return Os(n,s,e,!0)-Os(a,s,e,!1)}function Ta(o){const t=o.storageInfo.origin.x,e=lt(o.spatialReference,!0);if(e==null)return{originX:t,halfWorldWidth:null,pyramidsInfo:null};const s=e/2,{nativePixelSize:r,storageInfo:n,extent:a}=o,{maximumPyramidLevel:i,blockWidth:u,pyramidScalingFactor:l}=n;let c=r.x;const p=[],m=o.transform!=null&&o.transform.type==="gcs-shift",f=t+(m?0:s),g=m?e-t:s-t;for(let x=0;x<=i;x++){const y=(a.xmax-t)/c/u,v=y-Math.floor(y)===0?y:Math.ceil(y),w=g/c/u,A=w-Math.floor(w)===0?w:Math.ceil(w),b=Math.floor(f/c/u),T=Math.round(f/c)%u,P=(u-Math.round(g/c)%u)%u;p.push({resolutionX:c,blockWidth:u,datasetColumnCount:v,worldColumnCountFromOrigin:A,leftMargin:T,rightPadding:P,originColumnOffset:b}),c*=l}return{originX:t,halfWorldWidth:s,pyramidsInfo:p,hasGCSSShiftTransform:m}}function Co(o){if(!o||o.isGeographic)return o;const t=String(o.wkid||o.wkt2||o.wkt);let e;return Ie.has(t)?e=Ie.get(t):(e=(o.wkid?st.coordsys(o.wkid):st.fromString(et.PE_TYPE_PROJCS,o.wkt2||o.wkt)).getGeogcs().getCode(),Ie.set(t,e)),new Pn({wkid:e})}function Pa(o){const t=o.isAdaptive&&o.spacing==null;let e=o.spacing||[xe,xe],s=_e(o),r={cols:s.size[0]+1,rows:s.size[1]+1};const n=s.outofBoundPointCount>0&&s.outofBoundPointCount<s.offsets.length/2;let a=s.outofBoundPointCount===s.offsets.length/2||t&&n?[0,0]:Bs(s.offsets,r,e,Ne);const i=(a[0]+a[1])/2,u=o.projectedExtent.spatialReference,l=o.srcBufferExtent.spatialReference;if(t&&(n||i>Ne)&&(u.isGeographic||Ot(u),e=[we,we],s=_e({...o,spacing:e}),r={cols:s.size[0]+1,rows:s.size[1]+1},a=Bs(s.offsets,r,e,Ne)),s.error=a,e[0]>1&&(s.coefficients=Ds(s.offsets,r,n)),o.includeGCSGrid&&!u.isGeographic&&!u.isWebMercator)if(l.isGeographic)s.gcsGrid={offsets:s.offsets,coefficients:s.coefficients,spacing:e};else{const c=Ot(u);if(c!=null&&!c.isEnvelope){const p=Co(u),m=hn(o.projectedExtent,p),{offsets:f}=_e({...o,srcBufferExtent:m,spacing:e}),g=Ds(f,r,n);s.gcsGrid={offsets:f,coefficients:g,spacing:e}}}return s}function _e(o){const{projectedExtent:t,srcBufferExtent:e,pixelSize:s,datumTransformation:r,rasterTransform:n}=o,a=t.spatialReference,i=e.spatialReference;ue();const{xmin:u,ymin:l,xmax:c,ymax:p}=t,m=lt(i),f=m!=null&&(o.hasWrapAround||n?.type==="gcs-shift"),g=o.spacing||[xe,xe],x=g[0]*s.x,y=g[1]*s.y,v=g[0]===1,w=Math.ceil((c-u)/x-.1/g[0])+(v?0:1),A=Math.ceil((p-l)/y-.1/g[1])+(v?0:1),b=$o({cols:w,rows:A,xmin:u,ymax:p,xres:x,yres:y,inSR:a,outSR:i,datumTransformation:r,preferPE:g[0]<=we,usePixelCenter:v}),T=[];let P,$=0;const F=v?-1:NaN,{xmin:I,xmax:k,ymax:_,width:C,height:q}=e,gt=J(i,be),Q=m!=null&&I>0&&k>m/2,Dt=Ot(a),le=Dt!=null&&Dt.poleLocation>0;for(let te=0;te<w;te++){const Te=[];for(let ee=0;ee<A;ee++){let V=b[te*A+ee];if(f&&V[0]>k&&V[0]>m/2-gt?V[0]-=m:f&&te===0&&V[0]<0&&Q&&!n&&(V[0]+=m),!V||isNaN(V[0])||isNaN(V[1]))T.push(F),T.push(F),Te.push(null),$++;else{if(n){const fs=n.inverseTransform(new X({x:V[0],y:V[1],spatialReference:i}));V=[fs.x,fs.y]}Te.push(V),te>0&&f&&P[ee]&&V[0]<P[ee][0]&&(V[0]+=m,le&&V[0]>k&&V[0]>m&&(V[0]-=m)),T.push((V[0]-I)/C),T.push((_-V[1])/q)}}P=Te}return{offsets:T,error:null,coefficients:null,outofBoundPointCount:$,spacing:g,size:v?[w,A]:[w-1,A-1]}}function Ds(o,t,e){const{cols:s,rows:r}=t,n=new Float32Array((s-1)*(r-1)*2*6),a=new Float32Array([-0,-1,1,-1,1,-0,1,-0,-0]),i=new Float32Array([-1,1,0,0,-1,1,1,0,0]);for(let u=0;u<s-1;u++){for(let l=0;l<r-1;l++){let c=u*r*2+2*l;const p=o[c],m=o[c+1],f=o[c+2],g=o[c+3];c+=2*r;const x=o[c],y=o[c+1],v=o[c+2],w=o[c+3];let A=0,b=12*(l*(s-1)+u);for(let T=0;T<3;T++)n[b++]=a[A++]*p+a[A++]*f+a[A++]*v;A=0;for(let T=0;T<3;T++)n[b++]=a[A++]*m+a[A++]*g+a[A++]*w;A=0;for(let T=0;T<3;T++)n[b++]=i[A++]*p+i[A++]*x+i[A++]*v;A=0;for(let T=0;T<3;T++)n[b++]=i[A++]*m+i[A++]*y+i[A++]*w}if(e)for(let l=0;l<n.length;l++)isNaN(n[l])&&(n[l]=-1)}return n}function Ra(o){const{spatialReference:t}=o,e=Tn(t);if(!e)return o;const[s,r]=e.valid,n=r-s;let a=0;if(o.xmin<s){const i=s-o.xmin;a=Math.ceil(i/n)}else if(o.xmin>r){const i=o.xmin-r;a=-Math.ceil(i/n)}return new Gt({spatialReference:o.spatialReference,xmin:o.xmin+a*n,ymin:o.ymin,xmax:o.xmax+a*n,ymax:o.ymax})}function $a(o,t,e){const{storageInfo:s,pixelSize:r}=t;let n=0,a=!1;const{pyramidResolutions:i}=s,u=s.tileInfo.format?.toLowerCase()==="mixed"?Math.max(1,Math.min(3,s.tileInfo.dpi/96)):1,l=(o.x+o.y)/2/u;if(i!=null&&i.length){const g=i[i.length-1],x=(g.x+g.y)/2,y=(r.x+r.y)/2;if(l<=y)n=0;else if(l>=x)n=i.length,a=l/x>8;else{let w,A=y;for(let b=1;b<=i.length;b++){if(w=(i[b-1].x+i[b-1].y)/2,l<=w){l===w?n=b:e==="down"?(n=b-1,a=l/A>8):n=e==="up"||l-A>w-l||l/A>2?b:b-1;break}A=w}}const v=n===0?r:i[n-1];return a&&Math.min(v.x,v.y)*zt(t.spatialReference)>19567&&(a=!1),{pyramidLevel:n,pyramidResolution:new X({x:v.x,y:v.y,spatialReference:t.spatialReference}),excessiveReading:a}}const c=Math.log(o.x/r.x)/Math.LN2,p=Math.log(o.y/r.y)/Math.LN2,m=t.storageInfo.maximumPyramidLevel||0;n=e==="down"?Math.floor(Math.min(c,p)):e==="up"?Math.ceil(Math.max(c,p)):Math.round((c+p)/2),n<0?n=0:n>m&&(a=n>m+3,n=m);const f=2**n;return{pyramidLevel:n,pyramidResolution:new X({x:f*t.nativePixelSize.x,y:f*t.nativePixelSize.y,spatialReference:t.spatialReference}),excessiveReading:a}}let xt=class extends z{constructor(){super(...arguments),this.functionName="Clip",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const t=this.sourceRasterInfos[0].clone();this.outputPixelType=this._getOutputPixelType(t.pixelType),t.pixelType=this.outputPixelType,this.rasterInfo=t;const{functionArguments:e}=this,{clippingGeometry:s,clippingType:r}=e;if(!s)return{success:!1,supportsGPU:!1,error:"missing clipping geometry"};if(r==="outside")try{const{spatialReference:n}=t,a=s.type==="extent"?hn(s,n):_o(s,n).extent;a&&Ao(t,a)}catch{}return{success:!0,supportsGPU:!0}}_processPixels(t){return t.pixelBlocks?.[0]}_getWebGLParameters(){const{clippingGeometry:t,clippingType:e}=this.functionArguments;return{clippingGeometry:t.toJSON(),clippingType:e}}};h([d({json:{write:!0,name:"rasterFunction"}})],xt.prototype,"functionName",void 0),h([d({type:fo,json:{write:!0,name:"rasterFunctionArguments"}})],xt.prototype,"functionArguments",void 0),h([d()],xt.prototype,"rasterArgumentNames",void 0),h([d()],xt.prototype,"isNoopProcess",void 0),xt=h([N("esri.layers.support.rasterFunctions.ClipFunction")],xt);const Bo=xt;var ze;let tt=ze=class extends O{castColormapName(o){if(!o)return null;const t=o.toLowerCase();return _n.includes(t)?t:null}readColorRamp(o){return nn(o)}readColorRampName(o,t){if(!o)return null;const e=jt.jsonValues.find(s=>s.toLowerCase()===o.toLowerCase());return e?jt.fromJSON(e):null}clone(){return new ze({colormap:K(this.colormap),colormapName:this.colormapName,colorRamp:this.colorRamp?.clone(),colorRampName:this.colorRampName})}};h([d({type:[[Number]],json:{write:!0}})],tt.prototype,"colormap",void 0),h([d({type:String,json:{write:!0}})],tt.prototype,"colormapName",void 0),h([Js("colormapName")],tt.prototype,"castColormapName",null),h([d({types:Jn,json:{write:!0}})],tt.prototype,"colorRamp",void 0),h([ie("colorRamp")],tt.prototype,"readColorRamp",null),h([d({type:jt.apiValues,json:{type:jt.jsonValues,write:jt.write}})],tt.prototype,"colorRampName",void 0),h([ie("colorRampName")],tt.prototype,"readColorRampName",null),tt=ze=h([N("esri.layers.support.rasterFunctions.ColormapFunctionArguments")],tt);const jo=tt,Go=[[36,0,255],[36,0,255],[36,0,255],[36,0,255],[112,75,3],[113,76,3],[114,77,3],[115,77,3],[116,78,3],[117,79,3],[118,79,3],[119,80,3],[121,81,4],[122,82,4],[123,82,4],[124,83,4],[125,84,4],[126,84,4],[127,85,4],[128,86,4],[129,86,4],[130,87,4],[131,88,4],[132,89,4],[133,89,4],[134,90,4],[135,91,4],[136,91,4],[137,92,4],[138,93,4],[139,94,4],[140,94,4],[142,95,5],[143,96,5],[144,96,5],[145,97,5],[146,98,5],[147,99,5],[148,99,5],[149,100,5],[150,101,5],[151,101,5],[152,102,5],[153,103,5],[154,104,5],[155,104,5],[156,105,5],[157,106,5],[158,106,5],[159,107,5],[160,108,5],[161,108,5],[162,109,5],[164,110,6],[165,111,6],[166,111,6],[167,112,6],[168,113,6],[169,113,6],[170,114,6],[171,115,6],[172,116,6],[173,116,6],[174,117,6],[245,0,0],[245,5,0],[245,10,0],[246,15,0],[246,20,0],[246,25,0],[246,30,0],[247,35,0],[247,40,0],[247,45,0],[247,50,0],[247,55,0],[248,60,0],[248,65,0],[248,70,0],[248,75,0],[249,81,0],[249,86,0],[249,91,0],[249,96,0],[250,101,0],[250,106,0],[250,111,0],[250,116,0],[250,121,0],[251,126,0],[251,131,0],[251,136,0],[251,141,0],[252,146,0],[252,151,0],[252,156,0],[252,156,0],[251,159,0],[250,162,0],[249,165,0],[248,168,0],[247,171,0],[246,174,0],[245,177,0],[245,179,0],[244,182,0],[243,185,0],[242,188,0],[241,191,0],[240,194,0],[239,197,0],[238,200,0],[237,203,0],[236,206,0],[235,209,0],[234,212,0],[233,215,0],[232,218,0],[231,221,0],[230,224,0],[230,226,0],[229,229,0],[228,232,0],[227,235,0],[226,238,0],[225,241,0],[224,244,0],[223,247,0],[165,247,0],[163,244,0],[161,240,0],[158,237,0],[156,233,1],[154,230,1],[152,227,1],[149,223,1],[147,220,1],[145,216,1],[143,213,1],[140,210,2],[138,206,2],[136,203,2],[134,200,2],[132,196,2],[129,193,2],[127,189,2],[125,186,3],[123,183,3],[120,179,3],[118,176,3],[116,172,3],[114,169,3],[111,166,3],[109,162,4],[107,159,4],[105,155,4],[103,152,4],[100,149,4],[98,145,4],[96,142,4],[94,138,5],[91,135,5],[89,132,5],[87,128,5],[85,125,5],[82,121,5],[80,118,5],[78,115,6],[76,111,6],[73,108,6],[71,105,6],[69,101,6],[67,98,6],[65,94,6],[62,91,7],[60,88,7],[58,84,7],[56,81,7],[53,77,7],[51,74,7],[49,71,7],[47,67,8],[44,64,8],[42,60,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8],[40,57,8]],zo=[[36,0,255],[36,0,255],[36,0,255],[36,0,255],[245,20,0],[245,24,0],[245,29,0],[245,31,0],[247,33,0],[247,33,0],[247,37,0],[247,41,0],[247,41,0],[247,41,0],[247,45,0],[247,45,0],[247,47,0],[247,49,0],[247,49,0],[247,54,0],[247,54,0],[247,56,0],[247,58,0],[247,58,0],[250,62,0],[250,62,0],[250,62,0],[250,67,0],[250,67,0],[250,67,0],[250,69,0],[250,71,0],[250,71,0],[250,75,0],[250,75,0],[250,78,0],[250,79,0],[250,79,0],[250,79,0],[250,81,0],[250,83,0],[250,83,0],[250,87,0],[250,87,0],[250,90,0],[250,92,0],[252,93,0],[252,93,0],[252,97,0],[252,97,0],[252,97,0],[252,97,0],[252,101,0],[252,101,0],[252,101,0],[252,101,0],[252,105,0],[252,105,0],[252,107,0],[252,109,0],[252,109,0],[252,113,13],[255,118,20],[255,119,23],[255,121,25],[255,126,33],[255,132,38],[255,133,40],[255,135,43],[255,141,48],[255,144,54],[255,150,59],[255,152,61],[255,153,64],[255,159,69],[255,163,77],[255,165,79],[255,168,82],[255,174,87],[255,176,92],[255,181,97],[255,183,99],[255,186,102],[255,191,107],[255,197,115],[255,201,120],[255,203,123],[255,205,125],[255,209,130],[255,214,138],[255,216,141],[255,218,143],[255,224,150],[255,228,156],[255,234,163],[255,236,165],[255,238,168],[255,243,173],[255,248,181],[255,252,186],[253,252,186],[250,252,187],[244,250,180],[238,247,176],[234,246,173],[231,245,169],[223,240,163],[217,237,157],[211,235,150],[205,233,146],[200,230,142],[195,227,136],[189,224,132],[184,222,126],[180,220,123],[174,217,119],[169,214,114],[163,212,108],[160,210,105],[154,207,101],[148,204,96],[143,201,93],[138,199,88],[134,197,84],[130,194,81],[126,191,77],[117,189,70],[115,186,68],[112,184,64],[106,181,60],[100,179,55],[94,176,49],[92,174,47],[90,173,45],[81,168,37],[75,166,33],[71,163,28],[66,160,24],[62,158,21],[56,156,14],[51,153,0],[51,153,0],[51,153,0],[50,150,0],[50,150,0],[50,150,0],[50,150,0],[49,148,0],[49,148,0],[49,148,0],[48,145,0],[48,145,0],[48,145,0],[48,145,0],[48,143,0],[48,143,0],[48,143,0],[48,143,0],[47,140,0],[47,140,0],[47,140,0],[47,140,0],[46,138,0],[46,138,0],[46,138,0],[46,138,0],[45,135,0],[45,135,0],[45,135,0],[45,135,0],[44,133,0],[44,133,0],[44,133,0],[43,130,0],[43,130,0],[43,130,0],[43,130,0],[43,130,0],[43,130,0],[42,128,0],[42,128,0],[42,128,0],[42,125,0],[42,125,0],[42,125,0],[42,125,0],[41,122,0],[41,122,0],[41,122,0],[41,122,0],[40,120,0],[40,120,0],[40,120,0],[40,120,0],[40,120,0],[39,117,0],[39,117,0],[39,117,0],[39,117,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0],[38,115,0]];function hs(o,t){const e=[],s=[];for(let n=0;n<o.length-1;n++)e.push({type:"algorithmic",algorithm:"esriHSVAlgorithm",fromColor:o[n].slice(1),toColor:o[n+1].slice(1)}),s.push(o[n+1][0]-o[n][0]);const r=o[o.length-1][0];return Ys({type:"multipart",colorRamps:e},{numColors:r,weights:t=t??s})}function Eo(){return hs([[0,0,191,191],[51,0,0,255],[102,255,0,255],[153,255,0,127],[204,191,63,127],[256,20,20,20]])}function Oo(){const o=hs([[0,255,255,255],[70,0,255,0],[80,205,173,193],[100,150,150,150],[110,120,51,100],[130,120,100,200],[140,28,3,144],[160,6,0,55],[180,10,25,30],[201,6,7,27]]);for(let t=o.length;t<256;t++)o.push([6,27,7]);return o}function Do(){return Ys({type:"algorithmic",algorithm:"esriHSVAlgorithm",fromColor:[0,0,0],toColor:[255,255,255]})}function Vo(){const o=[];for(let t=0;t<256;t++){const e=[];for(let s=0;s<3;s++)e.push(Math.round(255*Math.random()));o.push(e)}return o}function Uo(){return hs([[0,38,41,54],[69,79,82,90],[131,156,156,156],[256,253,253,241]],[.268,.238,.495])}function Lo(o){let t;switch(o){case"elevation":t=Eo();break;case"gray":t=Do();break;case"hillshade":t=Uo();break;case"ndvi":t=Go;break;case"ndvi2":t=Oo();break;case"ndvi3":t=zo;break;case"random":t=Vo()}return t?(t=t.map((e,s)=>[s,...e]),t):null}let it=class extends z{constructor(){super(...arguments),this.functionName="Colormap",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const t=this.sourceRasterInfos[0];if(t.bandCount>1)return{success:!1,supportsGPU:!1,error:"colormap-function: source data must be single band"};let{colormap:e,colormapName:s,colorRamp:r,colorRampName:n}=this.functionArguments;if(!e?.length)if(r)this.colorRamp=r,e=Me(r,{interpolateAlpha:!0});else if(n){const u=Zs(n);u&&(e=Me(u),this.colorRamp=nn(u))}else s&&(e=Lo(s));if(!e?.length)return{success:!1,supportsGPU:!1,error:"colormap-function: missing colormap argument"};const a=this._getOutputPixelType(t.pixelType);this.outputPixelType=a.startsWith("f")?"s32":a;const i=t.clone();return i.pixelType=this.outputPixelType,i.colormap=e,i.bandCount=1,this.rasterInfo=i,{success:!0,supportsGPU:!0}}_processPixels(t){let e=t.pixelBlocks?.[0];return!e||W(e.pixelType)||(e=e.clone(),e.clamp(this.outputPixelType)),e}};h([d({json:{write:!0,name:"rasterFunction"}})],it.prototype,"functionName",void 0),h([d({type:jo,json:{write:!0,name:"rasterFunctionArguments"}})],it.prototype,"functionArguments",void 0),h([d()],it.prototype,"rasterArgumentNames",void 0),h([d()],it.prototype,"isNoopProcess",void 0),h([d({json:{write:!0}})],it.prototype,"indexedColormap",void 0),h([d()],it.prototype,"colorRamp",void 0),it=h([N("esri.layers.support.rasterFunctions.ColormapFunction")],it);const Wo=it;var Ee;let Oe=Ee=class extends O{clone(){return new Ee({raster:this.raster})}};Oe=Ee=h([N("esri.layers.support.rasterFunctions.ColormapToRGBFunctionArguments")],Oe);const qo=Oe;let wt=class extends z{constructor(){super(...arguments),this.functionName="ColormapToRGB",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const t=this.sourceRasterInfos[0];if(t.bandCount>1||!t.colormap?.length)return{success:!1,supportsGPU:!1,error:"colormap-to-rgb-function: source data must be single band with a colormap"};const e=t.clone();e.pixelType=this.outputPixelType=this._getOutputPixelType("u8"),this._removeStatsHistColormapVAT(e),e.bandCount=3,e.statistics=[{min:0,max:255,avg:100,stddev:20},{min:0,max:255,avg:100,stddev:20},{min:0,max:255,avg:100,stddev:20}],this.rasterInfo=e;const s=[...t.colormap].sort((a,i)=>a[0]-i[0]),{indexedColormap:r,offset:n}=Qs({colormap:s});return r?(this.lookup={indexedColormap:r,offset:n},{success:!0,supportsGPU:tn(r)}):{success:!1,supportsGPU:!1,error:"colormap-to-rgb-function: the colormap is not supported"}}_processPixels(t){let e=t.pixelBlocks?.[0];if(!e||!this.lookup)return e;e=e.clone();const s=e.pixels[0],r=e.mask??new Uint8Array(s.length).fill(255),n=new Uint8Array(s.length),a=new Uint8Array(s.length),i=new Uint8Array(s.length),{indexedColormap:u,offset:l}=this.lookup,c=u.length;for(let p=0;p<s.length;p++)if(r[p]){let m=4*(s[p]-l);m<0||m>c-4?r[p]=0:(n[p]=u[m++],a[p]=u[m++],i[p]=u[m++])}return e.pixels=[n,a,i],e.statistics=[new Pe(0,255),new Pe(0,255),new Pe(0,255)],e.pixelType=this.outputPixelType,e}_getWebGLParameters(){return this.lookup}};h([d({json:{write:!0,name:"rasterFunction"}})],wt.prototype,"functionName",void 0),h([d({type:qo,json:{write:!0,name:"rasterFunctionArguments"}})],wt.prototype,"functionArguments",void 0),h([d()],wt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],wt.prototype,"lookup",void 0),wt=h([N("esri.layers.support.rasterFunctions.ColormapToRGBFunction")],wt);const Ho=wt;var De;let re=De=class extends O{constructor(){super(...arguments),this.rasters=[]}writeRasters(o,t){t.rasters=o.map(e=>typeof e=="number"||typeof e=="string"?e:e.toJSON())}clone(){return new De({rasters:K(this.rasters)})}};h([d({json:{write:!0}})],re.prototype,"rasters",void 0),h([Ae("rasters")],re.prototype,"writeRasters",null),re=De=h([N("esri.layers.support.rasterFunctions.CompositeBandFunctionArguments")],re);const Jo=re;let Wt=class extends z{constructor(){super(...arguments),this.functionName="CompositeBand",this.functionArguments=null,this.rasterArgumentNames=["rasters"]}_bindSourceRasters(){const{sourceRasterInfos:t}=this,e=t[0];this.outputPixelType=this._getOutputPixelType(e.pixelType);const s=e.clone();if(s.attributeTable=null,s.colormap=null,s.pixelType=this.outputPixelType,s.bandCount=t.map(({bandCount:n})=>n).reduce((n,a)=>n+a),t.every(({statistics:n})=>n!=null&&n.length)){const n=[];t.forEach(({statistics:a})=>a!=null&&n.push(...a)),s.statistics=n}if(t.every(({histograms:n})=>n!=null&&n.length)){const n=[];t.forEach(({histograms:a})=>a!=null&&n.push(...a)),s.histograms=n}s.multidimensionalInfo&&s.multidimensionalInfo.variables.forEach(n=>{const a=t.map(l=>l.multidimensionalInfo?.variables.find(({name:c})=>c===n.name)),i=a.map(l=>l?.statistics?.length?l.statistics:null),u=a.map(l=>l?.histograms?.length?l.histograms:null);n.statistics=i.every(l=>l!=null)?i.flat():null,n.histograms=u.every(l=>l!=null)?u.flat():null}),s.bandCount>1&&(s.colormap=null,s.attributeTable=null);const r=t.every(n=>n.keyProperties.BandProperties?.length)?t.flatMap(n=>n.keyProperties.BandProperties):void 0;return s.keyProperties={...s.keyProperties,BandProperties:r},this.rasterInfo=s,{success:!0,supportsGPU:s.bandCount<=3}}_processPixels(t){const{pixelBlocks:e}=t;return e?e?.[0]==null?null:Mn(e):null}_getWebGLParameters(){return{bandCount:this.rasterInfo.bandCount}}};h([d({json:{write:!0,name:"rasterFunction"}})],Wt.prototype,"functionName",void 0),h([d({type:Jo,json:{write:!0,name:"rasterFunctionArguments"}})],Wt.prototype,"functionArguments",void 0),h([d()],Wt.prototype,"rasterArgumentNames",void 0),Wt=h([N("esri.layers.support.rasterFunctions.CompositeBandFunction")],Wt);const Ko=Wt,Xo=new ot({0:"difference",1:"relative-difference",2:"categorical",3:"euclidean-distance",4:"angle-difference",5:"band-with-most-change"},{useNumericKeys:!0}),Yo=new ot({0:"all",1:"changed",2:"unchanged"},{useNumericKeys:!0});function Zo(o,t,e,s){const[r,n]=o,a=W(e)&&!W(r.pixelType)&&!W(n.pixelType),i=[r.mask,n.mask].filter(g=>g),u=R.combineBandMasks(i),l=o.map(g=>g.pixels[0]),{width:c,height:p}=r,m=R.createEmptyBand(e,c*p);switch(t){case"difference":case"relative-difference":Qo({bands:l,mask:u,outBand:m,isRoundingNeeded:a,isRelative:t==="relative-difference"});break;case"categorical":ti({bands:l,mask:u,outBand:m,...s});break;case"euclidean-distance":ei({pixels:o.map(g=>g.pixels),mask:u,outBand:m});break;case"angle-difference":si({pixels:o.map(g=>g.pixels),mask:u,outBand:m});break;case"band-with-most-change":ni({pixels:o.map(g=>g.pixels),mask:u,outBand:m})}const f=new R({width:c,height:p,pixels:[m],pixelType:e,mask:u});return f.updateStatistics(),f}function Qo(o){const{bands:[t,e],mask:s,isRelative:r,isRoundingNeeded:n,outBand:a}=o,i=t.length;for(let u=0;u<i;u++)if(!s||s[u]){let l=t[u]-e[u];if(r){const c=Math.max(Math.abs(t[u])-Math.abs(e[u]));l=c>0?l/c:0}a[u]=n?Math.round(l):l}}function ti(o){const{bands:[t,e],categoryIndexLookups:[s,r],classNames:[n,a],mask:i,keepMethod:u,outBand:l}=o,c=t.length,p=n.length,m=a.length,f=p*m,g=f+1,x=f+2;for(let y=0;y<c;y++)if(!i||i[y]){const v=t[y],w=e[y],A=s[v],b=r[w],T=n[A],P=a[b];l[y]=A==null||b==null?f:u==="changed"&&T===P?g:u==="unchanged"&&T!==P?x:A*m+b}}function ei(o){const{pixels:[t,e],mask:s,outBand:r}=o,n=t[0].length,a=t.length;for(let i=0;i<n;i++)if(!s||s[i]){let u=0;for(let l=0;l<a;l++){const c=t[l][i]-e[l][i];u+=c*c}r[i]=Math.sqrt(u)}}function si(o){const{pixels:[t,e],mask:s,outBand:r}=o,n=t[0].length,a=t.length;for(let i=0;i<n;i++)if(!s||s[i]){let u=0,l=0,c=0;for(let m=0;m<a;m++){const f=t[m][i],g=e[m][i];u+=f*g,l+=f*f,c+=g*g}const p=Math.sqrt(l*c);r[i]=p?Math.acos(u/p):1.5707963267948966}}function ni(o){const{pixels:[t,e],mask:s,outBand:r}=o,n=t[0].length,a=t.length;for(let i=0;i<n;i++)if(!s||s[i]){let u=0,l=0;for(let c=0;c<a;c++){const p=Math.abs(t[c][i]-e[c][i]);p>u&&(u=p,l=c)}r[i]=l}}var Ve;let bt=Ve=class extends O{constructor(){super(...arguments),this.method="difference",this.keepMethod="all",this.raster2=void 0}get rasters(){return[this.raster,this.raster2]}clone(){return new Ve({raster:this.raster,raster2:this.raster2,method:this.method,keepMethod:this.keepMethod})}};h([rt(Xo)],bt.prototype,"method",void 0),h([rt(Yo)],bt.prototype,"keepMethod",void 0),h([d({json:{write:!0}})],bt.prototype,"raster2",void 0),h([d({readOnly:!0})],bt.prototype,"rasters",null),bt=Ve=h([N("esri.layers.support.rasterFunctions.ComputeChangeFunctionArguments")],bt);const ri=bt;let vt=class extends z{constructor(){super(...arguments),this.functionName="ComputeChange",this.functionArguments=null,this.rasterArgumentNames=["raster","raster2"]}_bindSourceRasters(){const{method:t}=this.functionArguments,e=this.sourceRasterInfos[0].clone();if(this.outputPixelType=this._getOutputPixelType(e.pixelType),e.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(e),t==="categorical"){const s=this.sourceRasterInfos.map(a=>a.attributeTable),r=this._getFieldNames(s,"value"),n=s.map(a=>this._getClassFieldName(a));if(r[0]==null||r[1]==null||n[0]==null||n[1]==null)return{success:!1,supportsGPU:!1,error:"both inputs must have proper attribute table with value and class fields"};this._updateAttributeTable(e,r,n)}return e.bandCount=1,this.rasterInfo=e,{success:!0,supportsGPU:t==="difference"||t==="relative-difference"}}_processPixels(t){const{pixelBlocks:e}=t;if(e?.[0]==null||e?.[1]==null)return null;const{method:s}=this.functionArguments;return Zo(e,s,this.outputPixelType,this._categoryConfig)}_getWebGLParameters(){const t=this.outputPixelType??"f32";let[e,s]=dt(t);const r=W(t);return r&&(e-=1e-4,s+=1e-4),{method:this.functionArguments.method,domainRange:[e,s],isOutputRounded:r}}_updateAttributeTable(t,e,s){const r=this.sourceRasterInfos.map(b=>b.attributeTable),n=r.map((b,T)=>b.features.map(P=>P.attributes[e[T]])),a=r.map((b,T)=>b.features.map(P=>P.attributes[s[T]])),i=n.map(b=>{const T=[];return b.forEach((P,$)=>T[P]=$),T}),{keepMethod:u}=this.functionArguments;this._categoryConfig={categoryIndexLookups:i,classNames:a,keepMethod:u};const l=r[0].clone();l.fields=[new ct({name:"OID",type:"oid"}),new ct({name:"Value",type:"integer"}),new ct({name:"ClassName",type:"string"}),new ct({name:"Class_From",type:"string"}),new ct({name:"Class_To",type:"string"})];const c=this._getFieldNames(r,"red"),p=this._getFieldNames(r,"green"),m=this._getFieldNames(r,"blue"),f=[],g=c.length===2&&p.length===2&&m.length===2;g&&(f.push(...r.map((b,T)=>b.features.map(P=>[P.attributes[c[T]],P.attributes[p[T]],P.attributes[m[T]]]))),l.fields.push(new ct({name:"Red",type:"integer"}),new ct({name:"Green",type:"integer"}),new ct({name:"Blue",type:"integer"})));const x=l.features[0].clone();x.geometry=null;const y=[],[v,w]=n.map(b=>b.length);let A=1;for(let b=0;b<v;b++){const T=a[0][b];for(let P=0;P<w;P++){const $=a[1][P];if(u==="changed"&&T===$||u==="unchanged"&&T!==$)continue;const F=x.clone();F.attributes={OID:A++,Value:b*w+P,ClassName:T===$?T:`${T} -> ${$}`,Class_From:T,Class_To:$},g&&(F.attributes.Red=f[0][b][0]+f[1][P][0]>>1,F.attributes.Green=f[0][b][1]+f[1][P][1]>>1,F.attributes.Blue=f[0][b][2]+f[1][P][2]>>1),y.push(F)}}if(u==="changed"){const b=x.clone();b.attributes={OID:A++,Value:v*w+1,ClassName:"No Change",Class_From:"Same",Class_To:"Same"},y.push(b)}else if(u==="unchanged"){const b=x.clone();b.attributes={OID:A++,Value:v*w+2,ClassName:"Changed",Class_From:"Any",Class_To:"Any"},y.push(b)}l.features=y,t.attributeTable=l}_getFieldNames(t,e){return t.map(({fields:s})=>s.find(r=>r.name.toLowerCase()===e)?.name).filter(s=>s)}_getClassFieldName(t){return(t.fields.find(s=>s.type==="string"&&s.name.toLowerCase().startsWith("class"))??t.fields.find(s=>s.type==="string"&&s.name.toLowerCase().includes("class")||s.name.toLowerCase().includes("type")||s.name.toLowerCase().includes("name"))??t.fields.find(s=>s.type==="string"))?.name}};h([d({json:{write:!0,name:"rasterFunction"}})],vt.prototype,"functionName",void 0),h([d({type:ri,json:{write:!0,name:"rasterFunctionArguments"}})],vt.prototype,"functionArguments",void 0),h([d()],vt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],vt.prototype,"_categoryConfig",void 0),vt=h([N("esri.layers.support.rasterFunctions.ComputeChangeFunction")],vt);const oi=vt;var Ue;let oe=Ue=class extends O{constructor(){super(...arguments),this.contrastOffset=0,this.brightnessOffset=0}clone(){return new Ue({contrastOffset:this.contrastOffset,brightnessOffset:this.brightnessOffset,raster:this.raster})}};h([d({json:{write:!0}})],oe.prototype,"contrastOffset",void 0),h([d({json:{write:!0}})],oe.prototype,"brightnessOffset",void 0),oe=Ue=h([N("esri.layers.support.rasterFunctions.ContrastBrightnessFunctionArguments")],oe);const ii=oe;let At=class extends z{constructor(){super(...arguments),this.functionName="ContrastBrightness",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null}_bindSourceRasters(){const{sourceRasterInfos:t}=this,e=t[0];if(e.pixelType!=="u8")return{success:!1,supportsGPU:!1,error:"Only unsigned 8 bit raster is supported by ContrastBrightness function."};this.outputPixelType=this._getOutputPixelType("u8");const s=e.clone();this._removeStatsHistColormapVAT(s),this.rasterInfo=s;const{contrastOffset:r,brightnessOffset:n}=this.functionArguments;return this.lookup=Sn(r,n),{success:!0,supportsGPU:!0}}_processPixels(t){const e=t.pixelBlocks?.[0];return e==null?null:us(e,{lut:e.pixels.map(()=>this.lookup),offset:0,outputPixelType:"u8"})}_getWebGLParameters(){const{contrastOffset:t,brightnessOffset:e}=this.functionArguments;return{contrastOffset:t,brightnessOffset:e}}};h([d({json:{write:!0,name:"rasterFunction"}})],At.prototype,"functionName",void 0),h([d({type:ii,json:{write:!0,name:"rasterFunctionArguments"}})],At.prototype,"functionArguments",void 0),h([d()],At.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],At.prototype,"lookup",void 0),At=h([N("esri.layers.support.rasterFunctions.ContrastBrightnessFunction")],At);const ai=At;function ms(o,t,e,s,r){const n=Math.floor(s/2);for(let i=0;i<n;i++)for(let u=0;u<t;u++)o[i*t+u]=o[(r-1-i)*t+u],o[(e-1-i)*t+u]=o[(e-r+i)*t+u];const a=Math.floor(r/2);for(let i=0;i<e;i++){const u=i*t;for(let l=0;l<a;l++)o[u+l]=o[u+r-1-l],o[u+t-l-1]=o[u+t+l-r]}}const j=new Map;function ui(o){const t=Math.sqrt(o.length),e=o.slice(0,t),s=[1];for(let r=1;r<t;r++){let n=null;for(let a=0;a<t;a++){const i=o[a+r*t],u=o[a];if(n==null)if(u===0){if(i)return{separable:!1,row:null,col:null}}else n=i/u;else if(i/u!==n)return{separable:!1,row:null,col:null}}if(n==null)return{separable:!1,row:null,col:null};s.push(n)}return{separable:!0,row:e,col:s}}function Vs(o,t,e,s,r,n,a){const i=new Float32Array(t*e),u=n.length,l=a?0:s,c=a?s:0,p=a?1:t;for(let m=l;m<e-l;m++){const f=m*t;for(let g=c;g<t-c;g++){if(r&&!r[f+g])continue;let x=0;for(let y=0;y<u;y++)x+=o[f+g+(y-s)*p]*n[y];i[f+g]=x}}return i}function li(o,t,e,s,r,n,a){const i=new Float32Array(t*e),u=Math.floor(s/2),l=Math.floor(r/2);for(let c=u;c<e-u;c++){const p=c*t;for(let m=l;m<t-l;m++){if(n&&!n[p+m])continue;let f=0;for(let g=0;g<s;g++)for(let x=0;x<r;x++)f+=o[p+m+(g-u)*t+x-l]*a[g*r+x];i[p+m]=f}}return i}function ci(o,t,e=!0){const{pixels:s,width:r,height:n,pixelType:a,mask:i}=o,u=s.length,l=[],{kernel:c,rows:p,cols:m}=t;for(let f=0;f<u;f++){const g=li(s[f],r,n,p,m,i,c);e&&ms(g,r,n,p,m),l.push(g)}return new R({width:r,height:n,pixelType:a,pixels:l,mask:i})}function pi(o,t,e,s=!0){const{pixels:r,width:n,height:a,pixelType:i,mask:u}=o,l=r.length,c=[],p=t.length,m=e.length,f=Math.floor(p/2),g=Math.floor(m/2);for(let x=0;x<l;x++){let y=Vs(r[x],n,a,f,u,t,!0);y=Vs(y,n,a,g,u,e,!1),s&&ms(y,n,a,p,m),c.push(y)}return new R({width:n,height:a,pixelType:i,pixels:c,mask:u})}function hi(o,t){const e=ui(t.kernel),s=t.mirrorEdges!==!1,r=e.separable?pi(o,e.row,e.col,s):ci(o,t,s),{outputPixelType:n}=t;return n&&r.clamp(n),r}j.set(S.none,[0,0,0,0,1,0,0,0,0]),j.set(S.lineDetectionHorizontal,[-1,-1,-1,2,2,2,-1,-1,-1]),j.set(S.lineDetectionVertical,[-1,2,-1,-1,2,-1,-1,2,-1]),j.set(S.lineDetectionLeftDiagonal,[2,-1,-1,-1,2,-1,-1,-1,2]),j.set(S.lineDetectionRightDiagonal,[-1,-1,2,-1,2,-1,2,-1,-1]),j.set(S.gradientNorth,[-1,-2,-1,0,0,0,1,2,1]),j.set(S.gradientWest,[-1,0,1,-2,0,2,-1,0,1]),j.set(S.gradientEast,[1,0,-1,2,0,-2,1,0,-1]),j.set(S.gradientSouth,[1,2,1,0,0,0,-1,-2,-1]),j.set(S.gradientNorthEast,[0,-1,-2,1,0,-1,2,1,0]),j.set(S.gradientNorthWest,[-2,-1,0,-1,0,1,0,1,2]),j.set(S.smoothArithmeticMean,[.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111]),j.set(S.smoothing3x3,[.0625,.125,.0625,.125,.25,.125,.0625,.125,.0625]),j.set(S.smoothing5x5,[1,1,1,1,1,1,4,4,4,1,1,4,12,4,1,1,4,4,4,1,1,1,1,1,1]),j.set(S.sharpening3x3,[-1,-1,-1,-1,9,-1,-1,-1,-1]),j.set(S.sharpening5x5,[-1,-3,-4,-3,-1,-3,0,6,0,-3,-4,6,21,6,-4,-3,0,6,0,-3,-1,-3,-4,-3,-1]),j.set(S.laplacian3x3,[0,-1,0,-1,4,-1,0,-1,0]),j.set(S.laplacian5x5,[0,0,-1,0,0,0,-1,-2,-1,0,-1,-2,17,-2,-1,0,-1,-2,-1,0,0,0,-1,0,0]),j.set(S.sobelHorizontal,[-1,-2,-1,0,0,0,1,2,1]),j.set(S.sobelVertical,[-1,0,1,-2,0,2,-1,0,1]),j.set(S.sharpen,[0,-.25,0,-.25,2,-.25,0,-.25,0]),j.set(S.sharpen2,[-.25,-.25,-.25,-.25,3,-.25,-.25,-.25,-.25]),j.set(S.pointSpread,[-.627,.352,-.627,.352,2.923,.352,-.627,.352,-.627]);var Le;let Tt=Le=class extends O{constructor(){super(...arguments),this.rows=3,this.cols=3,this.kernel=[0,0,0,0,1,0,0,0,0]}set convolutionType(o){this._set("convolutionType",o);const t=j.get(o);if(!t||o===S.userDefined||o===S.none)return;const e=Math.sqrt(t.length);this._set("kernel",t),this._set("cols",e),this._set("rows",e)}clone(){return new Le({cols:this.cols,rows:this.rows,kernel:[...this.kernel],convolutionType:this.convolutionType,raster:K(this.raster)})}};h([d({json:{type:Number,write:!0}})],Tt.prototype,"rows",void 0),h([d({json:{type:Number,write:!0}})],Tt.prototype,"cols",void 0),h([d({json:{name:"type",type:Number,write:!0}})],Tt.prototype,"convolutionType",null),h([d({json:{type:[Number],write:!0}})],Tt.prototype,"kernel",void 0),Tt=Le=h([N("esri.layers.support.rasterFunctions.ConvolutionFunctionArguments")],Tt);const mi=Tt,Us=25;let Pt=class extends z{constructor(){super(...arguments),this.functionName="Convolution",this.rasterArgumentNames=["raster"]}get _normalizedKernel(){const{kernel:t,convolutionType:e}=this.functionArguments,s=t.reduce((r,n)=>r+n);return e===-1||s===0||s===1?t:t.map(r=>r/s)}_bindSourceRasters(){const{convolutionType:t,rows:e,cols:s,kernel:r}=this.functionArguments;if(!Object.values(S).includes(t))return{success:!1,supportsGPU:!1,error:`convolution-function: the specified kernel type is not supported ${t}`};if(t!==S.none&&e*s!==r.length)return{success:!1,supportsGPU:!1,error:"convolution-function: the specified rows and cols do not match the length of the kernel"};const n=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType(n.pixelType);const a=n.clone();a.pixelType=this.outputPixelType;const i=[S.none,S.sharpen,S.sharpen2,S.sharpening3x3,S.sharpening5x5];return(t===-1||this.outputPixelType!=="u8"&&!i.includes(t))&&(a.statistics=null,a.histograms=null),a.colormap=null,a.attributeTable=null,this.rasterInfo=a,{success:!0,supportsGPU:r.length<=Us}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null||this.functionArguments.convolutionType===S.none)return e;const{rows:s,cols:r}=this.functionArguments,{_normalizedKernel:n}=this;return hi(e,{kernel:n,rows:s,cols:r,outputPixelType:this.outputPixelType})}_getWebGLParameters(){const t=new Float32Array(Us),{rows:e,cols:s}=this.functionArguments,{_normalizedKernel:r}=this;for(let n=0;n<e;n++)for(let a=0;a<s;a++)t[5*n+a]=r[n*s+a];return{kernelRows:e,kernelCols:s,kernel:t,clampRange:dt(this.outputPixelType)}}};h([d({json:{write:!0,name:"rasterFunction"}})],Pt.prototype,"functionName",void 0),h([d({type:mi,json:{write:!0,name:"rasterFunctionArguments"}})],Pt.prototype,"functionArguments",void 0),h([d()],Pt.prototype,"rasterArgumentNames",void 0),h([d()],Pt.prototype,"_normalizedKernel",null),Pt=h([N("esri.layers.support.rasterFunctions.ConvolutionFunction")],Pt);const fi=Pt;var We;const mn=new ot({0:"standard",1:"planform",2:"profile"},{useNumericKeys:!0});let qt=We=class extends O{constructor(){super(...arguments),this.curvatureType="standard",this.zFactor=1}readCurvatureType(o,t){return mn.fromJSON(t.type??t.curvatureType??0)}clone(){return new We({curvatureType:this.curvatureType,zFactor:this.zFactor,raster:this.raster})}};h([d({json:{write:{target:"type"}}}),rt(mn)],qt.prototype,"curvatureType",void 0),h([ie("curvatureType",["type","curvatureType"])],qt.prototype,"readCurvatureType",null),h([d({type:Number,json:{write:!0}})],qt.prototype,"zFactor",void 0),qt=We=h([N("esri.layers.support.rasterFunctions.CurvatureFunctionArguments")],qt);const di=qt;let Rt=class extends z{constructor(){super(...arguments),this.functionName="Curvature",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){this.outputPixelType=this._getOutputPixelType("f32");const t=this.sourceRasterInfos[0].clone();return t.pixelType=this.outputPixelType,t.bandCount=1,this._removeStatsHistColormapVAT(t),this.rasterInfo=t,this.isGCS=t.spatialReference?.isGeographic??!1,{success:!0,supportsGPU:!0}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return null;const{zFactor:s,curvatureType:r}=this.functionArguments,{extent:n,primaryPixelSizes:a}=t,i=a?.[0],u=i??(n?{x:n.width/e.width,y:n.height/e.height}:{x:1,y:1}),l=this.isGCS&&s>=1?s*ae:s;return Cn(e,{zFactor:l,curvatureType:r,resolution:u})}_getWebGLParameters(){const{zFactor:t,curvatureType:e}=this.functionArguments;return{curvatureType:e,zFactor:this.isGCS&&t>=1?t*ae:t}}};h([d({json:{write:!0,name:"rasterFunction"}})],Rt.prototype,"functionName",void 0),h([d({type:di,json:{write:!0,name:"rasterFunctionArguments"}})],Rt.prototype,"functionArguments",void 0),h([d()],Rt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],Rt.prototype,"isGCS",void 0),Rt=h([N("esri.layers.support.rasterFunctions.CurvatureFunction")],Rt);const gi=Rt;var qe;let at=qe=class extends O{constructor(){super(...arguments),this.bandIds=[],this.bandNames=[],this.bandWavelengths=[],this.missingBandAction=0}clone(){return new qe({bandIds:this.bandIds?.slice(),bandNames:this.bandNames?.slice(),bandWavelengths:this.bandWavelengths?.slice(),missingBandAction:this.missingBandAction,method:this.method,wavelengthMatchTolerance:this.wavelengthMatchTolerance})}};h([d({json:{write:!0}})],at.prototype,"bandIds",void 0),h([d({json:{write:!0}})],at.prototype,"bandNames",void 0),h([d({json:{write:!0}})],at.prototype,"bandWavelengths",void 0),h([rt({0:"name",1:"wavelength",2:"id"})],at.prototype,"method",void 0),h([d({json:{write:!0}})],at.prototype,"missingBandAction",void 0),h([d({json:{write:!0}})],at.prototype,"wavelengthMatchTolerance",void 0),at=qe=h([N("esri.layers.support.rasterFunctions.ExtractBandFunctionArguments")],at);const yi=at;let Ht=class extends z{constructor(){super(...arguments),this.functionName="ExtractBand",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{functionArguments:t,sourceRasterInfos:e}=this,s=e[0],{method:r,bandNames:n,bandWavelengths:a,bandIds:i,missingBandAction:u}=t,l=n?.length&&(r==="name"||r!=="id"&&!i?.length),c=a?.length&&(r==="wavelength"||r!=="id"&&!i?.length),p=u===1,m=l?wi(s,n):c?vi(s,a,this.functionArguments,p):bi(s,i,p);if(m==null)return{success:!1,supportsGPU:!1,error:`extract-band-function: Invalid ${l?"band names":c?"band wavelengths":"band ids"} for the imagery data source`};this.functionArguments.bandIds=m,this.functionArguments.method="id",this.outputPixelType=this._getOutputPixelType("f32");const f=s.clone();f.pixelType=this.outputPixelType,f.bandCount=m.length;const{statistics:g,histograms:x}=f;g!=null&&g.length&&(f.statistics=m.map(v=>g[v]||g[g.length-1])),x!=null&&x.length&&(f.histograms=m.map(v=>x[v]||x[x.length-1])),f.multidimensionalInfo&&f.multidimensionalInfo.variables.forEach(v=>{const{statistics:w,histograms:A}=v;w!=null&&w.length&&(v.statistics=m.map(b=>w[b]||w[w.length-1])),A!=null&&A.length&&(v.histograms=m.map(b=>A[b]||A[A.length-1]))});let y=f.keyProperties?.BandProperties;return y?.length&&(y=m.map(v=>v>=y.length?y[y.length-1]:y[v]),f.keyProperties={...f.keyProperties,BandProperties:y}),this.rasterInfo=f,{success:!0,supportsGPU:f.bandCount<=3}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return null;let{bandIds:s}=this.functionArguments;if(this.rasterInfo.storageInfo.isBsqTile){const{rawInputBandIds:r}=this;s=s.map(n=>r.indexOf(n))}else{const r=e.pixels.length;s=s.map(n=>n>=r?r-1:n)}return e.extractBands(s)}_getWebGLParameters(){let t;if(this.isInputBandIdsSwizzled)t=this.swizzledBandSelection.length?this.swizzledBandSelection:[0,1,2];else{t=[...this.functionArguments.bandIds],t.length===0?t=[0,1,2]:t.length<3&&(t[1]=t[1]??t[0],t[2]=t[2]??t[1]);for(let e=0;e<3;e++)t[e]=Math.min(t[e],2)}return{bandIndexMat3:U(t)}}_getInputBandIds(t){const e=t.length;return this.functionArguments.bandIds.map(s=>s>=e?e-1:s).map(s=>t[s])}_swizzleBandIds(t){const e=this.functionArguments.bandIds.map(s=>t.indexOf(s));return this.isInputBandIdsSwizzled=!0,e[1]??=e[0],e[2]??=e[1],this.swizzledBandSelection=e,!1}};h([d({json:{write:!0,name:"rasterFunction"}})],Ht.prototype,"functionName",void 0),h([d({type:yi,json:{write:!0,name:"rasterFunctionArguments"}})],Ht.prototype,"functionArguments",void 0),h([d()],Ht.prototype,"rasterArgumentNames",void 0),Ht=h([N("esri.layers.support.rasterFunctions.ExtractBandFunction")],Ht);const xi=Ht;function wi(o,t){const e=o.bandInfos.map(({name:r})=>r.toLowerCase()),s=[];for(let r=0;r<t.length;r++){const n=t[r].toLowerCase();let a=e.indexOf(n);if(a===-1&&n==="nearinfrared"&&(a=e.findIndex(i=>i.startsWith("nearinfrared_1")),a===-1&&(a=e.findIndex(i=>i.startsWith("nearinfrared")))),a===-1)return null;s.push(a)}return s}function bi(o,t,e){const{bandCount:s}=o;return!t?.length||e&&t.some(r=>r<0||r>=s)?null:t}function vi(o,t,{wavelengthMatchTolerance:e},s){const{bandInfos:r}=o,n=[];for(let i=0;i<r.length;i++){const{minWavelength:u,maxWavelength:l}=r[i];if(!u||!l)return null;n.push({minWavelength:u,maxWavelength:l})}const a=[];for(let i=0;i<t.length;i++){const u=t[i];let l=!1,c=-1,p=Number.MAX_VALUE;for(let m=0;m<n.length;m++){const f=n[m],g=u>=f.minWavelength&&u<=f.maxWavelength,x=Math.abs(u-(f.minWavelength+f.maxWavelength)/2);g?x<p&&(l=!0,c=m,p=x):!l&&x<p&&(c=m,p=x)}if(!l&&e&&p<e&&(l=!0),!l&&s)return null;a.push(c)}return a}function Ai(o,t,e){const{pixels:s,width:r,height:n,mask:a,bandMasks:i}=o,u=r*n,l=i?.length?R.combineBandMasks(i):a,c=Math.min(t.length,s.length),p=e.startsWith("f"),m=!p&&e!==o.pixelType,[f,g]=dt(e),x=R.createEmptyBand(e,u);for(let v=0;v<n;v++){let w=v*r;for(let A=0;A<r;A++,w++)if(!l||l[w]){let b=0;for(let T=0;T<c;T++)b+=t[T]*s[T][w];p||(b=Math.round(b),m&&(b=b>g?g:b<f?f:b)),x[w]=b}}const y=new R({width:r,height:n,pixels:[x],pixelType:e,mask:l});return y.updateStatistics(),y}var He;let me=He=class extends O{clone(){return new He({conversionParameters:[...this.conversionParameters],raster:this.raster})}};h([d({type:[Number],json:{write:!0}})],me.prototype,"conversionParameters",void 0),me=He=h([N("esri.layers.support.rasterFunctions.GrayscaleFunctionArguments")],me);const Ti=me;let $t=class extends z{constructor(){super(...arguments),this.functionName="Grayscale",this.functionArguments=null,this.rasterArgumentNames=["raster"]}get _normalizedWeights(){const{conversionParameters:t}=this.functionArguments,e=t.reduce((s,r)=>s+r);return t.map(s=>s/e)}_bindSourceRasters(){const{conversionParameters:t}=this.functionArguments;if(!t?.length)return{success:!1,supportsGPU:!1,error:"missing valid conversion parameters."};const e=this.sourceRasterInfos[0].clone();this.outputPixelType=this._getOutputPixelType(e.pixelType),e.pixelType=this.outputPixelType;const s=t.length===3||e.bandCount===3&&t.length>3;return e.bandCount=1,this._removeStatsHistColormapVAT(e),this.rasterInfo=e,{success:!0,supportsGPU:s}}_processPixels(t){const e=t.pixelBlocks?.[0];return e==null?null:Ai(e,this._normalizedWeights,this.outputPixelType)}_getWebGLParameters(){return{weights:this._normalizedWeights}}};h([d({json:{write:!0,name:"rasterFunction"}})],$t.prototype,"functionName",void 0),h([d({type:Ti,json:{write:!0,name:"rasterFunctionArguments"}})],$t.prototype,"functionArguments",void 0),h([d()],$t.prototype,"rasterArgumentNames",void 0),h([d()],$t.prototype,"_normalizedWeights",null),$t=h([N("esri.layers.support.rasterFunctions.GrayscaleFunction")],$t);const Pi=$t;var Je;const Ri=new ot({0:"traditional",1:"multi-directional"},{useNumericKeys:!0}),$i=new ot({1:"degree",2:"percent-rise",3:"scaled"},{useNumericKeys:!0});let Y=Je=class extends O{constructor(){super(...arguments),this.altitude=45,this.azimuth=315,this.hillshadeType="traditional",this.pixelSizePower=.664,this.pixelSizeFactor=.024,this.slopeType="degree",this.zFactor=1,this.removeEdgeEffect=!1}clone(){return new Je({hillshadeType:this.hillshadeType,altitude:this.altitude,azimuth:this.azimuth,zFactor:this.zFactor,slopeType:this.slopeType,pixelSizeFactor:this.pixelSizeFactor,pixelSizePower:this.pixelSizePower,removeEdgeEffect:this.removeEdgeEffect,raster:this.raster})}};h([d({type:Number,json:{write:!0}})],Y.prototype,"altitude",void 0),h([d({type:Number,json:{write:!0}})],Y.prototype,"azimuth",void 0),h([d(),rt(Ri)],Y.prototype,"hillshadeType",void 0),h([d({type:Number,json:{write:!0,name:"psPower"}})],Y.prototype,"pixelSizePower",void 0),h([d({type:Number,json:{write:!0,name:"psZFactor"}})],Y.prototype,"pixelSizeFactor",void 0),h([d(),rt($i)],Y.prototype,"slopeType",void 0),h([d({type:Number,json:{write:!0}})],Y.prototype,"zFactor",void 0),h([d({type:Boolean,json:{write:!0}})],Y.prototype,"removeEdgeEffect",void 0),Y=Je=h([N("esri.layers.support.rasterFunctions.HillshadeFunctionArguments")],Y);const fn=Y;let Nt=class extends z{constructor(){super(...arguments),this.functionName="Hillshade",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){const t=this.sourceRasterInfos[0];if(t.bandCount>1)return{success:!1,supportsGPU:!1,error:"hillshade-function: source data must be single band"};this.outputPixelType=this._getOutputPixelType("u8");const e=t.clone();return this._removeStatsHistColormapVAT(e),e.pixelType=this.outputPixelType,e.bandCount=1,e.statistics=[{min:0,max:255,avg:60,stddev:10}],this.rasterInfo=e,this.isGCS=e.spatialReference?.isGeographic??!1,{success:!0,supportsGPU:!0}}_processPixels(t){const e=t.pixelBlocks?.[0];if(!e)return null;const{extent:s,primaryPixelSizes:r}=t,n=r?.[0],a=n??(s?{x:s.width/e.width,y:s.height/e.height}:{x:1,y:1}),i=de(this.functionArguments,a,this.isGCS),u=en(e,i);return u.pixelType=this.outputPixelType,u}_getWebGLParameters(){const t=de(this.functionArguments,{x:1,y:1},this.isGCS),e=sn(t),{slopeType:s,zFactor:r,pixelSizeFactor:n,pixelSizePower:a}=this.functionArguments,i=s==="scaled",u=W(this.outputPixelType);return{...e,zFactor:r,gcsFactor:this.isGCS?ae:1,pixelSizeFactor:i?n:0,pixelSizePower:i?a:0,isOutputRounded:u}}};h([d({json:{write:!0,name:"rasterFunction"}})],Nt.prototype,"functionName",void 0),h([d({type:fn,json:{write:!0,name:"rasterFunctionArguments"}})],Nt.prototype,"functionArguments",void 0),h([d()],Nt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],Nt.prototype,"isGCS",void 0),Nt=h([N("esri.layers.support.rasterFunctions.HillshadeFunction")],Nt);const Ni=Nt;var Ke;let Ft=Ke=class extends O{constructor(){super(...arguments),this.rasters=[],this.processAsMultiband=!0}writeRasters(o,t){t.rasters=o.map(e=>typeof e=="number"||typeof e=="string"?e:e.toJSON())}clone(){return new Ke({operation:this.operation,processAsMultiband:this.processAsMultiband,rasters:K(this.rasters)})}};h([d({json:{write:!0}})],Ft.prototype,"operation",void 0),h([d({json:{write:!0}})],Ft.prototype,"rasters",void 0),h([Ae("rasters")],Ft.prototype,"writeRasters",null),h([d({json:{write:!0}})],Ft.prototype,"processAsMultiband",void 0),Ft=Ke=h([N("esri.layers.support.rasterFunctions.LocalFunctionArguments")],Ft);const Fi=Ft;let Jt=class extends z{constructor(){super(...arguments),this.functionName="Local",this.functionArguments=null,this.rasterArgumentNames=["rasters"]}_bindSourceRasters(){const{sourceRasterInfos:t}=this,e=t[0],{bandCount:s}=e,{processAsMultiband:r}=this.functionArguments;if(t.some(l=>l.bandCount!==s))return{success:!1,supportsGPU:!1,error:"local-function: input rasters do not have same band count"};const{operation:n,rasters:a}=this.functionArguments,i=ws[n];if(!(i===999||a.length===i||a.length<=1&&i===1))return{success:!1,supportsGPU:!1,error:`local-function: the length of functionArguments.rasters does not match operation's requirement: ${i}`};const u=e.clone();return u.bandCount=i!==999||r?s:1,this._removeStatsHistColormapVAT(u),this._updateStatistics(u),this._updatePixelType(u),this.rasterInfo=u,{success:!0,supportsGPU:u.bandCount===1&&i<=3}}_processPixels(t){const{pixelBlocks:e}=t;return e==null||e.some(s=>s==null)?null:ln(e,this.functionArguments.operation,{processAsMultiband:this.functionArguments.processAsMultiband,outputPixelType:this.outputPixelType??void 0})}_getWebGLParameters(){const{operation:t}=this.functionArguments,e=ws[t],s=Object.keys(ys).find(u=>ys[u]===t)?.toLowerCase()??"undefined",r=this.outputPixelType??"f32";let[n,a]=dt(r);const i=W(r);return i&&(n-=1e-4,a+=1e-4),{imageCount:e,operationName:s,domainRange:[n,a],isOutputRounded:i}}_updateStatistics(t){const e=this.sourceRasterInfos[0],{operation:s}=this.functionArguments,r=xs(s)?.domain;if(r){t.statistics=[];for(let n=0;n<t.bandCount;n++)t.statistics[n]={min:r[0],max:r[1],avg:(r[0]+r[1])/2,stddev:(r[0]+r[1])/10}}else s===45&&e.statistics?.length&&(t.statistics=e.statistics.map(n=>({min:-n.max,max:-n.min,avg:n.avg!=null?-n.avg:void 0,stddev:n.stddev!=null?-n.stddev:void 0})))}_updatePixelType(t){const{statistics:e,pixelType:s}=this.sourceRasterInfos[0],{operation:r}=this.functionArguments,{domain:n,isInteger:a}=xs(r)??{domain:null,isInteger:!1};let i="f32";if(n&&a)i=Re(n[0],n[1]);else if(r===30){const u=e?.[0];i=u?Re(u.min,u.max):W(s)?s:"s32"}else if(r===45&&W(s)){const u=e?.map(({max:m})=>-m),l=e?.map(({min:m})=>-m),c=u?.length?Math.min(...u):null,p=l?.length?Math.min(...l):null;i=c!=null&&p!=null?Re(c,p):s.startsWith("s")?s.replace("s","u"):s==="u1"||s==="u2"||s==="u4"?"s8":s==="u8"?"s16":"s32"}t.pixelType=this.outputPixelType=this._getOutputPixelType(i)}};h([d({json:{write:!0,name:"rasterFunction"}})],Jt.prototype,"functionName",void 0),h([d({type:Fi,json:{write:!0,name:"rasterFunctionArguments"}})],Jt.prototype,"functionArguments",void 0),h([d()],Jt.prototype,"rasterArgumentNames",void 0),Jt=h([N("esri.layers.support.rasterFunctions.LocalFunction")],Jt);const Ii=Jt;var Xe;let It=Xe=class extends O{constructor(){super(...arguments),this.includedRanges=null,this.noDataValues=null,this.noDataInterpretation=0}get normalizedNoDataValues(){const{noDataValues:o}=this;if(!o?.length)return null;let t=!1;const e=o.map(s=>{if(typeof s=="number")return t=!0,[s];if(typeof s=="string"){const r=s.trim().split(" ").filter(n=>n.trim()!=="").map(n=>Number(n));return t=t||r.length>0,r.length===0?null:r}return null});return t?e:null}clone(){return new Xe({includedRanges:this.includedRanges?.slice()??[],noDataValues:this.noDataValues?.slice()??[],noDataInterpretation:this.noDataInterpretation})}};h([d({json:{write:!0}})],It.prototype,"includedRanges",void 0),h([d({json:{write:!0}})],It.prototype,"noDataValues",void 0),h([d()],It.prototype,"normalizedNoDataValues",null),h([d({json:{write:!0}})],It.prototype,"noDataInterpretation",void 0),It=Xe=h([N("esri.layers.support.rasterFunctions.MaskFunctionArguments")],It);const ki=It;let kt=class extends z{constructor(){super(...arguments),this.functionName="Mask",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const t=this.sourceRasterInfos[0].clone(),{pixelType:e}=t;this.outputPixelType=this._getOutputPixelType(e),t.pixelType=this.outputPixelType,this.rasterInfo=t;const{includedRanges:s,normalizedNoDataValues:r}=this.functionArguments;if(!s?.length&&!r?.length)return{success:!1,supportsGPU:!1,error:"missing includedRanges or noDataValues argument"};let n=[];for(let i=0;i<t.bandCount;i++){const u=Bn(e,s?.slice(2*i,2*i+2),r?.[i]);if(u==null){n=null;break}n.push(u)}this.lookups=n;const a=r!=null&&r.every(i=>i?.length===r[0]?.length);return{success:!0,supportsGPU:(!s||s.length<=2*Qt)&&(!r||a&&r[0].length<=Qt)}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return null;const{outputPixelType:s,lookups:r}=this,{includedRanges:n,noDataInterpretation:a,normalizedNoDataValues:i}=this.functionArguments;return jn(e,{includedRanges:n,noDataValues:i,outputPixelType:s,matchAll:a===1,lookups:r})}_getWebGLParameters(){const{includedRanges:t,normalizedNoDataValues:e}=this.functionArguments,s=new Float32Array(Qt);s.fill(pe),e?.[0]?.length&&s.set(e[0]);const r=new Float32Array(6);for(let n=0;n<r.length;n+=2)r[n]=t?.[n]??-pe,r[n+1]=t?.[n+1]??pe;return t?.length&&r.set(t),{bandCount:this.sourceRasterInfos[0].bandCount,noDataValues:s,includedRanges:r}}};h([d({json:{write:!0,name:"rasterFunction"}})],kt.prototype,"functionName",void 0),h([d({type:ki,json:{write:!0,name:"rasterFunctionArguments"}})],kt.prototype,"functionArguments",void 0),h([d()],kt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],kt.prototype,"lookups",void 0),kt=h([N("esri.layers.support.rasterFunctions.MaskFunction")],kt);const _i=kt;var Ye;let Kt=Ye=class extends O{constructor(){super(...arguments),this.visibleBandID=0,this.infraredBandID=1,this.scientificOutput=!1}clone(){const{visibleBandID:o,infraredBandID:t,scientificOutput:e}=this;return new Ye({visibleBandID:o,infraredBandID:t,scientificOutput:e})}};h([d({json:{write:!0}})],Kt.prototype,"visibleBandID",void 0),h([d({json:{write:!0}})],Kt.prototype,"infraredBandID",void 0),h([d({json:{write:!0}})],Kt.prototype,"scientificOutput",void 0),Kt=Ye=h([N("esri.layers.support.rasterFunctions.NDVIFunctionArguments")],Kt);const Mi=Kt;let Xt=class extends z{constructor(){super(...arguments),this.functionName="NDVI",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{scientificOutput:t,visibleBandID:e,infraredBandID:s}=this.functionArguments;this.outputPixelType=this._getOutputPixelType(t?"f32":"u8");const r=this.sourceRasterInfos[0],n=Math.max(e,s);if(r.bandCount<2||n>=r.bandCount)return{success:!1,supportsGPU:!1,error:"ndvi-function: source raster has insufficient amount of raster bands"};if(e<0||s<0)return{success:!1,supportsGPU:!1,error:"ndvi-function: invalid visible or infrared band id"};const a=r.clone();a.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(a),a.bandCount=1,a.keyProperties={...a.keyProperties,BandProperties:void 0};const[i,u,l,c]=t?[-1,1,0,.1]:[0,200,100,10];return a.statistics=[{min:i,max:u,avg:l,stddev:c}],this.rasterInfo=a,{success:!0,supportsGPU:!0}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return null;let{visibleBandID:s,infraredBandID:r,scientificOutput:n}=this.functionArguments;if(this.rasterInfo.storageInfo.isBsqTile){const{rawInputBandIds:a}=this;r=a.indexOf(r),s=a.indexOf(s)}return Xr(e,s,r,!n)}_getWebGLParameters(){const{visibleBandID:t,infraredBandID:e,scientificOutput:s}=this.functionArguments,r=this.isInputBandIdsSwizzled?[0,1,2]:[e,t,0];return{bandIndexMat3:U(r),scaled:!s}}_getInputBandIds(t){const{visibleBandID:e,infraredBandID:s}=this.functionArguments;return[s,e,0].map(r=>t[r])}_swizzleBandIds(t){const{visibleBandID:e,infraredBandID:s}=this.functionArguments,r=[e,s].map(n=>t.indexOf(n));return r[2]=r[1],this.isInputBandIdsSwizzled=!0,this.swizzledBandSelection=r,!1}};h([d({json:{write:!0,name:"rasterFunction"}})],Xt.prototype,"functionName",void 0),h([d({type:Mi,json:{write:!0,name:"rasterFunctionArguments"}})],Xt.prototype,"functionArguments",void 0),h([d()],Xt.prototype,"rasterArgumentNames",void 0),Xt=h([N("esri.layers.support.rasterFunctions.NDVIFunction")],Xt);const Si=Xt;var Ze;let ut=Ze=class extends O{constructor(){super(...arguments),this.inputRanges=null,this.outputValues=null,this.noDataRanges=null,this.allowUnmatched=!1,this.isLastInputRangeInclusive=!1}clone(){return new Ze({inputRanges:[...this.inputRanges],outputValues:[...this.outputValues],noDataRanges:[...this.noDataRanges],allowUnmatched:this.allowUnmatched,isLastInputRangeInclusive:this.isLastInputRangeInclusive})}};h([d({json:{write:!0}})],ut.prototype,"inputRanges",void 0),h([d({json:{write:!0}})],ut.prototype,"outputValues",void 0),h([d({json:{write:!0}})],ut.prototype,"noDataRanges",void 0),h([d({json:{write:!0}})],ut.prototype,"allowUnmatched",void 0),h([d({json:{write:!0}})],ut.prototype,"replacementValue",void 0),h([d({json:{write:!0}})],ut.prototype,"isLastInputRangeInclusive",void 0),ut=Ze=h([N("esri.layers.support.rasterFunctions.RemapFunctionArguments")],ut);const Ci=ut;let _t=class extends z{constructor(){super(...arguments),this.functionName="Remap",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null}_bindSourceRasters(){const o=this.sourceRasterInfos[0].clone(),{pixelType:t}=o;o.bandCount=1;const{statistics:e}=o;this._removeStatsHistColormapVAT(o);const{allowUnmatched:s,replacementValue:r,outputValues:n,inputRanges:a,noDataRanges:i,isLastInputRangeInclusive:u}=this.functionArguments,l=this.outputPixelType==="unknown"||this.outputPixelType==null;if(this.outputPixelType=this._getOutputPixelType(t),n?.length){const c=e?.[0];if(s&&r==null){let p=c?.min??n[0],m=c?.max??n[0];p=Math.min.apply(null,[...n,p]),m=Math.max.apply(null,[...n,m]),o.statistics=[{min:p,max:m,avg:c?.avg??0,stddev:c?.stddev??-1}]}else{let p=n[0],m=p;for(let f=0;f<n.length;f++)p=p>n[f]?n[f]:p,m=m>n[f]?m:n[f];s&&r!=null&&(p=Math.min(p,r),m=Math.max(m,r)),o.statistics=[{min:p,max:m,avg:c?.avg??0,stddev:c?.stddev??-1}]}if(l){const{min:p,max:m}=o.statistics[0],f=["u8","s8","u16","s16","u32","s32","f32"],g=f.find(x=>{const[y,v]=dt(x);return p>=y&&m<=v})??"f64";n.some(x=>Math.floor(x)!==x)?this.outputPixelType=g==="f64"?"f64":"f32":this.outputPixelType=s&&r==null&&f.indexOf(t)>f.indexOf(g)?t:g}}return o.pixelType=this.outputPixelType,this.rasterInfo=o,this.lookup=s?null:Gn({srcPixelType:t,inputRanges:a,outputValues:n,noDataRanges:i,allowUnmatched:s,isLastInputRangeInclusive:u,outputPixelType:this.outputPixelType}),{success:!0,supportsGPU:(!n||n.length<=Qt)&&(!i||i.length<=Qt)}}_processPixels(o){const t=o.pixelBlocks?.[0];if(t==null)return null;const{lookup:e,outputPixelType:s}=this;if(e){const c=us(t,{lut:[e.lut],offset:e.offset,outputPixelType:s});return c!=null&&e.mask&&(c.mask=zn(t.pixels[0],t.mask,e.mask,e.offset,"u8")),c}const{inputRanges:r,outputValues:n,noDataRanges:a,allowUnmatched:i,isLastInputRangeInclusive:u,replacementValue:l}=this.functionArguments;return En(t,{inputRanges:r,outputValues:n,noDataRanges:a,outputPixelType:s,allowUnmatched:i,isLastInputRangeInclusive:u,replacementValue:l})}_getWebGLParameters(){const{allowUnmatched:o,noDataRanges:t,isLastInputRangeInclusive:e}=this.functionArguments,s=this.functionArguments.inputRanges??[],r=this.functionArguments.outputValues??[],n=On(s,r,e),a=new Float32Array(2*Qt);return a.fill(pe),t?.length&&a.set(t),{allowUnmatched:o,rangeMaps:n,noDataRanges:a,clampRange:dt(this.outputPixelType),replacementValue:this.functionArguments.replacementValue}}};h([d({json:{write:!0,name:"rasterFunction"}})],_t.prototype,"functionName",void 0),h([d({type:Ci,json:{write:!0,name:"rasterFunctionArguments"}})],_t.prototype,"functionArguments",void 0),h([d()],_t.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],_t.prototype,"lookup",void 0),_t=h([N("esri.layers.support.rasterFunctions.RemapFunction")],_t);const Bi=_t;var Qe;let Yt=Qe=class extends fn{readColorRamp(o){if(typeof o=="string"){const t=jt.jsonValues.find(e=>e.toLowerCase()===o.toLowerCase());return t?Zs(jt.fromJSON(t)):null}return"toJSON"in o?o.toJSON():o}clone(){return new Qe({hillshadeType:this.hillshadeType,altitude:this.altitude,azimuth:this.azimuth,zFactor:this.zFactor,slopeType:this.slopeType,pixelSizeFactor:this.pixelSizeFactor,pixelSizePower:this.pixelSizePower,removeEdgeEffect:this.removeEdgeEffect,colorRamp:this.colorRamp,colormap:this.colormap,raster:this.raster})}};h([d({json:{write:!0}})],Yt.prototype,"colorRamp",void 0),h([ie("colorRamp")],Yt.prototype,"readColorRamp",null),h([d({type:[[Number]],json:{write:!0}})],Yt.prototype,"colormap",void 0),Yt=Qe=h([N("esri.layers.support.rasterFunctions.ShadedReliefFunctionArguments")],Yt);const ji=Yt;let pt=class extends z{constructor(){super(...arguments),this.functionName="ShadedRelief",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){const o=this.sourceRasterInfos[0];if(o.bandCount>1)return{success:!1,supportsGPU:!1,error:"shadedrelief-function: source data must be single band"};let{colorRamp:t,colormap:e}=this.functionArguments;if(!t&&!e?.length)return{success:!1,supportsGPU:!1,error:"shadedrelief-function: a color ramp argument must be specified"};this.outputPixelType=this._getOutputPixelType("u8");const s=o.clone();this._removeStatsHistColormapVAT(s),s.pixelType=this.outputPixelType,s.bandCount=3,s.statistics=[{min:0,max:255,avg:60,stddev:10},{min:0,max:255,avg:60,stddev:10},{min:0,max:255,avg:60,stddev:10}],this.rasterInfo=s,this.isGCS=s.spatialReference?.isGeographic??!1,e?.length||(e=Me(t,{interpolateAlpha:!0}));const{indexedColormap:r,offset:n}=Qs({colormap:e});if(!r?.length)return{success:!1,supportsGPU:!1,error:"shadedrelief-function: a valid colorramp is required"};const a=Dn(r);return this.lookup={indexedColormap:r,offset:n,hsvMap:a},{success:!0,supportsGPU:tn(r)}}_processPixels(o){const t=o.pixelBlocks?.[0];if(!t||!this.lookup)return null;let e=o.primaryPixelSizes?.[0];if(e==null){const{extent:a}=o;e=a?{x:a.width/t.width,y:a.height/t.height}:{x:1,y:1}}const s=de(this.functionArguments,e,this.isGCS),r=en(t,s),n=this.sourceRasterInfos[0].statistics?.[0]??{min:0,max:8e3};return Vn(r,t,this.lookup.hsvMap,n),r.pixelType=this.outputPixelType,r}_getWebGLParameters(){const o=de(this.functionArguments,{x:1,y:1},this.isGCS),t=sn(o),{slopeType:e,zFactor:s,pixelSizeFactor:r,pixelSizePower:n}=this.functionArguments,a=e==="scaled",{indexedColormap:i,offset:u}=this.lookup,l=this.sourceRasterInfos[0].statistics?.[0],c=W(this.outputPixelType);return{...t,indexedColormap:i,offset:u,zFactor:s,gcsFactor:this.isGCS?ae:1,pixelSizeFactor:a?r:0,pixelSizePower:a?n:0,minValue:l?.min??0,maxValue:l?.max??8e3,isOutputRounded:c}}};h([d({json:{write:!0,name:"rasterFunction"}})],pt.prototype,"functionName",void 0),h([d({type:ji,json:{write:!0,name:"rasterFunctionArguments"}})],pt.prototype,"functionArguments",void 0),h([d()],pt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],pt.prototype,"isGCS",void 0),h([d({json:{write:!0}})],pt.prototype,"lookup",void 0),pt=h([N("esri.layers.support.rasterFunctions.ShadedReliefFunction")],pt);const Gi=pt;var ts;const zi=new ot({1:"degree",2:"percent-rise",3:"adjusted"},{useNumericKeys:!0});let ht=ts=class extends O{constructor(){super(...arguments),this.slopeType="degree",this.zFactor=1,this.pixelSizePower=.664,this.pixelSizeFactor=.024,this.removeEdgeEffect=!1}clone(){return new ts({slopeType:this.slopeType,zFactor:this.zFactor,pixelSizePower:this.pixelSizePower,pixelSizeFactor:this.pixelSizeFactor,removeEdgeEffect:this.removeEdgeEffect,raster:this.raster})}};h([rt(zi)],ht.prototype,"slopeType",void 0),h([d({type:Number,json:{write:!0}})],ht.prototype,"zFactor",void 0),h([d({type:Number,json:{name:"psPower",write:!0}})],ht.prototype,"pixelSizePower",void 0),h([d({type:Number,json:{name:"psZFactor",write:!0}})],ht.prototype,"pixelSizeFactor",void 0),h([d({type:Boolean,json:{write:!0}})],ht.prototype,"removeEdgeEffect",void 0),ht=ts=h([N("esri.layers.support.rasterFunctions.SlopeFunctionArguments")],ht);const Ei=ht;let Mt=class extends z{constructor(){super(...arguments),this.functionName="Slope",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){this.outputPixelType=this._getOutputPixelType("f32");const t=this.sourceRasterInfos[0].clone();return t.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(t),t.statistics=this.functionArguments.slopeType!=="percent-rise"?[{min:0,max:90,avg:1,stddev:1}]:null,t.bandCount=1,this.rasterInfo=t,this.isGCS=t.spatialReference?.isGeographic??!1,{success:!0,supportsGPU:!0}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return null;const{zFactor:s,slopeType:r,pixelSizePower:n,pixelSizeFactor:a}=this.functionArguments,{isGCS:i}=this,{extent:u,primaryPixelSizes:l}=t,c=l?.[0],p=c??(u?{x:u.width/e.width,y:u.height/e.height}:{x:1,y:1});return Un(e,{zFactor:s,slopeType:r,pixelSizePower:n,pixelSizeFactor:a,isGCS:i,resolution:p})}_getWebGLParameters(){const{zFactor:t,slopeType:e,pixelSizeFactor:s,pixelSizePower:r}=this.functionArguments;return{zFactor:this.isGCS&&t>=1?t*ae:t,slopeType:e,pixelSizeFactor:s??0,pixelSizePower:r??0,isOutputRounded:W(this.outputPixelType)}}};h([d({json:{write:!0,name:"rasterFunction"}})],Mt.prototype,"functionName",void 0),h([d({type:Ei,json:{write:!0,name:"rasterFunctionArguments"}})],Mt.prototype,"functionArguments",void 0),h([d()],Mt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],Mt.prototype,"isGCS",void 0),Mt=h([N("esri.layers.support.rasterFunctions.SlopeFunction")],Mt);const Oi=Mt,Ls=new ot({1:"min",2:"max",3:"mean",4:"stddev",5:"median",6:"majority",7:"minority"},{useNumericKeys:!0});function Di(o,t){const{fillNoDataOnly:e}=t,{band:s,width:r,height:n,mask:a,outBand:i}=o;if(e&&!a)return void i.set(s);const{statisticsType:u,kernelRows:l,kernelCols:c}=t,p=u==="stddev",m=r*n,f=new Float64Array(m),g=new Float64Array(m),x=new Uint32Array(m);for(let P=0;P<n;P++){const $=P*r;let F=0,I=0,k=0;for(let _=0;_<c;_++)a&&!a[$+_]||(F+=s[$+_],p&&(I+=s[$+_]**2),k++);f[$]=F,g[$]=I,x[$]=k;for(let _=1;_<=r-c;_++){const C=$+_-1,q=C+c;a?(a[C]&&(k--,F-=s[C],p&&(I-=s[C]**2)),a[q]&&(k++,F+=s[q],p&&(I+=s[q]**2))):(F-=s[C],F+=s[q],p&&(I-=s[C]**2,I+=s[q]**2)),f[$+_]=F,x[$+_]=k,p&&(g[$+_]=I)}}const y=new Float64Array(m),v=new Float64Array(m),w=new Uint32Array(m),A=l*r;for(let P=0;P<=r-c;P++){let $=0,F=0,I=0;for(let k=0;k<l;k++){const _=k*r+P;$+=f[_],I+=x[_],p&&(F+=g[_])}y[P]=$,v[P]=F,w[P]=I;for(let k=1;k<=n-l;k++){const _=(k-1)*r+P,C=_+A;$-=f[_],$+=f[C],I-=x[_],I+=x[C],p&&(F-=g[_],F+=g[C]),y[k*r+P]=$,v[k*r+P]=F,w[k*r+P]=I}}const b=Math.floor(l/2),T=Math.floor(c/2);for(let P=b;P<n-b;P++){const $=P*r;for(let F=T;F<r-T;F++){const I=(P-b)*r+F-T,k=w[I];if(k===0||e&&(!a||a[$+F]))continue;const _=y[I]/k,C=p?Math.sqrt((v[I]-y[I]*_)/k):_;i[$+F]=C,a&&(a[$+F]=255)}}}function Vi(o,t){const{fillNoDataOnly:e}=t,{band:s,width:r,height:n,mask:a,outBand:i}=o;if(e&&!a)return void i.set(s);const{kernelRows:u,kernelCols:l,statisticsType:c}=t,p=Math.floor(u/2),m=Math.floor(l/2),f=c==="min",g=i.slice(),x=new Uint32Array(r*n);for(let y=p;y<n-p;y++){const v=y*r;for(let w=m;w<r-m;w++){let A=f?Number.MAX_VALUE:-Number.MAX_VALUE,b=0;for(let T=0;T<u;T++)for(let P=0;P<l;P++){const $=v+w+(T-p)*r+P-m;a&&!a[$]||(A=f?Math.min(A,s[$]):Math.max(A,s[$]),b++)}a?(g[v+w]=b===0?0:A,x[v+w]=b):i[v+w]=b===0?0:A}}if(a)for(let y=p;y<n-p;y++){const v=y*r;for(let w=m;w<r-m;w++)if(x[v+w]){if(e&&a[v+w])continue;i[v+w]=g[v+w],a[v+w]=255}}}function Ui(o,t){const{fillNoDataOnly:e}=t,{band:s,width:r,height:n,mask:a,outBand:i}=o;if(e&&!a)return void i.set(s);const{kernelRows:u,kernelCols:l}=t,c=Math.floor(u/2),p=Math.floor(l/2),m=i.slice(),f=new Uint32Array(r*n);for(let g=c;g<n-c;g++){const x=g*r;for(let y=p;y<r-p;y++){if(e&&a?.[x+y])continue;const v=[];for(let w=0;w<u;w++)for(let A=0;A<l;A++){const b=x+y+(w-c)*r+A-p;a&&!a[b]||v.push(s[b])}v.length&&(v.sort((w,A)=>w-A),a?(m[x+y]=v[Math.floor((v.length-1)/2)],f[x+y]=v.length):i[x+y]=v[Math.floor((v.length-1)/2)])}}if(a)for(let g=c;g<n-c;g++){const x=g*r;for(let y=p;y<r-p;y++)if(f[x+y]){if(e&&a[x+y])continue;i[x+y]=m[x+y],a[x+y]=255}}}function Li(o,t){const{fillNoDataOnly:e}=t,{band:s,width:r,height:n,mask:a,outBand:i}=o;if(e&&!a)return void i.set(s);const{kernelRows:u,kernelCols:l}=t,c=Math.floor(u/2),p=Math.floor(l/2),m=t.statisticsType==="majority",f=u*l,g=i.slice(),x=new Uint32Array(r*n);for(let y=c;y<n-c;y++){const v=y*r;for(let w=p;w<r-p;w++){if(e&&a?.[v+w])continue;const A=new Map;for(let $=0;$<u;$++)for(let F=0;F<l;F++){const I=v+w+($-c)*r+F-p;if(a&&!a[I])continue;const k=s[I];A.set(k,A.has(k)?A.get(k)+1:1)}if(A.size===0)continue;let b=0,T=0,P=m?0:f+1;for(const $ of A.keys())T=A.get($),m===T>P&&(P=T,b=$);a?(g[v+w]=b,x[v+w]=A.size):i[v+w]=b}}if(a)for(let y=c;y<n-c;y++){const v=y*r;for(let w=p;w<r-p;w++)if(x[v+w]){if(e&&a[v+w])continue;i[v+w]=g[v+w],a[v+w]=255}}}function Wi(o,t){const{mask:e}=o,{fillNoDataOnly:s}=t;if(s&&!e)return o;const{pixels:r,width:n,height:a,bandMasks:i,pixelType:u}=o,l=r.length,c=n*a,p=[],{kernelRows:m,kernelCols:f,statisticsType:g,mirrorEdges:x}=t;if(s&&!e)return o;const y=t.outputPixelType??u,v=[];for(let b=0;b<l;b++){const T=r[b],P=R.createEmptyBand(y,c);s&&P.set(T);const $=i?.[b]??e,F=$?.slice()??null,I={band:T,width:n,height:a,mask:F,outBand:P};switch(g){case"min":case"max":Vi(I,t);break;case"mean":case"stddev":Di(I,t);break;case"median":Ui(I,t);break;case"majority":case"minority":Li(I,t)}x&&!s&&ms(P,n,a,m,f),p.push(P),F&&v.push(F)}let w=v[0]??e;v.length!==l&&(v.length=0),l>1&&i?.length&&(w=R.combineBandMasks(i));const A=new R({pixelType:y,width:n,height:a,pixels:p,bandMasks:i&&v.length?v:null,mask:w});return A.updateStatistics(),A}var es;let St=es=class extends O{constructor(){super(...arguments),this.rows=3,this.cols=3,this.fillNoDataOnly=!1,this.statisticsType="min"}clone(){return new es({rows:this.rows,cols:this.cols,fillNoDataOnly:this.fillNoDataOnly,statisticsType:this.statisticsType,raster:K(this.raster)})}};h([d({json:{write:!0,read:{source:["kernelRows","rows"],reader:(o,t)=>Number(o??t?.kernelRows??3)}}})],St.prototype,"rows",void 0),h([d({json:{write:!0,read:{source:["kernelCols","cols"],reader:(o,t)=>Number(o??t?.kernelCols??3)}}})],St.prototype,"cols",void 0),h([d({json:{write:!0}})],St.prototype,"fillNoDataOnly",void 0),h([d({json:{read:{source:["statisticsType","type"],reader:(o,t)=>Ls.fromJSON(t?.statisticsType??t?.type)??"min"},write:{target:"type"}}}),rt(Ls)],St.prototype,"statisticsType",void 0),St=es=h([N("esri.layers.support.rasterFunctions.StatisticsFunctionArguments")],St);const qi=St;let Zt=class extends z{constructor(){super(...arguments),this.functionName="Statistics",this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{type:t}=this.functionArguments.toJSON();if(t<1||t>7)return{success:!1,supportsGPU:!1,error:`statistics-function: the given statistics type is not supported ${t}`};const e=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType(e.pixelType);const s=e.clone();s.pixelType=this.outputPixelType;const{statisticsType:r}=this.functionArguments;return r==="stddev"&&this._removeStatsHistColormapVAT(s),this.rasterInfo=s,{success:!0,supportsGPU:s.bandCount<=3&&t<5}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return e;const{statisticsType:s,rows:r,cols:n,fillNoDataOnly:a}=this.functionArguments;return Wi(e,{kernelRows:r,kernelCols:n,fillNoDataOnly:a,outputPixelType:this.outputPixelType,statisticsType:s,mirrorEdges:!0})}_getWebGLParameters(){const{rows:t,cols:e,statisticsType:s,fillNoDataOnly:r}=this.functionArguments;return{fillNoDataOnly:r,kernelRows:t,kernelCols:e,statisticsType:s,clampRange:dt(this.outputPixelType)}}};h([d({json:{write:!0,name:"rasterFunction"}})],Zt.prototype,"functionName",void 0),h([d({type:qi,json:{write:!0,name:"rasterFunctionArguments"}})],Zt.prototype,"functionArguments",void 0),h([d()],Zt.prototype,"rasterArgumentNames",void 0),Zt=h([N("esri.layers.support.rasterFunctions.StatisticsFunction")],Zt);const Hi=Zt;var ss;let Ct=ss=class extends O{constructor(){super(...arguments),this.statistics=null,this.histograms=null}readStatistics(o,t){if(!o?.length)return null;const e=[];return o.forEach(s=>{const r={min:s.min,max:s.max,avg:s.avg??s.mean,stddev:s.stddev??s.standardDeviation};e.push(r)}),e}writeStatistics(o,t,e){if(!o?.length)return;const s=[];o.forEach(r=>{const n={...r,mean:r.avg,standardDeviation:r.stddev};delete n.avg,delete n.stddev,s.push(n)}),t[e]=s}clone(){return new ss({statistics:K(this.statistics),histograms:K(this.histograms)})}};h([d({json:{write:!0}})],Ct.prototype,"statistics",void 0),h([ie("statistics")],Ct.prototype,"readStatistics",null),h([Ae("statistics")],Ct.prototype,"writeStatistics",null),h([d({json:{write:!0}})],Ct.prototype,"histograms",void 0),Ct=ss=h([N("esri.layers.support.rasterFunctions.StatisticsHistogramFunctionArguments")],Ct);const Ji=Ct;let mt=class extends z{constructor(){super(...arguments),this.functionName="StatisticsHistogram",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const t=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType("u8");const e=t.clone(),{statistics:s,histograms:r}=this.functionArguments;return r&&(e.histograms=r),s&&(e.statistics=s),this.rasterInfo=e,{success:!0,supportsGPU:!0}}_processPixels(t){return t.pixelBlocks?.[0]}};h([d({json:{write:!0,name:"rasterFunction"}})],mt.prototype,"functionName",void 0),h([d({type:Ji,json:{write:!0,name:"rasterFunctionArguments"}})],mt.prototype,"functionArguments",void 0),h([d()],mt.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],mt.prototype,"indexedColormap",void 0),h([d()],mt.prototype,"isNoopProcess",void 0),mt=h([N("esri.layers.support.rasterFunctions.StatisticsHistogramFunction")],mt);const Ki=mt;var ns;const Xi=new ot({0:"none",3:"standard-deviation",4:"histogram-equalization",5:"min-max",6:"percent-clip",9:"sigmoid"},{useNumericKeys:!0});let L=ns=class extends O{constructor(){super(...arguments),this.computeGamma=!1,this.dynamicRangeAdjustment=!1,this.gamma=[],this.histograms=null,this.statistics=null,this.stretchType="none",this.useGamma=!1}writeStatistics(o,t,e){o?.length&&(Array.isArray(o[0])||(o=o.map(s=>[s.min,s.max,s.avg,s.stddev])),t[e]=o)}clone(){return new ns({stretchType:this.stretchType,outputMin:this.outputMin,outputMax:this.outputMax,useGamma:this.useGamma,computeGamma:this.computeGamma,statistics:K(this.statistics),gamma:K(this.gamma),sigmoidStrengthLevel:this.sigmoidStrengthLevel,numberOfStandardDeviations:this.numberOfStandardDeviations,minPercent:this.minPercent,maxPercent:this.maxPercent,histograms:K(this.histograms),dynamicRangeAdjustment:this.dynamicRangeAdjustment,raster:this.raster})}};h([d({type:Boolean,json:{write:!0}})],L.prototype,"computeGamma",void 0),h([d({type:Boolean,json:{name:"dra",write:!0}})],L.prototype,"dynamicRangeAdjustment",void 0),h([d({type:[Number],json:{write:!0}})],L.prototype,"gamma",void 0),h([d()],L.prototype,"histograms",void 0),h([d({type:Number,json:{write:!0}})],L.prototype,"maxPercent",void 0),h([d({type:Number,json:{write:!0}})],L.prototype,"minPercent",void 0),h([d({type:Number,json:{write:!0}})],L.prototype,"numberOfStandardDeviations",void 0),h([d({type:Number,json:{name:"max",write:!0}})],L.prototype,"outputMax",void 0),h([d({type:Number,json:{name:"min",write:!0}})],L.prototype,"outputMin",void 0),h([d({type:Number,json:{write:!0}})],L.prototype,"sigmoidStrengthLevel",void 0),h([d({json:{type:[[Number]],write:!0}})],L.prototype,"statistics",void 0),h([Ae("statistics")],L.prototype,"writeStatistics",null),h([rt(Xi)],L.prototype,"stretchType",void 0),h([d({type:Boolean,json:{write:!0}})],L.prototype,"useGamma",void 0),L=ns=h([N("esri.layers.support.rasterFunctions.StretchFunctionArguments")],L);const Yi=L;let ft=class extends z{constructor(){super(...arguments),this.functionName="Stretch",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null,this.cutOffs=null}_bindSourceRasters(){this.lookup=null,this.cutOffs=null;const t=this.sourceRasterInfos[0],{pixelType:e}=t,{functionArguments:s}=this,{dynamicRangeAdjustment:r,gamma:n,useGamma:a}=s;if(!r&&["u8","u16","s8","s16"].includes(e)){const c=$e(s.toJSON(),{rasterInfo:t}),p=W(this.outputPixelType)?"round":"float";this.lookup=Ln({pixelType:e,...c,gamma:a?n:null,rounding:p}),this.cutOffs=c}else r||(this.cutOffs=$e(s.toJSON(),{rasterInfo:t}));this.outputPixelType=this._getOutputPixelType(e);const i=t.clone();i.pixelType=this.outputPixelType,this._removeStatsHistColormapVAT(i),this.outputPixelType==="u8"&&(i.keyProperties.DataType="processed");const{outputMin:u=0,outputMax:l=255}=this.functionArguments;i.statistics=[];for(let c=0;c<i.bandCount;c++)i.statistics[c]={min:u,max:l};return this.rasterInfo=i,{success:!0,supportsGPU:!r}}_processPixels(t){const e=t.pixelBlocks?.[0];if(e==null)return e;const{lookup:s}=this;if(s)return us(e,{...s,outputPixelType:this.rasterInfo.pixelType});const{functionArguments:r}=this,n=this.cutOffs||$e(r.toJSON(),{rasterInfo:this.sourceRasterInfos[0],pixelBlock:e}),a=r.useGamma?r.gamma:null;return Wn(e,{...n,gamma:a,outputPixelType:this.outputPixelType})}_getWebGLParameters(){const{outputMin:t=0,outputMax:e=255,gamma:s,useGamma:r}=this.functionArguments,n=this.rasterInfo.bandCount>=2?3:1,a=r&&s?.length?qn(n,s):[1,1,1],{minCutOff:i,maxCutOff:u}=this.cutOffs??{minCutOff:[0,0,0],maxCutOff:[255,255,255]};i.length===1&&(i[1]=i[2]=i[0],u[1]=u[2]=u[0]);const l=u.map((f,g)=>(e-t)/(u[g]-i[g])),c=W(this.outputPixelType),p=r&&s?[s[0],s[1]??s[0],s[2]??s[0]]:[1,1,1],m=r?[a[0],a[1]??a[0],a[2]??a[0]]:[1,1,1];return{bandCount:n,minOutput:t,maxOutput:e,minCutOff:i,maxCutOff:u,factor:l,useGamma:r,gamma:p,gammaCorrection:m,stretchType:this.functionArguments.stretchType,isOutputRounded:c,type:"stretch"}}};h([d({json:{write:!0,name:"rasterFunction"}})],ft.prototype,"functionName",void 0),h([d({type:Yi,json:{write:!0,name:"rasterFunctionArguments"}})],ft.prototype,"functionArguments",void 0),h([d()],ft.prototype,"rasterArgumentNames",void 0),h([d({json:{write:!0}})],ft.prototype,"lookup",void 0),h([d({json:{write:!0}})],ft.prototype,"cutOffs",void 0),ft=h([N("esri.layers.support.rasterFunctions.StretchFunction")],ft);const Zi=ft;var rs;let fe=rs=class extends O{constructor(){super(...arguments),this.attributeTableAsRecordSet=null}clone(){return new rs({attributeTableAsRecordSet:K(this.attributeTableAsRecordSet)})}};h([d({json:{write:!0}})],fe.prototype,"attributeTableAsRecordSet",void 0),fe=rs=h([N("esri.layers.support.rasterFunctions.TableFunctionArguments")],fe);const Qi=fe;let Bt=class extends z{constructor(){super(...arguments),this.functionName="Table",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isNoopProcess=!0}_bindSourceRasters(){const o=this.sourceRasterInfos[0];if(o.bandCount>1||o.pixelType.startsWith("f"))return{success:!1,supportsGPU:!1,error:"table-function: Source data must be single band and integer pixel type."};const{attributeTableAsRecordSet:t}=this.functionArguments;if(!t)return{success:!1,supportsGPU:!1,error:"table-function: Missing attributeTableAsRecordSet argument."};this.outputPixelType=this._getOutputPixelType(o.pixelType);const e=o.clone();return e.pixelType=this.outputPixelType,e.bandCount=1,e.dataType!=="thematic"&&(e.keyProperties=e.keyProperties?{...e.keyProperties,DataType:"thematic"}:{DataType:"thematic"}),this.rasterInfo=e,{success:!0,supportsGPU:!0}}_processPixels(o){return o.pixelBlocks?.[0]}};h([d({json:{write:!0,name:"rasterFunction"}})],Bt.prototype,"functionName",void 0),h([d({type:Qi,json:{write:!0,name:"rasterFunctionArguments"}})],Bt.prototype,"functionArguments",void 0),h([d()],Bt.prototype,"rasterArgumentNames",void 0),h([d()],Bt.prototype,"isNoopProcess",void 0),Bt=h([N("esri.layers.support.rasterFunctions.TableFunction")],Bt);const ta=Bt,B=new Map;function ea(o,t){const{rasterFunctionArguments:e}=o;e&&(e.rasters||[e.raster,e.raster2]).forEach(s=>{s&&typeof s!="number"&&(typeof s=="string"?s.startsWith("http")&&(t.includes(s)||t.push(s)):"rasterFunctionArguments"in s&&ea(s,t))})}function Wa(o,t){t=t??{};try{if("function"in(o=K(o))&&"arguments"in o&&o.arguments){const e=yn(o,new Map,t);if(as(e),!e.renderingRule)throw new Et("raster-function-helper","Unsupported raster function json.");o=e.renderingRule}if("rasterFunction"in o){const e=dn(o=os(o),t);return e.isRoot=!0,e}}catch{}throw new Et("raster-function-helper","unsupported raster function json.")}function sa(o,t){return t[0]==="rasters"&&Array.isArray(o.rasters)?o.rasters:t.map(e=>o[e])}function Ws(o){return!!(o&&typeof o=="object"&&o.rasterFunction&&o.rasterFunctionArguments)}function os(o){const{rasterFunction:t,rasterFunctionArguments:e}=o,s={};for(const r in e){let n=e[r];const a=r.toLowerCase();if(a==="rasters"&&Array.isArray(n))s.rasters=n.map(i=>Ws(i)?os(i):i);else switch(Ws(n)&&(n=os(n)),a){case"dra":s.dra=n;break;case"pspower":s.psPower=n;break;case"pszfactor":s.psZFactor=n;break;case"bandids":s.bandIds=n;break;default:s[r[0].toLowerCase()+r.slice(1)]=n}}return t!=="Local"||s.rasters?.length||(s.rasters=["$$"]),{...o,rasterFunctionArguments:s}}function dn(o,t){const{rasterFunction:e,rasterFunctionArguments:s}=o,r=o.outputPixelType?.toLowerCase();if(e==null||!B.has(e))throw new Et("raster-function-helper",`unsupported raster function: ${e}`);const n=B.get(e),a=(typeof n.ctor=="function"?n.ctor:n.ctor.default).fromJSON({...o,outputPixelType:r}),{rasterArgumentNames:i}=a,u=[],l=sa(s,i),c=i[0]==="rasters"||i.length>1,p=[];for(let m=0;m<l.length;m++){const f=l[m];let g;f==null||typeof f=="string"&&f.startsWith("$")?u.push(t?.raster):typeof f=="string"?t[f]&&u.push(t[f]):typeof f!="number"&&"rasterFunction"in f&&(g=dn(f,t),c||(a.functionArguments[i[m]]=g),u.push(g)),c&&p.push(g??f)}if(c&&(i[0]==="rasters"?a.functionArguments.rasters=p:i.forEach((m,f)=>{a.functionArguments[m]=p[f]})),t){a.sourceRasters=u;const m=t.raster?.url;m&&(a.mainPrimaryRasterId=m)}return a}function gn(o,t){if(o&&t)for(const e in o){const s=o[e];s&&typeof s=="object"&&"type"in s&&(s.type==="RasterFunctionTemplate"?gn(s.arguments,t):s.type==="RasterFunctionVariable"&&t[s.name]!=null&&(s.value=t[s.name]))}}function is(o,t){if(!o||typeof o!="object")return o;const{value:e}=o;if(!e||typeof e!="object")return o.isDataset?"$$":e;if(Array.isArray(e))return e.length===0?[]:e.map(r=>r&&typeof r=="object"&&r.type==="RasterFunctionVariable"?is(r,t):r);if("value"in e&&["number","string","boolean"].includes(typeof e.value))return e.value;if(o.isDataset&&e.type!=="Scalar")return"$$";if(!("type"in e))return e;let s=e;switch(e.type){case"Scalar":s=e.value;break;case"AlgorithmicColorRamp":s=qs(e);break;case"MultiPartColorRamp":s={type:"multipart",colorRamps:e.ArrayOfColorRamp.map(qs)};break;case"ArgumentArray":if(e.elements?.length&&e.elements[0].type!=="RasterStatistics"){const r=[];for(let n=0;n<e.elements.length;n++){const a=e.elements[n],{type:i}=a;if(i)if(i==="RasterFunctionTemplate"){const{renderingRule:u}=yn(a,t);r.push(u),a._object_id!=null&&t.set(a._object_id,u)}else{if(i!=="RasterFunctionVariable")throw new Et("raster-function-helper","unsupported raster function json.");{const u=is(a,t);r.push(u),a._object_id!=null&&t.set(a._object_id,u)}}else r.push(a)}s=r}else s=e.elements}return e._object_id!=null&&t.set(e._object_id,s),s}function qs(o){const t=o.algorithm??"esriHSVAlgorithm";let{FromColor:e,ToColor:s}=o;if(!Array.isArray(e)){const{r,g:n,b:a}=ds({h:e.Hue,s:e.Saturation,v:e.Value});e=[r,n,a,e.AlphaValue]}if(!Array.isArray(s)){const{r,g:n,b:a}=ds({h:s.Hue,s:s.Saturation,v:s.Value});s=[r,n,a,s.AlphaValue]}return{type:"algorithmic",algorithm:t,fromColor:e,toColor:s}}function yn(o,t,e){e&&gn(o,e);const s={renderingRule:{},templates:t};return xn(o,s),s}function xn(o,t){if(!o||!t.renderingRule)return;const{renderingRule:e,templates:s}=t,{function:r,arguments:n,_object_id:a}=o;if(!r||!n)return;a!=null&&s.set(a,e),e.rasterFunction=r.type.replace("Function",""),e.outputPixelType=r.pixelType;const i={};e.rasterFunctionArguments=i;for(const u in n){if(u==="type"||u==="object_id"||u==="_object_ref_id")continue;const l=n[u];l&&typeof l=="object"&&"type"in l&&(l.type==="RasterFunctionTemplate"||l.type==="RasterFunctionVariable")?(l.type==="RasterFunctionVariable"?i[u]=is(l,s):(e.rasterFunctionArguments[u]={},xn(l,{renderingRule:e.rasterFunctionArguments[u],templates:s})),l._object_id!=null&&s.set(l._object_id,i[u])):i[u]=l}switch(i.DEM&&!i.Raster&&(i.Raster=i.DEM,delete i.DEM),e.rasterFunction){case"Stretch":na(i);break;case"Colormap":ra(i);break;case"Convolution":oa(i);break;case"Mask":ia(i)}}function as(o){const{renderingRule:t,templates:e}=o;if(typeof t!="object"||!t?.rasterFunctionArguments||!e.size)return;const{rasterFunctionArguments:s}=t;for(const r in s){const n=s[r],a=r==="_object_ref_id"?n:n&&typeof n=="object"&&"_object_ref_id"in n?n._object_ref_id:null;if(a!=null){if(!e.has(a))throw new Et("raster-function-helper",`unsupported raster function json. _object_ref_id: ${a} does not exist`);const i=e.get(a);r!=="_object_ref_id"?s[r]=i:i&&typeof i=="object"&&Object.assign(s,i);continue}n&&typeof n=="object"&&(n.rasterFunctionArguments&&as({renderingRule:n,templates:e}),Array.isArray(n)&&n.forEach((i,u)=>{if(i&&typeof i=="object")if(i._object_ref_id!=null){if(!e.has(i._object_ref_id))throw new Et("raster-function-helper",`unsupported raster function json. _object_ref_id: ${n} does not exist`);const l=e.get(a);l&&typeof l=="object"?Object.assign(i,l):n[u]=l}else as({renderingRule:i,templates:e})}))}}function na(o){o.Statistics?.length&&typeof o.Statistics=="object"&&(o.Statistics=o.Statistics.map(t=>[t.min,t.max,t.mean,t.standardDeviation])),o.NumberOfStandardDeviation!=null&&(o.NumberOfStandardDeviations=o.NumberOfStandardDeviation,delete o.NumberOfStandardDeviation)}function ra(o){o.ColorRamp?.type?.toLowerCase()==="randomcolorramp"&&(delete o.ColorRamp,o.ColormapName="Random"),o.ColorSchemeType===0&&delete o.ColorRamp}function oa(o){o.ConvolutionType!=null&&(o.Type=o.ConvolutionType,delete o.ConvolutionType)}function ia(o){o.NoDataValues?.length&&typeof o.NoDataValues[0]=="string"&&(o.NoDataValues=o.NoDataValues.filter(t=>t!=="").map(t=>Number(t)))}B.set("Arithmetic",{desc:"Arithmetic Function",ctor:Er,rasterArgumentNames:["rasters"]}),B.set("Aspect",{desc:"Aspect Function",ctor:Dr,rasterArgumentNames:["raster"]}),B.set("BandArithmetic",{desc:"Band Arithmetic Function",ctor:mo,rasterArgumentNames:["raster"]}),B.set("Colormap",{desc:"Colormap Function",ctor:Wo,rasterArgumentNames:["raster"]}),B.set("ColormapToRGB",{desc:"ColormapToRGB Function",ctor:Ho,rasterArgumentNames:["raster"]}),B.set("CompositeBand",{desc:"CompositeBand Function",ctor:Ko,rasterArgumentNames:["rasters"]}),B.set("ComputeChange",{desc:"ComputeChange Function",ctor:oi,rasterArgumentNames:["rasters"]}),B.set("Convolution",{desc:"Convolution Function",ctor:fi,rasterArgumentNames:["raster"]}),B.set("ContrastBrightness",{desc:"Contrast Brightness Function",ctor:ai,rasterArgumentNames:["raster"]}),B.set("ExtractBand",{desc:"ExtractBand Function",ctor:xi,rasterArgumentNames:["raster"]}),B.set("Curvature",{desc:"Curvature Function",ctor:gi,rasterArgumentNames:["raster"]}),B.set("Hillshade",{desc:"Hillshade Function",ctor:Ni,rasterArgumentNames:["raster"]}),B.set("ShadedRelief",{desc:"ShadedRelief Function",ctor:Gi,rasterArgumentNames:["raster"]}),B.set("Grayscale",{desc:"Grayscale Function",ctor:Pi,rasterArgumentNames:["raster"]}),B.set("Clip",{desc:"Clip Function",ctor:Bo,rasterArgumentNames:["raster"]}),B.set("Local",{desc:"Local Function",ctor:Ii,rasterArgumentNames:["rasters"]}),B.set("Mask",{desc:"Mask Function",ctor:_i,rasterArgumentNames:["raster"]}),B.set("NDVI",{desc:"NDVI Function",ctor:Si,rasterArgumentNames:["raster"]}),B.set("Remap",{desc:"Remap Function",ctor:Bi,rasterArgumentNames:["raster"]}),B.set("Slope",{desc:"Slope Function",ctor:Oi,rasterArgumentNames:["raster"]}),B.set("Statistics",{desc:"Focal Statistics Function",ctor:Hi,rasterArgumentNames:["raster"]}),B.set("StatisticsHistogram",{desc:"Statistics Histogram Function",ctor:Ki,rasterArgumentNames:["raster"]}),B.set("Stretch",{desc:"Stretch Function",ctor:Zi,rasterArgumentNames:["raster"]}),B.set("Table",{desc:"Attribute Table Function",ctor:ta,rasterArgumentNames:["raster"]});export{lt as $,Aa as C,hn as H,_o as Q,Wa as T,js as W,ba as a,Ra as c,$a as f,Ta as i,va as j,So as n,To as p,Pa as r,ea as w};
