import{b4 as D,aZ as j,bP as f,bo as pt,X as _t,ef as L,_ as bt,A as gt}from"./MapPage-COzn-Qm3.js";import{I as St,v as Q,g as I,u as w,q as xt,p as K}from"./vec32-BRGMkWll.js";import{w as B,v as jt,b as zt,j as Ot}from"./frustum-Qvht9yxS.js";import{O as U,k as Y,L as k,z as at,t as tt,P as C,U as et,N as Nt,I as S,q as Tt,l as ht}from"./sphere-DIaQSr9d.js";import{i as dt}from"./BufferView-DRDRszCm.js";import{g as Mt}from"./edgeProcessing-DYhWENV2.js";import"./index-DXY0tzSu.js";import"./themeLevelStore-BW_Eok9o.js";import"./vectorStacks-JamUT9ZG.js";import"./quatf64-aQ5IuZRd.js";import"./vec2f64-DCcDeJvX.js";import"./vec4f64-CvoGn1-Y.js";import"./mat4-hUksrAJ2.js";import"./vec42-DABpX5hl.js";import"./plane-B1rRDXrg.js";import"./deduplicate-Dltq2iHk.js";import"./Indices-CWS59enc.js";import"./InterleavedLayout-R-GgoRNp.js";import"./types-BKo2foNY.js";import"./enums-CVsE7NBb.js";import"./VertexAttributeLocations-W6y2attr.js";class q{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(t,e){this.objectToBoundingSphere=t,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new l,this._objectCount=0,e&&(e.maximumObjectsPerNode!==void 0&&(this._maximumObjectsPerNode=e.maximumObjectsPerNode),e.maximumDepth!==void 0&&(this._maximumDepth=e.maximumDepth))}destroy(){this._degenerateObjects.clear(),l.clearPool(),G[0]=null,$.prune(),E.prune()}add(t){const e=Array.from(t);this._grow(e);const n=l.acquire();for(const o of e)++this._objectCount,this._isDegenerate(o)?this._degenerateObjects.add(o):(n.init(this._root),this._add(o,n));l.release(n)}remove(t,e=null){this._objectCount-=t.length;const n=l.acquire();for(const o of t){const r=e??U(this.objectToBoundingSphere(o),Bt);A(r[3])?(n.init(this._root),$t(o,r,n)):this._degenerateObjects.delete(o)}l.release(n),this._shrink()}update(t,e){if(!A(e[3])&&this._isDegenerate(t))return;const n=Dt(t);this.remove(n,e),this.add(n)}forEachAlongRay(t,e,n){const o=Y(t,e);M(this._root,r=>{if(!vt(o,r))return!1;const a=r.node;return a.terminals.forAll(h=>{this._intersectsObject(o,h)&&n(h)}),a.residents!==null&&a.residents.forAll(h=>{this._intersectsObject(o,h)&&n(h)}),!0})}forEachAlongRayWithVerticalOffset(t,e,n,o){const r=Y(t,e);M(this._root,a=>{if(!wt(r,a,o))return!1;const h=a.node;return h.terminals.forAll(s=>{this._intersectsObjectWithOffset(r,s,o)&&n(s)}),h.residents!==null&&h.residents.forAll(s=>{this._intersectsObjectWithOffset(r,s,o)&&n(s)}),!0})}forEach(t){M(this._root,e=>{const n=e.node;return n.terminals.forAll(t),n.residents!==null&&n.residents.forAll(t),!0}),this._degenerateObjects.forEach(t)}forEachDegenerateObject(t){this._degenerateObjects.forEach(t)}findClosest(t,e,n,o=()=>!0,r=1/0){let a=1/0,h=1/0,s=null;const d=V(t,e),c=u=>{if(--r,!o(u))return;const p=this.objectToBoundingSphere(u);if(!B(n,p))return;const z=T(t,e,S(p)),P=z-p[3],m=z+p[3];P<a&&(a=P,h=m,s=u)};return nt(this._root,u=>{if(r<=0||!B(n,u.bounds)||(I(g,d,u.halfSize),w(g,g,S(u.bounds)),T(t,e,g)>h))return!1;const p=u.node;return p.terminals.forAll(z=>c(z)),p.residents!==null&&p.residents.forAll(z=>c(z)),!0},t,e),s}forEachInDepthRange(t,e,n,o,r,a,h){let s=-1/0,d=1/0;const c={setRange:m=>{n===1?(s=Math.max(s,m.near),d=Math.min(d,m.far)):(s=Math.max(s,-m.far),d=Math.min(d,-m.near))}};c.setRange(o);const u=T(e,n,t),p=V(e,n),z=V(e,-n),P=m=>{if(!h(m))return;const N=this.objectToBoundingSphere(m),v=T(e,n,S(N))-u,mt=v-N[3],ft=v+N[3];mt>d||ft<s||!B(a,N)||r(m,c)};nt(this._root,m=>{if(!B(a,m.bounds)||(I(g,p,m.halfSize),w(g,g,S(m.bounds)),T(e,n,g)-u>d)||(I(g,z,m.halfSize),w(g,g,S(m.bounds)),T(e,n,g)-u<s))return!1;const N=m.node;return N.terminals.forAll(v=>P(v)),N.residents!==null&&N.residents.forAll(v=>P(v)),!0},e,n)}forEachNode(t){M(this._root,e=>t(e.node,e.bounds,e.halfSize,e.depth))}forEachNeighbor(t,e){const n=k(e),o=at(e,j()),r=s=>{const d=this.objectToBoundingSphere(s),c=k(d),u=n+c;return!(Q(S(d),o)-u*u<=0)||t(s)};let a=!0;const h=s=>{a&&(a=r(s))};M(this._root,s=>{const d=k(s.bounds),c=n+d;if(Q(S(s.bounds),o)-c*c>0)return!1;const u=s.node;return u.terminals.forAll(h),a&&u.residents!==null&&u.residents.forAll(h),a}),a&&this.forEachDegenerateObject(h)}_intersectsObject(t,e){const n=this.objectToBoundingSphere(e);return!(n[3]>0)||tt(n,t)}_intersectsObjectWithOffset(t,e,n){const o=this.objectToBoundingSphere(e);return!(o[3]>0)||tt(n.applyToBoundingSphere(o),t)}_add(t,e){e.advanceTo(this.objectToBoundingSphere(t))?e.node.terminals.push(t):(e.node.residents.push(t),e.node.residents.length>this._maximumObjectsPerNode&&e.depth<this._maximumDepth&&this._split(e))}_split(t){const e=t.node.residents;t.node.residents=null;for(let n=0;n<e.length;n++){const o=l.acquire().init(t);this._add(e.at(n),o),l.release(o)}}_grow(t){if(ot(t,e=>this.objectToBoundingSphere(e),O),A(O[3])&&!this._fitsInsideTree(O))if(ut(this._root.node))U(O,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize();else{const e=this._rootBoundsForRootAsSubNode(O);this._placingRootViolatesMaxDepth(e)?this._rebuildTree(O,e):this._growRootAsSubNode(e),l.release(e)}}_rebuildTree(t,e){et(J,e.bounds),J[3]=e.halfSize,ot([t,J],o=>o,W);const n=l.acquire().init(this._root);this._root.initFrom(null,W,W[3]),this._root.increaseHalfSize(1.25),M(n,o=>(this.add(o.node.terminals.data),o.node.residents!==null&&this.add(o.node.residents.data),!0)),l.release(n)}_placingRootViolatesMaxDepth(t){const e=Math.log(t.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return M(this._root,o=>(n=Math.max(n,o.depth),n+e<=this._maximumDepth)),n+e>this._maximumDepth}_rootBoundsForRootAsSubNode(t){const e=t[3],n=t;let o=-1/0;const r=this._root.bounds,a=this._root.halfSize;for(let s=0;s<3;s++){const d=r[s]-a-(n[s]-e),c=n[s]+e-(r[s]+a),u=Math.max(0,Math.ceil(d/(2*a))),p=Math.max(0,Math.ceil(c/(2*a)))+1,z=2**Math.ceil(Math.log(u+p)*Math.LOG2E);o=Math.max(o,z),y[s].min=u,y[s].max=p}for(let s=0;s<3;s++){let d=y[s].min,c=y[s].max;const u=(o-(d+c))/2;d+=Math.ceil(u),c+=Math.floor(u);const p=r[s]-a-d*a*2;H[s]=p+(c+d)*a}const h=o*a;return H[3]=h*lt,l.acquire().initFrom(null,H,h,0)}_growRootAsSubNode(t){const e=this._root.node;et(O,this._root.bounds),O[3]=this._root.halfSize,this._root.init(t),t.advanceTo(O,null,!0),t.node.children=e.children,t.node.residents=e.residents,t.node.terminals=e.terminals}_shrink(){for(;;){const t=this._findShrinkIndex();if(t===-1)break;this._root.advance(t),this._root.depth=0}}_findShrinkIndex(){if(this._root.node.terminals.length!==0||this._root.isLeaf())return-1;let t=null;const e=this._root.node.children;let n=0,o=0;for(;o<e.length&&t==null;)n=o++,t=e[n];for(;o<e.length;)if(e[o++])return-1;return n}_isDegenerate(t){return!A(this.objectToBoundingSphere(t)[3])}_fitsInsideTree(t){const e=this._root.bounds,n=this._root.halfSize;return t[3]<=n&&t[0]>=e[0]-n&&t[0]<=e[0]+n&&t[1]>=e[1]-n&&t[1]<=e[1]+n&&t[2]>=e[2]-n&&t[2]<=e[2]+n}toJSON(){const{maximumDepth:t,maximumObjectsPerNode:e,_objectCount:n}=this,o=this._nodeToJSON(this._root.node);return{maximumDepth:t,maximumObjectsPerNode:e,objectCount:n,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:o}}}_nodeToJSON(t){const e=t.children.map(r=>r?this._nodeToJSON(r):null),n=t.residents?.map(r=>this.objectToBoundingSphere(r)),o=t.terminals?.map(r=>this.objectToBoundingSphere(r));return{children:e,residents:n,terminals:o}}static fromJSON(t){const e=new q(n=>n,{maximumDepth:t.maximumDepth,maximumObjectsPerNode:t.maximumObjectsPerNode});return e._objectCount=t.objectCount,e._root.initFrom(t.root.node,t.root.bounds,t.root.halfSize,t.root.depth),e}}var x;let l=(x=class{constructor(){this.bounds=C(),this.halfSize=0,this.initFrom(null,null,0,0)}init(t){return this.initFrom(t.node,t.bounds,t.halfSize,t.depth)}initFrom(t,e,n,o=this.depth){return this.node=t??x.createEmptyNode(),e&&U(e,this.bounds),this.halfSize=n,this.depth=o,this}increaseHalfSize(t){this.halfSize*=t,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*lt}advance(t){let e=this.node.children[t];e||(e=x.createEmptyNode(),this.node.children[t]=e),this.node=e,this.halfSize/=2,this.depth++;const n=ct[t];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(t,e,n=!1){for(;;){if(this.isTerminalFor(t))return e?.(this,-1),!0;if(this.isLeaf()){if(!n)return e?.(this,-1),!1;this.node.residents=null}const o=this._childIndex(t);e?.(this,o),this.advance(o)}}isLeaf(){return this.node.residents!=null}isTerminalFor(t){return t[3]>this.halfSize/2}_childIndex(t){const e=this.bounds;return(e[0]<t[0]?1:0)+(e[1]<t[1]?2:0)+(e[2]<t[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new D({shrink:!0}),residents:new D({shrink:!0})}}static acquire(){return x._pool.acquire()}static release(t){x._pool.release(t)}static clearPool(){x._pool.prune()}},x._pool=new pt(()=>new x),x);function M(i,t){let e=l.acquire().init(i);const n=[e];for(;n.length!==0;){if(e=n.pop(),t(e)&&!e.isLeaf())for(let o=0;o<e.node.children.length;o++)e.node.children[o]&&n.push(l.acquire().init(e).advance(o));l.release(e)}}function nt(i,t,e,n=1){let o=l.acquire().init(i);const r=[o];for(At(e,n,st);r.length!==0;){if(o=r.pop(),t(o)&&!o.isLeaf())for(let a=7;a>=0;--a){const h=st[a];o.node.children[h]&&r.push(l.acquire().init(o).advance(h))}l.release(o)}}function $t(i,t,e){$.clear();const n=e.advanceTo(t,(o,r)=>{$.push(o.node),$.push(r)})?e.node.terminals:e.node.residents;if(n.removeUnordered(i),n.length===0)for(let o=$.length-2;o>=0&&Et($.data[o],$.data[o+1]);o-=2);}function Et(i,t){return t>=0&&(i.children[t]=null),!!ut(i)&&(i.residents===null&&(i.residents=new D({shrink:!0})),!0)}function vt(i,t){return F(S(t.bounds),2*-t.halfSize,_),F(S(t.bounds),2*t.halfSize,b),dt(i.origin,i.direction,_,b)}function wt(i,t,e){return F(S(t.bounds),2*-t.halfSize,_),F(S(t.bounds),2*t.halfSize,b),e.applyToMinMax(_,b),dt(i.origin,i.direction,_,b)}function ut(i){if(i.terminals.length!==0)return!1;if(i.residents!==null)return i.residents.length===0;for(let t=0;t<i.children.length;t++)if(i.children[t])return!1;return!0}function Ct(i,t){i[0]=Math.min(i[0],t[0]-t[3]),i[1]=Math.min(i[1],t[1]-t[3]),i[2]=Math.min(i[2],t[2]-t[3])}function Pt(i,t){i[0]=Math.max(i[0],t[0]+t[3]),i[1]=Math.max(i[1],t[1]+t[3]),i[2]=Math.max(i[2],t[2]+t[3])}function F(i,t,e){e[0]=i[0]+t,e[1]=i[1]+t,e[2]=i[2]+t}function ot(i,t,e){_[0]=1/0,_[1]=1/0,_[2]=1/0,b[0]=-1/0,b[1]=-1/0,b[2]=-1/0;for(const n of i){const o=t(n);A(o[3])&&(Ct(_,o),Pt(b,o))}Nt(e,St(yt,_,b,.5)),e[3]=Math.max(b[0]-_[0],b[1]-_[1],b[2]-_[2])/2}function At(i,t,e){if(!E.length)for(let n=0;n<8;++n)E.push({index:0,distance:0});for(let n=0;n<8;++n){const o=ct[n];E.data[n].index=n,E.data[n].distance=T(i,t,o)}E.sort((n,o)=>n.distance-o.distance);for(let n=0;n<8;++n)e[n]=E.data[n].index}function V(i,t){let e,n=1/0;for(let o=0;o<8;++o){const r=T(i,t,it[o]);r<n&&(n=r,e=it[o])}return e}function T(i,t,e){return t*(i[0]*e[0]+i[1]*e[1]+i[2]*e[2])}function A(i){return!isNaN(i)&&i!==-1/0&&i!==1/0&&i>0}const ct=[f(-1,-1,-1),f(1,-1,-1),f(-1,1,-1),f(1,1,-1),f(-1,-1,1),f(1,-1,1),f(-1,1,1),f(1,1,1)],it=[f(-1,-1,-1),f(-1,-1,1),f(-1,1,-1),f(-1,1,1),f(1,-1,-1),f(1,-1,1),f(1,1,-1),f(1,1,1)],lt=Math.sqrt(3),G=[null];function Dt(i){return G[0]=i,G}const H=C(),g=j(),_=j(),b=j(),$=new D,Bt=C(),O=C(),J=C(),W=C(),y=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],E=new D,st=[0,0,0,0,0,0,0,0],yt=j(),Lt=1e3;function It(i,t,e){const n=qt;I(n,i,.5),xt(n,n,t,.5);const o=K(n,i);return w(n,n,e),Tt(n,o)}const qt=j();let X=class{constructor(){this._idToComponent=new Map,this._components=new q(i=>i.bounds),this._edges=new q(i=>i.bounds),this._tmpLineSegment=jt(),this._tmpP1=j(),this._tmpP2=j(),this._tmpP3=j(),this.remoteClient=null}async fetchCandidates(i,t){await Promise.resolve(),_t(t),await this._ensureEdgeLocations(i,t);const e=[];return this._edges.forEachNeighbor(n=>(this._addCandidates(i,n,e),e.length<Lt),i.bounds),{result:{candidates:e}}}async _ensureEdgeLocations(i,t){const e=[];if(this._components.forEachNeighbor(r=>{if(r.info==null){const{id:a,uid:h}=r;e.push({id:a,uid:h})}return!0},i.bounds),!e.length)return;const n={components:e},o=await this.remoteClient.invoke("fetchAllEdgeLocations",n,t??{});for(const r of o.components)this._setFetchEdgeLocations(r)}async add(i){const t=new Z(i.id,i.bounds);return this._idToComponent.set(t.id,t),this._components.add([t]),{result:{}}}async remove(i){const t=this._idToComponent.get(i.id);if(t){const e=[];this._edges.forEachNeighbor(n=>(n.component===t&&e.push(n),!0),t.bounds),this._edges.remove(e),this._components.remove([t]),this._idToComponent.delete(t.id)}return{result:{}}}_setFetchEdgeLocations(i){const t=this._idToComponent.get(i.id);if(t==null||i.uid!==t.uid)return;const e=Mt.createView(i.locations),n=new Array(e.count),o=j(),r=j();for(let s=0;s<e.count;s++){e.position0.getVec(s,o),e.position1.getVec(s,r);const d=It(o,r,i.origin),c=new Ft(t,s,d);n[s]=c}this._edges.add(n);const{objectIds:a,origin:h}=i;t.info={locations:e,objectIds:a,origin:h}}_addCandidates(i,t,e){const{info:n}=t.component,{origin:o,objectIds:r}=n,a=n.locations,h=a.position0.getVec(t.index,this._tmpP1),s=a.position1.getVec(t.index,this._tmpP2);w(h,h,o),w(s,s,o);const d=r[a.componentIndex.get(t.index)];this._addEdgeCandidate(i,d,h,s,e),rt(i,d,h,e),rt(i,d,s,e)}_addEdgeCandidate(i,t,e,n,o){if(!i.returnEdge)return;const r=at(i.bounds,Rt),a=zt(e,n,this._tmpLineSegment),h=Ot(a,r,this._tmpP3);ht(i.bounds,h)&&o.push({type:"edge",objectId:t,target:L(h),distance:K(r,h),start:L(e),end:L(n)})}};X=bt([gt("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],X);const de=X;function rt(i,t,e,n){i.returnVertex&&ht(i.bounds,e)&&n.push({type:"vertex",objectId:t,target:L(e),distance:K(S(i.bounds),e)})}const R=class R{constructor(t,e){this.id=t,this.bounds=e,this.info=null,this.uid=++R.uid}};R.uid=0;let Z=R;class Ft{constructor(t,e,n){this.component=t,this.index=e,this.bounds=n}}const Rt=j();export{de as default};
