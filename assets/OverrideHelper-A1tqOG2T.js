import{U as M,s as I,g as d,bS as h}from"./MapPage-COzn-Qm3.js";import{i as x}from"./colorUtils-J3r2mA81.js";import{Z as O}from"./FieldsIndex-Bv3QU2EK.js";import{h as k}from"./DictionaryScriptEvaluator-ySPVxGCH.js";import{B as S,Y as v,X as g,z as N,a as P,c as w,D as $}from"./utils-CNckjA7H.js";import{B as T,H as G,D as E,C as D}from"./quantizationUtils-D-z-x-h8.js";import"./index-DXY0tzSu.js";import"./themeLevelStore-BW_Eok9o.js";import"./vec42-DABpX5hl.js";import"./vec4f64-CvoGn1-Y.js";import"./UnknownTimeZone-BtMwGur9.js";import"./timeZoneUtils-CfZ5OOEr.js";import"./Version-Ck0xjNHt.js";import"./TimeOnly-C7sKH3bI.js";import"./enum-1KudbGIP.js";function A(p,e,r,t,s,i){if(p==null)return null;const o=p.references("geometry")&&i?L(e,t,i):e,n=p.repurposeFeature(o,s);try{return p.evaluate(n,r)}catch(c){return M.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:",c),null}}const y=new Map;function L(p,e,r){const{transform:t,hasZ:s,hasM:i}=r;y.has(e)||y.set(e,R(e));const o=y.get(e)(p.geometry,t,s,i);return{...p,geometry:o}}function R(p){const e={};switch(p){case"esriGeometryPoint":return(r,t,s,i)=>D(t,e,r,s,i);case"esriGeometryPolygon":return(r,t,s,i)=>E(t,e,r,s,i);case"esriGeometryPolyline":return(r,t,s,i)=>G(t,e,r,s,i);case"esriGeometryMultipoint":return(r,t,s,i)=>T(t,e,r,s,i);default:return M.getLogger("esri.views.2d.support.arcadeOnDemand").error(new I("mapview-arcade",`Unable to handle geometryType: ${p}`)),r=>r}}const F=p=>{if(!p)return[0,0,0,0];const{r:e,g:r,b:t,a:s}=p;return[e,r,t,255*s]},a=class a{static findApplicableOverrides(e,r,t){if(e&&r){if(e.primitiveName){let s=!1;for(const i of t)if(i.primitiveName===e.primitiveName){s=!0;break}if(!s)for(const i of r)i.primitiveName===e.primitiveName&&t.push(i)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const s of e.effects)a.findApplicableOverrides(s,r,t);if(e.symbolLayers)for(const s of e.symbolLayers)a.findApplicableOverrides(s,r,t);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const s of e.effects)a.findApplicableOverrides(s,r,t);if(e.markerPlacement&&a.findApplicableOverrides(e.markerPlacement,r,t),e.type==="CIMVectorMarker"){if(e.markerGraphics)for(const s of e.markerGraphics)a.findApplicableOverrides(s,r,t),a.findApplicableOverrides(s.symbol,r,t)}else e.type==="CIMCharacterMarker"?a.findApplicableOverrides(e.symbol,r,t):e.type==="CIMHatchFill"?a.findApplicableOverrides(e.lineSymbol,r,t):e.type==="CIMPictureMarker"&&a.findApplicableOverrides(e.animatedSymbolProperties,r,t)}}}static findEffectOverrides(e,r){if(!e)return null;if(e.type==="CIMGeometricEffectDashes"&&S(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const t=v(e),s=e.primitiveName,i=[];for(const o of r)o.primitiveName===s&&i.push(v(o));return{type:"cim-effect-param",effect:t,overrides:g(i)}}static async resolveSymbolOverrides(e,r,t,s,i,o,n){if(!e?.symbol)return null;let{symbol:c,primitiveOverrides:l}=e;const m=!!l;if(!m&&!s)return c;c=d(c),l=d(l);let u=!0;if(r||(r={attributes:{}},u=!1),m){if(u||(l=l.filter(f=>!f.valueExpressionInfo?.expression.includes("$feature"))),n||(l=l.filter(f=>!f.valueExpressionInfo?.expression.includes("$view"))),l.length>0){const f=N(r.attributes),C={spatialReference:t,fields:f,geometryType:i};await a.createRenderExpressions(l,C),a.evaluateOverrides(l,r,i??"esriGeometryPoint",o,n,new O(f))}a.applyOverrides(c,l)}return s&&a.applyDictionaryTextOverrides(c,r,s,null),c}static async createRenderExpressions(e,r){const t=[];for(const s of e){const i=s.valueExpressionInfo;if(!i||a._expressionToRenderExpression.has(i.expression))continue;const o=k(i.expression,r.spatialReference);t.push(o),o.then(n=>a._expressionToRenderExpression.set(i.expression,n))}t.length>0&&await Promise.all(t)}static evaluateOverrides(e,r,t,s,i,o){const n={$view:{scale:i?.scale}};for(const c of e){c.value&&typeof c.value=="object"&&x(c.value)&&(c.propertyName==="Color"||c.propertyName==="StrokeColor")&&(c.value=F(c.value));const l=c.valueExpressionInfo;if(!l)continue;const m=a._expressionToRenderExpression.get(l.expression);m&&(c.value=A(m,r,n,t,o,s))}}static applyDictionaryTextOverrides(e,r,t,s,i="Normal"){if(e?.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const o=e.symbolLayers;if(!o)return;for(const n of o)n&&n.type==="CIMVectorMarker"&&a.applyDictionaryTextOverrides(n,r,t,s,e.type==="CIMTextSymbol"?e.textCase:i)}break;case"CIMVectorMarker":{const o=e.markerGraphics;if(!o)return;for(const n of o)n&&a.applyDictionaryTextOverrides(n,r,t,s)}break;case"CIMMarkerGraphic":{const o=e.textString;if(o&&o.includes("[")){const n=P(o,t);e.textString=w(r,n,s,i)}}}}static applyOverrides(e,r,t,s){if(e.primitiveName){for(const i of r)if(i.primitiveName===e.primitiveName){const o=$(i.propertyName);if(s&&s.push({cim:e,nocapPropertyName:o,value:e[o]}),t){let n=!1;for(const c of t)c.primitiveName===e.primitiveName&&(n=!0);n||t.push(i)}i.value!=null&&(e[o]=i.value)}}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const i of e.effects)a.applyOverrides(i,r,t,s);if(e.symbolLayers)for(const i of e.symbolLayers)a.applyOverrides(i,r,t,s);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const i of e.effects)a.applyOverrides(i,r,t,s);if(e.type==="CIMVectorMarker"&&e.markerGraphics)for(const i of e.markerGraphics)a.applyOverrides(i,r,t,s),a.applyOverrides(i.symbol,r,t,s)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const t of e)t.value!==void 0&&(r+=`${t.primitiveName}${t.propertyName}${JSON.stringify(t.value)}`);return r}static toValue(e,r){if(e==="DashTemplate")return r.split(" ").map(t=>Number(t));if(e==="Color"){const t=new h(r).toRgba();return t[3]*=255,t}return r}};a._expressionToRenderExpression=new Map;let b=a;export{b as OverrideHelper};
