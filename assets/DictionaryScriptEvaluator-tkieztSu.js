import{aH as S,s as y,b as v,az as F,dC as x,U as _}from"./MapPage-B4quncaN.js";import{r as D}from"./Version-1-0I74rr.js";import{Z as g}from"./FieldsIndex-CvkGjpK2.js";import{m as u,r as $,i as E}from"./TimeOnly-CHJM2LNG.js";const R=["geometry","scale","timeProperties"];function N(o,e){if(e!=null)for(const t of R)e.hasArcadeDependency(t)&&o.add(t);return o}function U(o,e){return h.create(o,e,null,["$feature","$view"])}function A(o,e,t){return h.create(o,e,t,["$feature","$view","$config"])}class h{static async create(e,t,r,i){const{arcade:n,Dictionary:s}=await S();let c;try{c=n.parseScript(e)}catch(p){throw new y("arcade-bad-expression","Failed to parse arcade script",{script:e,error:p})}const l=n.scriptUsesGeometryEngine(c);l&&await n.enableGeometrySupport(),await n.loadDependentModules(new Set,c,null,!1,l);const d={vars:i.reduce((p,T)=>({...p,[T]:null}),{}),spatialReference:t,useAsync:!1},f=n.compileScript(c,d);let a=null;r!=null&&(a=new s(r),a.immutable=!0);const m=new s;return m.immutable=!1,m.setField("scale",0),new h(e,n,c,f,t,m,a,s)}constructor(e,t,r,i,n,s,c,l){this.script=e,this._arcade=t,this._syntaxTree=r,this._compiled=i,this._spatialReference=n,this._viewDict=s,this._configDict=c,this._dictionaryCtor=l,this._dependencies=new Map,this._featureReader=new w,this._dependencies.set("geometry",t.scriptTouchesGeometry(this._syntaxTree)),this._dependencies.set("scale",this._arcade.referencesMember(this._syntaxTree,"scale")),this._dependencies.set("timeProperties",this._arcade.scriptUsesViewProperties(this._syntaxTree,["timeProperties"]))}evaluate(e,t){const r=t.$view?.timeZone;if(t.$view){let i;if(this._viewDict.setField("scale",t.$view.scale),t.$view.timeProperties!=null){const{currentStart:n,currentEnd:s}=t.$view.timeProperties;i=new this._dictionaryCtor({currentStart:n!=null?r!=null?u.epochToArcadeDate(n,r):u.unknownEpochToArcadeDate(n):void 0,currentEnd:s!=null?r!=null?u.epochToArcadeDate(s,r):u.unknownEpochToArcadeDate(s):void 0,startIncluded:!0,endIncluded:!0})}this._viewDict.setField("timeProperties",i)}return this._compiled({vars:{$view:this._viewDict,$config:this._configDict,$feature:e},spatialReference:this._spatialReference,timeZone:r})}repurposeFeature(e,t){return this._featureReader.bind(e,t,this._spatialReference),this._featureReader}references(e){return this._dependencies.get(e)??!1}}class w{constructor(){this._boundTarget=null,this._boundSchema={fields:null,fieldsIndex:null,spatialReference:null,get geometryType(){return null},get objectIdField(){return null}},this.arcadeDeclaredClass="esri.arcade.Feature",this._contextTimeZone=null}bind(e,t,r){const i=t??new g(I(e.attributes));this._boundTarget=e,this._boundSchema.fields=i.fields,this._boundSchema.fieldsIndex=i,this._boundSchema.spatialReference=r}_getField(e){return this._boundSchema.fieldsIndex.get(e)}get contextTimeZone(){return this._contextTimeZone}set contextTimeZone(e){this._contextTimeZone=e}readArcadeFeature(){return this}hasField(e){return this._boundSchema.fieldsIndex.has(e)}geometry(){if("fromJSON"in this._boundTarget)return this._boundTarget.geometry;const e=v(this._boundTarget.geometry);if(e){if(!this._boundSchema.spatialReference)throw new Error("InternalError: Expected spatial reference to be defined");e.spatialReference=this._boundSchema.spatialReference}return e}_hasGeometry(){return this._boundTarget.geometry!=null}isUnknownDateTimeField(e){return this._boundSchema.fieldsIndex.getTimeZone(e)===F}field(e,t=!0){const r=this._getField(e);if(r){const i=this._boundTarget.attributes[r.name];if(i==null)return null;switch(r.type){case"date-only":case"esriFieldTypeDateOnly":return E.fromReader(i);case"time-only":case"esriFieldTypeTimeOnly":return $.fromReader(i);case"esriFieldTypeTimestampOffset":case"timestamp-offset":return u.fromReaderAsTimeStampOffset(i);case"date":case"esriFieldTypeDate":return this.isUnknownDateTimeField(e)?u.unknownEpochToArcadeDate(i):u.epochToArcadeDate(i,this.contextTimeZone??x);default:return i}}if(t)throw new Error(`Field ${e} does not exist`);return null}setField(e,t){throw new Error("Unable to update feature attribute values, feature is readonly")}keys(){return this._boundSchema.fieldsIndex.fields.map(e=>e.name)}isEmpty(){return this._boundSchema.fields.length<=0&&!this._hasGeometry()}castToText(e=!1){return JSON.stringify(this._boundTarget)}gdbVersion(){return null}fullSchema(){return this._boundSchema}castAsJson(e=null){return{attributes:this._boundTarget.attributes,geometry:e?.keepGeometryType===!0?this.geometry():this.geometry()?.toJSON()??null}}castAsJsonAsync(e=null,t=null){return Promise.resolve(this.castAsJson(t))}}function I(o){const e=[];for(const t in o)e.push({name:t,alias:t,type:typeof o[t]=="string"?"esriFieldTypeString":"esriFieldTypeDouble"});return e}class b{static async from(e,t,r){const i=e.dictionary_version?D.parse(e.dictionary_version):null,n=new Set(e.itemsNames),s={};if(t)for(const a in t)s[a]=t[a];if(e.authoringInfo.configuration)for(const a of e.authoringInfo.configuration)s.hasOwnProperty(a.name)||(s[a.name]=a.value);const c=new Set(e.authoringInfo.symbol);for(const a of Object.keys(r))c.delete(a);c.size&&_.getLogger("esri.renderers.support.DictionaryScriptEvaluator").warnOnce("missing-fields: fieldMap entries for the following symbol fields are missing",{symbolFields:c});const l=await A(e.expression,null,s);if(!l)throw new y("dictionary-renderer:expression-error","Unable to create dictionary renderer expression");const d=!i||!i.greaterEqual(4,0);d&&_.getLogger("esri.renderers.support.DictionaryScriptEvaluator").warnOnce("Dictionary script does not support native field types. Applying fallback",{version:i});const f=new O(r,d);return new b(d,n,l,f)}constructor(e,t,r,i){this._requiresFieldCoercionToString=e,this._itemNames=t,this._compiled=r,this._reader=i}get itemNames(){return this._itemNames}evaluate(e,t,r,i){try{return this._reader.bind(e,r,i),this._compiled.evaluate(this._reader,{$view:{scale:t}})}catch(n){_.getLogger("esri.renderers.support.DictionaryScriptEvaluator").warnOnce("arcade: dictionary script evaluation failed",{error:n})}return null}createDictionaryFieldsIndex(e){if(!this._requiresFieldCoercionToString)return new g(e);const t=e.map(r=>({...r,type:"esriFieldTypeString"}));return new g(t)}}class O extends w{constructor(e,t){super(),this._fieldMap=e,this._requiresFieldCoercionToString=t}_getField(e){const t=this._fieldMap[e]??e;return this._boundSchema.fieldsIndex.get(t)}field(e){if(!this._requiresFieldCoercionToString)return super.field(e,!1);const t=this._getField(e);return t==null||this._boundTarget.attributes[t.name]==null?"":""+this._boundTarget.attributes[t.name]}}export{I as _,U as h,b as s,N as u};
