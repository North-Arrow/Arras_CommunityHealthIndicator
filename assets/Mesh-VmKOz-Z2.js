const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/loadGLTFMesh-D80RUiG_.js","assets/MapPage-za7jC9p0.js","assets/index-BVzlNWmt.js","assets/index-DydP-41E.css","assets/themeLevelStore-Dj7TAJR1.js","assets/MapPage-BHiKaOsG.css","assets/vec4f64-CvoGn1-Y.js","assets/MeshVertexAttributes-BbT9YsFc.js","assets/meshVertexSpaceUtils-NP6WBJEp.js","assets/vec32-J1QC9Knu.js","assets/MeshLocalVertexSpace-D8O30gEX.js","assets/BufferView-BzIcawn2.js","assets/vec42-DUT3dHi7.js","assets/vec2f64-DCcDeJvX.js","assets/vec3-C5goPdqL.js","assets/vec4-CCt0ygFj.js","assets/types-BKo2foNY.js","assets/loader-BvewMpDA.js","assets/Version-I9X7zz6E.js","assets/mat4-pAtdF9Wt.js","assets/quat-s2tjKEWS.js","assets/quatf64-aQ5IuZRd.js","assets/resourceUtils-O0C-dR6k.js","assets/enums-CVsE7NBb.js","assets/indexUtils-rIYrUp6w.js","assets/asyncUtils-BI-MqmEH.js","assets/Indices-CsS7CaN4.js","assets/vertexSpaceConversion-DApZfPas.js","assets/spatialReferenceEllipsoidUtils-BGKtiT0V.js","assets/computeTranslationToOriginAndRotation-PHa-btm_.js","assets/projectionUtils-DhAzLFkc.js","assets/projectPointToVector-DdP_24Wv.js","assets/MeshTransform-CbQf5vO1.js","assets/imageUtils-BsJSdqEN.js","assets/earcut-D9gy186-.js","assets/plane-CatWuyNB.js","assets/vectorStacks-DwaLtFCe.js","assets/deduplicate-CrooH2KE.js","assets/External-D2o7OmyM.js","assets/infoFor3D-DhzudQro.js","assets/gltfexport-wFPXHq9W.js"])))=>i.map(i=>d[i]);
import{_ as we}from"./index-BVzlNWmt.js";import{ci as re,B as de,c$ as Fe,ds as $e,_ as u,z as f,fA as jt,N as Ot,P as Ft,A as B,bS as Ke,U as j,dc as Ce,s as H,c3 as Ct,em as Dt,cA as Et,hZ as It,h_ as Ut,h$ as Le,i0 as se,h9 as Pt,aZ as M,bP as be,i1 as zt,fF as De,i2 as Ae,c1 as Nt,dL as ge,eR as Bt,fB as Qe,X as ye,aK as I,dw as Ht,er as kt,g_ as Gt,eC as Vt,u as Wt,d8 as qt,O as Zt,bm as Jt,bO as Xe,dG as Kt,eU as xe,f8 as Qt,gM as Xt,gN as Yt,cg as er,bj as tr,b2 as rr,cI as nr,i3 as sr}from"./MapPage-za7jC9p0.js";import{d as ee,z as Ye,w as le,a as et,j as tt,U as or}from"./MeshTransform-CbQf5vO1.js";import{c as ar}from"./imageUtils-BsJSdqEN.js";import{u as ir,r as lr,a as rt,n as cr,b as ur,c as ce,d as pr,f as oe}from"./MeshVertexAttributes-BbT9YsFc.js";import{a as Te,i as ue}from"./MeshLocalVertexSpace-D8O30gEX.js";import{t as ne,l as pe,c as nt,u as hr}from"./meshVertexSpaceUtils-NP6WBJEp.js";import{e as fr}from"./earcut-D9gy186-.js";import{t as st}from"./Indices-CsS7CaN4.js";import{o as he,c as mr,u as dr,N as Se,A as gr,z as ot,E as yr,g as xr}from"./vec32-J1QC9Knu.js";import{k as vr,j as wr,S as $r}from"./plane-CatWuyNB.js";import{e as Ee}from"./deduplicate-CrooH2KE.js";import{i as E}from"./projectPointToVector-DdP_24Wv.js";import{k as $,b as P,q as Re,n as br,P as at,V as it,w as lt,F as ct,x as ut,M as pt,a as ht}from"./vertexSpaceConversion-DApZfPas.js";import{J as Ar,o as Tr}from"./projectionUtils-DhAzLFkc.js";import{a as je}from"./spatialReferenceEllipsoidUtils-BGKtiT0V.js";import{f as ft}from"./computeTranslationToOriginAndRotation-PHa-btm_.js";import{r as Ie,a as Sr}from"./vec3-C5goPdqL.js";import{o as Ue,m as Rr,f as Mr}from"./External-D2o7OmyM.js";import{D as mt,c as dt,O as gt,f as yt,I as xt,p as _r}from"./mat4-pAtdF9Wt.js";import{b as Lr}from"./quat-s2tjKEWS.js";import{e as jr,r as Or}from"./quatf64-aQ5IuZRd.js";var X;const ve=new WeakMap;let Fr=0;var K;let R=(K=class extends re(de){constructor(e){super(e),this.wrap="repeat"}get url(){return this._get("url")||null}set url(e){this._set("url",e),e&&this._set("data",null)}get data(){return this._get("data")||null}set data(e){this._set("data",e),e&&this._set("url",null)}writeData(e,r,n,s){if(e instanceof HTMLImageElement){const o={type:"image-element",src:Fe(e.src,s),crossOrigin:e.crossOrigin};r[n]=o}else if(e instanceof HTMLCanvasElement){const o={type:"canvas-element",imageData:Pe(e.getContext("2d").getImageData(0,0,e.width,e.height))};r[n]=o}else if(e instanceof HTMLVideoElement){const o={type:"video-element",src:Fe(e.src,s),autoplay:e.autoplay,loop:e.loop,muted:e.muted,crossOrigin:e.crossOrigin,preload:e.preload};r[n]=o}else if(e instanceof ImageData){const o={type:"image-data",imageData:Pe(e)};r[n]=o}}readData(e){switch(e.type){case"image-element":{const r=new Image;return r.src=e.src,r.crossOrigin=e.crossOrigin,r}case"canvas-element":{const r=ze(e.imageData),n=document.createElement("canvas");return n.width=r.width,n.height=r.height,n.getContext("2d").putImageData(r,0,0),n}case"image-data":return ze(e.imageData);case"video-element":{const r=document.createElement("video");return r.src=e.src,r.crossOrigin=e.crossOrigin,r.autoplay=e.autoplay,r.loop=e.loop,r.muted=e.muted,r.preload=e.preload,r}default:return}}get transparent(){const{data:e,url:r}=this,n=s=>s?.toLowerCase().endsWith(".png")||s?.toLocaleLowerCase().startsWith("data:image/png;");return e instanceof HTMLCanvasElement?Ne(e.getContext("2d").getImageData(0,0,e.width,e.height)):e instanceof ImageData?Ne(e):!(!r||!n(r))||!!(e instanceof HTMLImageElement&&n(e.src))}set transparent(e){this._overrideIfSome("transparent",e)}get contentHash(){const e=typeof this.wrap=="string"?this.wrap:typeof this.wrap=="object"?`${this.wrap.horizontal}/${this.wrap.vertical}`:"",r=(n="")=>`d:${n},t:${this.transparent},w:${e}`;return this.url!=null?r(this.url):this.data!=null?this.data instanceof HTMLImageElement||this.data instanceof HTMLVideoElement?r(this.data.src):(ve.has(this.data)||ve.set(this.data,++Fr),r(ve.get(this.data))):r()}get memoryUsage(){let e=0;if(e+=this.url!=null?this.url.length:0,this.data!=null){const r=this.data;"data"in r?e+=r.data.byteLength:r instanceof HTMLImageElement?e+=r.naturalWidth*r.naturalHeight*3:r instanceof HTMLCanvasElement&&(e+=r.width*r.height*3)}return e}clone(e){const r=ir(e),n=r?.textureMap?.get(this);if(n)return n;const s=super.clone(e);return r?.textureMap?.set(this,s),s}static from(e){return typeof e=="string"?new X({url:e}):e instanceof HTMLImageElement||e instanceof HTMLCanvasElement||e instanceof ImageData||e instanceof HTMLVideoElement?new X({data:e}):$e(X,e)}},X=K,K);function Pe(t){let e="";for(let r=0;r<t.data.length;r++)e+=String.fromCharCode(t.data[r]);return{data:btoa(e),width:t.width,height:t.height}}function ze(t){const e=atob(t.data),r=new Uint8ClampedArray(e.length);for(let n=0;n<e.length;n++)r[n]=e.charCodeAt(n);return ar(r,t.width,t.height)}function Ne(t){for(let e=3;e<t.data.length;e+=4)if(t.data[e]!==255)return!0;return!1}u([f({type:String,json:{write:jt}})],R.prototype,"url",null),u([f({clonable:"reference",json:{write:{overridePolicy(){return{enabled:!this.url}}}}})],R.prototype,"data",null),u([Ot("data")],R.prototype,"writeData",null),u([Ft("data")],R.prototype,"readData",null),u([f({type:Boolean,json:{write:{overridePolicy(){return{enabled:this._isOverridden("transparent")}}}}})],R.prototype,"transparent",null),u([f({json:{write:!0}})],R.prototype,"wrap",void 0),u([f({readOnly:!0})],R.prototype,"contentHash",null),R=X=u([B("esri.geometry.support.MeshTexture")],R);let D=class extends re(de){constructor(e){super(e),this.offset=[0,0],this.rotation=0,this.scale=[1,1]}};u([f({type:[Number],nonNullable:!0,json:{write:!0}})],D.prototype,"offset",void 0),u([f({type:Number,nonNullable:!0,json:{write:!0}})],D.prototype,"rotation",void 0),u([f({type:[Number],nonNullable:!0,json:{write:!0}})],D.prototype,"scale",void 0),D=u([B("esri.geometry.support.MeshTextureTransform")],D);let _=class extends re(de){constructor(e){super(e),this.color=null,this.colorTexture=null,this.colorTextureTransform=null,this.normalTexture=void 0,this.normalTextureTransform=void 0,this.alphaMode="auto",this.alphaCutoff=.5,this.doubleSided=!0}clone(e){const r=lr(e),n=r?.materialMap?.get(this);if(n)return n;const s=super.clone(rt(e));return r?.materialMap?.set(this,s),s}get memoryUsage(){return this.getMemoryUsage()}getMemoryUsage(){let e=0;return e+=this.color!=null?16:0,this.colorTexture!=null&&(e+=this.colorTexture.memoryUsage),e+=this.colorTextureTransform!=null?20:0,this.normalTexture!=null&&(e+=this.normalTexture.memoryUsage),e+=this.normalTextureTransform!=null?20:0,e}};u([f({type:Ke,json:{write:!0}})],_.prototype,"color",void 0),u([f({type:R,json:{write:!0}})],_.prototype,"colorTexture",void 0),u([f({type:D,json:{write:!0}})],_.prototype,"colorTextureTransform",void 0),u([f({type:R,json:{write:!0}})],_.prototype,"normalTexture",void 0),u([f({type:D,json:{write:!0}})],_.prototype,"normalTextureTransform",void 0),u([f({nonNullable:!0,json:{write:!0}})],_.prototype,"alphaMode",void 0),u([f({nonNullable:!0,json:{write:!0}})],_.prototype,"alphaCutoff",void 0),u([f({nonNullable:!0,json:{write:!0}})],_.prototype,"doubleSided",void 0),_=u([B("esri.geometry.support.MeshMaterial")],_);let L=class extends _{constructor(e){super(e),this.emissiveColor=null,this.emissiveTexture=null,this.emissiveTextureTransform=void 0,this.occlusionTexture=null,this.occlusionTextureTransform=void 0,this.metallic=1,this.roughness=1,this.metallicRoughnessTexture=null,this.metallicRoughnessTextureTransform=void 0}getMemoryUsage(){let e=super.getMemoryUsage();return e+=this.emissiveColor!=null?16:0,this.emissiveTexture!=null&&(e+=this.emissiveTexture.memoryUsage),e+=this.emissiveTextureTransform!=null?20:0,this.occlusionTexture!=null&&(e+=this.occlusionTexture.memoryUsage),e+=this.occlusionTextureTransform!=null?20:0,this.metallicRoughnessTexture!=null&&(e+=this.metallicRoughnessTexture.memoryUsage),e+=this.metallicRoughnessTextureTransform!=null?20:0,e}};u([f({type:Ke,json:{write:!0}})],L.prototype,"emissiveColor",void 0),u([f({type:R,json:{write:!0}})],L.prototype,"emissiveTexture",void 0),u([f({type:D,json:{write:!0}})],L.prototype,"emissiveTextureTransform",void 0),u([f({type:R,json:{write:!0}})],L.prototype,"occlusionTexture",void 0),u([f({type:D,json:{write:!0}})],L.prototype,"occlusionTextureTransform",void 0),u([f({type:Number,nonNullable:!0,json:{write:!0},range:{min:0,max:1}})],L.prototype,"metallic",void 0),u([f({type:Number,nonNullable:!0,json:{write:!0},range:{min:0,max:1}})],L.prototype,"roughness",void 0),u([f({type:R,json:{write:!0}})],L.prototype,"metallicRoughnessTexture",void 0),u([f({type:D,json:{write:!0}})],L.prototype,"metallicRoughnessTextureTransform",void 0),L=u([B("esri.geometry.support.MeshMaterialMetallicRoughness")],L);var Me;let T=Me=class extends re(de){static from(t){return $e(Me,t)}constructor(t){super(t),this.faces=null,this.material=null,this.name=void 0,this.shading="source",this.trustSourceNormals=!1}castFaces(t){return cr(t,Uint32Array,[Uint16Array],{loggerTag:".faces=",stride:3},j.getLogger(this))}castMaterial(t){return $e(t&&typeof t=="object"&&("metallic"in t||"roughness"in t||"metallicRoughnessTexture"in t)?L:_,t)}get memoryUsage(){let t=0;return this.faces!=null&&(t+=this.faces.byteLength),this.material!=null&&(t+=this.material.memoryUsage),t}};u([f({json:{write:ur}})],T.prototype,"faces",void 0),u([Ce("faces")],T.prototype,"castFaces",null),u([f({type:_,json:{write:!0}})],T.prototype,"material",void 0),u([Ce("material")],T.prototype,"castMaterial",null),u([f({json:{write:!0}})],T.prototype,"name",void 0),u([f({type:String,json:{write:!0}})],T.prototype,"shading",void 0),u([f({type:Boolean})],T.prototype,"trustSourceNormals",void 0),T=Me=u([B("esri.geometry.support.MeshComponent")],T);const Cr="Mesh must be loaded before applying operations",Dr="Provided component is not part of the list of components",Er="Expected polygon to be a Polygon instance",Y="Expected location to be a Point instance";let Ir=class extends H{constructor(){super("invalid-input:location",Y)}};function Ur(t,e,r){const n=Pr(Be,t,e,r)?vr(Be):[0,0,1];return Math.abs(n[2])>Math.cos(Ct(80))?2:Math.abs(n[1])>Math.abs(n[0])?1:0}function Pr(t,e,r,n){const s=(i=>!Array.isArray(i[0]))(e)?(i,a)=>e[3*i+a]:(i,a)=>e[i][a],o=n?Dt(n)/Et(n):1;return $r(t,(i,a)=>he(i,s(a,0)*o,s(a,1)*o,s(a,2)),r)}const Be=wr();function zr(t){const e=Br(t.rings,t.hasZ,1,t.spatialReference),r=new Array;let n=0,s=0;for(const a of e.polygons){const c=a.count,l=a.index,h=It(e.position,3*l,3*c),d=a.holeIndices.map(p=>p-l),m=st(fr(h,d,3));r.push({position:h,faces:m}),n+=h.length,s+=m.length}const o=Nr(r,n,s),i=Array.isArray(o.position)?Ee(o.position,3,{originalIndices:o.faces}):Ee(o.position.buffer,6,{originalIndices:o.faces});return o.position=Ut(new Float64Array(i.buffer)),o.faces=i.indices,o}function Nr(t,e,r){if(t.length===1)return t[0];const n=Le(e),s=new Array(r);let o=0,i=0,a=0;for(const c of t){for(let l=0;l<c.position.length;l++)n[o++]=c.position[l];for(const l of c.faces)s[i++]=l+a;a=o/3}return{position:n,faces:st(s)}}function Br(t,e,r,n){const s=t.length,o=new Array(s),i=new Array(s),a=new Array(s);let c=0;for(let g=0;g<s;++g)c+=t[g].length;let l=0,h=0,d=0;const m=Le(3*c);let p=0;for(let g=s-1;g>=0;g--){const y=t[g],b=Hr(y,e,n);if(b&&s!==1)o[l++]=y;else{let F=y.length;for(let x=0;x<l;++x)F+=o[x].length;const w={index:p,pathLengths:new Array(l+1),count:F,holeIndices:new Array(l)};w.pathLengths[0]=y.length,y.length>0&&(a[d++]={index:p,count:y.length}),p=b?ae(y,y.length-1,-1,m,p,y.length,e):ae(y,0,1,m,p,y.length,e);for(let x=0;x<l;++x){const S=o[x];w.holeIndices[x]=p,w.pathLengths[x+1]=S.length,S.length>0&&(a[d++]={index:p,count:S.length}),p=ae(S,0,1,m,p,S.length,e)}l=0,w.count>0&&(i[h++]=w)}}for(let g=0;g<l;++g){const y=o[g];y.length>0&&(a[d++]={index:p,count:y.length}),p=ae(y,0,1,m,p,y.length,e)}return i.length=h,a.length=d,{position:m,polygons:i,outlines:a}}function ae(t,e,r,n,s,o,i){s*=3;for(let a=0;a<o;++a){const c=t[e];n[s++]=c[0],n[s++]=c[1],n[s++]=i&&c[2]?c[2]:0,e+=r}return s/3}function Hr(t,e,r){if(!e)return!se(t);const n=t.length-1;switch(Ur(t,n,r)){case 0:return!se(t,1,2);case 1:return!se(t,0,2);case 2:return!se(t,0,1)}}function Oe(t,e,r,n){if(n!==void 0){Pt(t(),"option: geographic",{replacement:"Use mesh `vertexSpace` and spatial reference to control how operations are performed instead.",version:"4.30",warnOnce:!0});const s=e.type==="local";if(!ne(e)||n===s)return r.isGeographic||r.isWebMercator&&n;t().warnOnce(`Specifying the 'geographic' parameter (${n}) for a Mesh vertex space of type "${e.type}" is not supported. This parameter will be ignored.`)}switch(e.type){case"georeferenced":return r.isGeographic;case"local":return r.isGeographic||r.isWebMercator}}const te=()=>j.getLogger("esri.geometry.support.meshUtils.centerAt");function kr(t,e,r){if(!t.vertexAttributes?.position)return;const{vertexSpace:n}=t,s=r?.origin??t.origin,o=Oe(te,n,s.spatialReference,r?.geographic);ne(n)?Gr(t,e,s):o?Vr(t,e,s):Wr(t,e,s)}function Gr(t,e,r){const{vertexSpace:n}=t;if(!ne(n))return;const s=wt,o=vt;if(!E(e,o,t.spatialReference))return void $(te(),e.spatialReference,t.spatialReference,P);if(!E(r,s,t.spatialReference)){const a=t.origin;return s[0]=a.x,s[1]=a.y,s[2]=a.z,void $(te(),r.spatialReference,t.spatialReference,P)}const i=mr(Zr,o,s);n.origin=dr(M(),n.origin,i)}function Vr(t,e,r){const n=be(r.x,r.y,r.z??0),s=Re(t,new Te({origin:n}));if(!s)return;const o=be(e.x,e.y,e.z??0),i=Re({vertexAttributes:s,spatialReference:t.spatialReference,vertexSpace:new Te({origin:o})},ue.absolute);if(!i)return;const{position:a,normal:c,tangent:l}=i;t.vertexAttributes.position=a,t.vertexAttributes.normal=c,t.vertexAttributes.tangent=l,t.vertexAttributesChanged()}function Wr(t,e,r){const n=wt,s=vt;if(E(e,s,t.spatialReference)){if(!E(r,n,t.spatialReference)){const o=t.origin;return n[0]=o.x,n[1]=o.y,n[2]=o.z,void $(te(),r.spatialReference,t.spatialReference,P)}qr(t.vertexAttributes.position,s,n),t.vertexAttributesChanged()}else $(te(),e.spatialReference,t.spatialReference,P)}function qr(t,e,r){if(t)for(let n=0;n<t.length;n+=3)for(let s=0;s<3;s++)t[n+s]+=e[s]-r[s]}const vt=M(),wt=M(),Zr=M();function Jr(t){const{spatialReference:e,vertexSpace:r,untransformedBounds:n}=t,s=zt(n,Kr);if(ne(r)&&t.transform&&Ie(s,s,t.transform.localMatrix),r.type==="georeferenced"){const a=r.origin;return a&&Sr(s,s,a),De(Ae(s),e)}const o=je(e),i=r.origin;if(!Ar(o,e)){const[a,c,l]=i;return new Nt({xmin:a,ymin:c,zmin:l,xmax:a,ymax:c,zmax:l,spatialReference:e})}return ft(e,i,He,o),Ie(s,s,He),Tr(s,o,0,s,e,0),De(Ae(s),e)}const He=ge(),Kr=Le(24);async function Qr(t,e,r){switch(e.source.type){case"client":case"service":return Xr(t,e,r);case"loadable":return e.source.load(t,r);default:Bt(e.source)}}async function Xr(t,e,r){const{source:n}=e,{loadGLTFMesh:s}=await Qe(we(()=>import("./loadGLTFMesh-D80RUiG_.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39])),r),o=await en(n,r);ye(r);const i=s(new I({x:0,y:0,z:0,spatialReference:t.spatialReference}),o.url,{resolveFile:Yr(o),signal:r?.signal,expectedType:o.type,unitConversionDisabled:e.unitConversionDisabled});i.then(()=>o.dispose(),()=>o.dispose());const{mesh:{vertexAttributes:a,components:c},meta:{isDracoDecompressed:l}}=await i;if(l)throw new H("mesh-load-external:draco-not-supported","The provided mesh uses Draco compression which is not supported.");t.vertexAttributes=a,t.components=c}function Yr(t){const e=Ht(t.url);return r=>{const n=kt(r,e,e),s=n?n.replace(/^ *\.\//,""):null;return(s?t.files.get(s):null)??r}}async function en(t,e){switch(t.type){case"client":return Array.isArray(t.files)?rn(t.files):$t(t.files);case"service":return nn(t.assets,e);default:throw new H("mesh-load-external:invalid-source","Invalid source type")}}async function tn(t,e){const{parts:r,assetMimeType:n,assetName:s}=t;if(r.length===1)return new fe(r[0].partUrl);const o=await t.toBlob(e);return ye(e),fe.fromBlob(o,Rt(s,n))}function $t(t){return fe.fromBlob(t,Rt(t.name,t.type))}function rn(t){if(!t.length)throw new H("mesh-load-external:missing-assets","There must be at least one file to load");return Tt(t.map(e=>({name:e.name,mimeType:e.type,source:$t(e)})))}async function nn(t,e){if(!t.length)throw new H("mesh-load-external:missing-assets","There must be at least one file to load");const r=await Gt(t.map(async n=>{const s=await tn(n);return ye(e),{name:n.assetName,mimeType:n.assetMimeType,source:s}}));if(Vt(e))throw r.forEach(n=>n.source.dispose()),Wt();return Tt(r)}const bt=/^model\/gltf\+json$/,At=/^model\/gltf-binary$/,_e=/\.gltf$/i,sn=/\.glb$/i;function ke({mimeType:t,source:e,name:r}){return bt.test(t)||_e.test(r)?{url:e.url,type:"gltf"}:At.test(t)||sn.test(r)?{url:e.url,type:"glb"}:null}function Tt(t){const e=new Map;let r=null,n=null;for(const o of t){const{source:i,name:a}=o;r??=ke(o),a==="ESRI3DO_NORM.glb"&&(n=ke(o)),e.set(a,i.url),i.files.forEach((c,l)=>e.set(l,c))}const s=n??r;if(s==null)throw new H("mesh-load-external:missing-files","Missing files to load external mesh source");return new fe(s.url,()=>t.forEach(({source:o})=>o.dispose()),e,s.type)}let fe=class St{constructor(e,r=()=>{},n=new Map,s){this.url=e,this.dispose=r,this.files=n,this.type=s}static fromBlob(e,r){const n=URL.createObjectURL(e);return new St(n,()=>URL.revokeObjectURL(n),void 0,r)}};function Rt(t,e){return bt.test(e)||_e.test(t)?"gltf":At.test(e)||_e.test(t)?"glb":void 0}let C=class extends qt{constructor(t){super(t),this.externalSources=new Zt,this._explicitDisplaySource=null,this.georeferenced=!1,this.addHandles(Jt(()=>this.externalSources,"after-remove",({item:e})=>{e===this._explicitDisplaySource&&(this._explicitDisplaySource=null)},{sync:!0,onListenerRemove:()=>this._explicitDisplaySource=null}))}get displaySource(){return this._explicitDisplaySource??this._implicitDisplaySource}set displaySource(t){if(t!=null&&!Ue(t))throw new Error("Cannot use this source for display: it is not in a supported format.");this._explicitDisplaySource=t,t&&this.externalSources.every(e=>!Rr(e,t))&&this.externalSources.add(t)}clearSources(){this.externalSources.removeAll()}getExternalSourcesOnService(t){return this.externalSources.items.filter(e=>Mr(e,t))}get _implicitDisplaySource(){return this.externalSources.find(Ue)}};u([f()],C.prototype,"externalSources",void 0),u([f()],C.prototype,"displaySource",null),u([f()],C.prototype,"_implicitDisplaySource",null),u([f()],C.prototype,"_explicitDisplaySource",void 0),u([f()],C.prototype,"georeferenced",void 0),C=u([B("esri.geometry.support.meshUtils.Metadata")],C);function on(){const{faceDescriptions:t,faceVertexOffsets:e,uvScales:r}=dn,n=4*t.length,s=new Float64Array(3*n),o=new Float32Array(3*n),i=new Float32Array(2*n),a=new Uint32Array(2*t.length*3);let c=0,l=0,h=0,d=0;for(let m=0;m<t.length;m++){const p=t[m],g=c/3;for(const b of e)a[d++]=g+b;const y=p.corners;for(let b=0;b<4;b++){const F=y[b];let w=0;i[h++]=.25*r[b][0]+p.uvOrigin[0],i[h++]=p.uvOrigin[1]-.25*r[b][1];for(let x=0;x<3;x++)p.axis[x]!==0?(s[c++]=.5*p.axis[x],o[l++]=p.axis[x]):(s[c++]=.5*F[w++],o[l++]=0)}}return{position:s,normal:o,uv:i,faces:a}}function an(t,e){const r=t.components[0],n=r.faces,s=gn[e],o=6*s,i=new Array(6),a=new Array(n.length-6);let c=0,l=0;for(let h=0;h<n.length;h++)h>=o&&h<o+6?i[c++]=n[h]:a[l++]=n[h];if(t.vertexAttributes.uv!=null){const h=new Float32Array(t.vertexAttributes.uv),d=4*s*2,m=[0,1,1,1,1,0,0,0];for(let p=0;p<m.length;p++)h[d+p]=m[p];t.vertexAttributes.uv=h}return t.components=[new T({faces:i,material:r.material}),new T({faces:a})],t}function ln(t=0){const e=Math.round(8*2**t),r=2*e,n=(e-1)*(r+1)+2*r,s=new Float64Array(3*n),o=new Float32Array(3*n),i=new Float32Array(2*n),a=new Uint32Array(3*((e-1)*r*2));let c=0,l=0,h=0,d=0;for(let m=0;m<=e;m++){const p=m/e*Math.PI+.5*Math.PI,g=Math.cos(p),y=Math.sin(p);v[2]=y;const b=m===0||m===e,F=b?r-1:r;for(let w=0;w<=F;w++){const x=w/F*2*Math.PI;v[0]=-Math.sin(x)*g,v[1]=Math.cos(x)*g;for(let S=0;S<3;S++)s[c]=.5*v[S],o[c]=v[S],++c;i[l++]=(w+(b?.5:0))/r,i[l++]=m/e,m!==0&&w!==r&&(m!==e&&(a[h++]=d,a[h++]=d+1,a[h++]=d-r),m!==1&&(a[h++]=d,a[h++]=d-r,a[h++]=d-r-1)),d++}}return{position:s,normal:o,uv:i,faces:a}}function cn(t=0){const r=Math.round(16*2**t),n=4*(r+1)+2*r,s=new Float64Array(3*n),o=new Float32Array(3*n),i=new Float32Array(2*n),a=new Uint32Array(3*(4*r));let c=0,l=0,h=0,d=0,m=0;for(let p=0;p<=5;p++){const g=p===0||p===5,y=p<=1||p>=4,b=p===2||p===4,F=g?r-1:r;for(let w=0;w<=F;w++){const x=w/F*2*Math.PI,S=g?0:.5;v[0]=S*Math.sin(x),v[1]=S*-Math.cos(x),v[2]=p<=2?.5:-.5;for(let k=0;k<3;k++)s[c++]=v[k],o[l++]=y?k===2?p<=1?1:-1:0:k===2?0:v[k]/S;i[h++]=(w+(g?.5:0))/r,i[h++]=p<=1?1*p/3:p<=3?1*(p-2)/3+1/3:1*(p-4)/3+2/3,b||p===0||w===r||(p!==5&&(a[d++]=m,a[d++]=m+1,a[d++]=m-r),p!==1&&(a[d++]=m,a[d++]=m-r,a[d++]=m-r-1)),m++}}return{position:s,normal:o,uv:i,faces:a}}function un(t,e){const r=typeof e=="number"?e:e!=null?e.width:1,n=typeof e=="number"?e:e!=null?e.height:1;switch(t){case"up":case"down":return{width:r,depth:n};case"north":case"south":return{width:r,height:n};case"east":case"west":return{depth:r,height:n}}}function pn(t){const e=Q.facingAxisOrderSwap[t],r=Q.position,n=Q.normal,s=new Float64Array(r.length),o=new Float32Array(n.length);let i=0;for(let a=0;a<4;a++){const c=i;for(let l=0;l<3;l++){const h=e[l],d=Math.abs(h)-1,m=h>=0?1:-1;s[i]=r[c+d]*m,o[i]=n[c+d]*m,i++}}return{position:s,normal:o,uv:new Float32Array(Q.uv),faces:new Uint32Array(Q.faces),isPlane:!0}}const G=1,V=2,W=3,Q={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[W,G,V],west:[-W,-G,V],north:[-G,W,V],south:[G,-W,V],up:[G,V,W],down:[G,-V,-W]}};function ie(t,e,r){t.isPlane||hn(t),mn(t,fn(r?.size,r?.unit,e.spatialReference));const n=pe(e,r),s=e.spatialReference.isGeographic?pe(e):n,o=Re({vertexAttributes:t,vertexSpace:s,spatialReference:e.spatialReference},n,{allowBufferReuse:!0});return{vertexAttributes:new ce({...o,uv:t.uv}),vertexSpace:n,components:[new T({faces:t.faces,material:r?.material||null})],spatialReference:e.spatialReference}}function hn(t){for(let e=0;e<t.position.length;e+=3)t.position[e+2]+=.5}function fn(t,e,r){const n=br(e,r);if(t==null&&n===1)return null;if(t==null)return[n,n,n];if(typeof t=="number"){const s=t*n;return[s,s,s]}return[t.width!=null?t.width*n:n,t.depth!=null?t.depth*n:n,t.height!=null?t.height*n:n]}function mn(t,e){if(e!=null){U[0]=e[0],U[4]=e[1],U[8]=e[2];for(let r=0;r<t.position.length;r+=3){for(let n=0;n<3;n++)v[n]=t.position[r+n];Se(v,v,U);for(let n=0;n<3;n++)t.position[r+n]=v[n]}if(e[0]!==e[1]||e[1]!==e[2]){U[0]=1/e[0],U[4]=1/e[1],U[8]=1/e[2];for(let r=0;r<t.normal.length;r+=3){for(let n=0;n<3;n++)v[n]=t.normal[r+n];Se(v,v,U),gr(v,v);for(let n=0;n<3;n++)t.normal[r+n]=v[n]}}}}const dn={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},gn={south:0,east:1,north:2,west:3,up:4,down:5},v=M(),U=Xe(),z=()=>j.getLogger("esri.geometry.support.meshUtils.rotate");function yn(t,e,r){if(!t.vertexAttributes?.position||e[3]===0)return;const{spatialReference:n,vertexSpace:s}=t,o=r?.origin??t.origin,i=r?.geographic,a=Oe(z,s,n,i);nt(t)?xn(t,e,o):a?vn(t,e,o):wn(t,e,o)}function xn(t,e,r){t.transform??=new ee;const{vertexSpace:n,transform:s,spatialReference:o}=t,[i,a,c]=n.origin,l=new I({x:i,y:a,z:c,spatialReference:o}),h=q;if(l.equals(r))he(h,0,0,0);else if(!at(h,r,t))return void $(z(),r.spatialReference,o,P);Lr(qe,le(e),Ye(e));const d=mt(Ge,qe,xe,Qt,h),{localMatrix:m}=s,p=dt(Ge,d,m);s.scale=gt(M(),p),yt(p,p,ot(q,s.scale));const g=s.rotationAxis;s.rotation=et(p),s.rotationAngle===0&&(s.rotationAxis=g),s.translation=xt(M(),p)}function vn(t,e,r){const n=t.spatialReference,s=je(n),o=Mt;if(!E(r,o,s)&&($(z(),r.spatialReference,s,"Falling back to mesh origin"),!E(t.origin,o,s)))return void $(z(),t.origin.spatialReference,s);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,l=new Float64Array(i.length),h=a!=null?new Float32Array(a.length):null,d=c!=null?new Float32Array(c.length):null;ft(s,o,me,s),Kt(We,me);const m=Ve;Se(le(Ve),le(e),We),m[3]=e[3],it(i,n,l,s)&&(a==null||h==null||lt(a,i,n,l,s,h))&&(c==null||d==null||ct(c,i,n,l,s,d))?(J(l,m,3,o),ut(l,s,i,n)&&(a==null||h==null||(J(h,m,3),pt(h,i,n,l,s,a)))&&(c==null||d==null||(J(d,m,4),ht(d,i,n,l,s,c)))?t.vertexAttributesChanged():$(z(),s,n)):$(z(),n,s)}function wn(t,e,r){const n=Mt;if(!E(r,n,t.spatialReference)){const s=t.origin;return n[0]=s.x,n[1]=s.y,n[2]=s.z,void $(z(),r.spatialReference,t.spatialReference,P)}J(t.vertexAttributes.position,e,3,n),J(t.vertexAttributes.normal,e,3),J(t.vertexAttributes.tangent,e,4),t.vertexAttributesChanged()}function J(t,e,r,n=xe){if(t!=null){_r(me,Ye(e),le(e));for(let s=0;s<t.length;s+=r){for(let o=0;o<3;o++)q[o]=t[s+o]-n[o];yr(q,q,me);for(let o=0;o<3;o++)t[s+o]=q[o]+n[o]}}}const q=M(),Ge=ge(),Ve=tt(),me=ge(),We=Xe(),Mt=M(),qe=jr(),N=()=>j.getLogger("esri.geometry.support.meshUtils.scale");function $n(t,e,r){if(!t.vertexAttributes?.position)return;const{vertexSpace:n,spatialReference:s}=t,o=r?.origin??t.origin,i=r?.geographic,a=Oe(N,n,s,i);nt(t)?bn(t,e,o):a?An(t,e,o):Tn(t,e,o)}function bn(t,e,r){t.transform??=new ee;const{vertexSpace:n,transform:s,spatialReference:o}=t,[i,a,c]=n.origin,l=new I({x:i,y:a,z:c,spatialReference:o}),h=Z;if(l.equals(r))he(h,0,0,0);else if(!at(h,r,t))return void $(N(),r.spatialReference,o,P);const d=he(Sn,e,e,e),m=mt(Ze,Or,xe,d,h),{localMatrix:p}=s,g=dt(Ze,m,p);s.scale=gt(M(),g),yt(g,g,ot(Z,s.scale));const y=s.rotationAxis;s.rotation=et(g),s.rotationAngle===0&&(s.rotationAxis=y),s.translation=xt(M(),g)}function An(t,e,r){const n=t.spatialReference,s=je(n),o=Lt;if(!E(r,o,s)&&($(N(),r.spatialReference,s,"Falling back to mesh origin"),!E(t.origin,o,s)))return void $(N(),t.origin.spatialReference,s);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,l=new Float64Array(i.length),h=a!=null?new Float32Array(a.length):null,d=c!=null?new Float32Array(c.length):null;it(i,n,l,s)&&(a==null||h==null||lt(a,i,n,l,s,h))&&(c==null||d==null||ct(c,i,n,l,s,d))?(_t(l,e,o),ut(l,s,i,n)&&(a==null||h==null||pt(h,i,n,l,s,a))&&(c==null||d==null||ht(d,i,n,l,s,c))?t.vertexAttributesChanged():$(N(),s,n)):$(N(),n,s)}function Tn(t,e,r){const n=Lt;if(!E(r,n,t.spatialReference)){const s=t.origin;return n[0]=s.x,n[1]=s.y,n[2]=s.z,void $(N(),r.spatialReference,t.spatialReference,P)}_t(t.vertexAttributes.position,e,n),t.vertexAttributesChanged()}function _t(t,e,r=xe){if(t)for(let n=0;n<t.length;n+=3){for(let s=0;s<3;s++)Z[s]=t[n+s]-r[s];xr(Z,Z,e);for(let s=0;s<3;s++)t[n+s]=Z[s]+r[s]}}const Z=M(),Sn=M(),Ze=ge(),Lt=M();var O;const Rn={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:ue,local:Te}};let A=O=class extends re(Xt(Yt(er))){constructor(t){super(t),this.components=null,this.vertexSpace=new ue,this.transform=null,this.metadata=new C,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new ce,this.type="mesh"}initialize(){(this.metadata.externalSources.length===0||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when(()=>{this.addHandles(tr(()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map(t=>t.clone())}),()=>this._clearSources(),{once:!0,sync:!0}))})}get hasExtent(){return this.loaded?this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0):this.metadata.displaySource?.extent!=null}get _transformedExtent(){const{spatialReference:t,vertexSpace:e}=this,r=this;return Jr({get transform(){return r.transform},vertexSpace:e,spatialReference:t,untransformedBounds:this._untransformedBounds})}get _untransformedBounds(){const{vertexAttributes:{position:t},components:e}=this;return t.length===0||e?.length===0?rr(sr):Ae(t)}get origin(){const t=hr(this.vertexSpace,this.spatialReference);if(t!=null)return t;const{center:e,zmin:r}=this._transformedExtent;return new I({x:e.x,y:e.y,z:r,spatialReference:this.spatialReference})}get extent(){return this.loaded||this.metadata?.displaySource?.extent==null?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(t){this._checkIfLoaded("addComponent()")&&(this.components||(this.components=[]),this.components.push(T.from(t)),this.notifyChange("components"))}removeComponent(t){if(this._checkIfLoaded("removeComponent()")){if(this.components){const e=this.components.indexOf(t);if(e!==-1)return this.components.splice(e,1),void this.notifyChange("components")}j.getLogger(this).error("removeComponent()",Dr)}}rotate(t,e,r,n){return or(t,e,r,Je),yn(this,Je,n),this}offset(t,e,r){if(!this._checkIfLoaded("offset()"))return this;const{vertexSpace:n,vertexAttributes:s}=this,o=s?.position;if(!o)return this;if(ne(n)){const[i,a,c]=n.origin;n.origin=be(i+t,a+e,c+r)}else{for(let i=0;i<o.length;i+=3)o[i]+=t,o[i+1]+=e,o[i+2]+=r;this.vertexAttributesChanged()}return this}scale(t,e){return this._checkIfLoaded("scale()")?($n(this,t,e),this):this}centerAt(t,e){return this._checkIfLoaded("centerAt()")?(kr(this,t,e),this):this}load(t){const{metadata:{displaySource:e}}=this;return e&&this.addResolvingPromise(Qr(this,e,t)),Promise.resolve(this)}addExternalSources(t){this.metadata.externalSources.addMany(t)}updateDisplaySource(t){this.metadata.displaySource=t}clone(t){return super.clone(pr(rt(t)))}cloneShallow(){return new O({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(t){const[{toBinaryGLTF:e}]=await Promise.all([we(()=>import("./gltfexport-wFPXHq9W.js"),__vite__mapDeps([40,1,2,3,4,5,20,21,9,12,27,19,28,29,30,31,8,10,14,11,13,6,15,23,22,32,33,7,34,26,35,36,37,38,39])),this.load(t)]);return ye(t),await e(this,t)}get usedMemory(){return this.components?this.components.reduce((t,e)=>t+e.memoryUsage,this.vertexAttributes.usedMemory):this.vertexAttributes.usedMemory}_clearSources(){this.metadata.clearSources()}_checkIfLoaded(t){return!!this.loaded||(j.getLogger(this).error(t,Cr),!1)}static createBox(t,e){if(!(t instanceof I))return j.getLogger(this.prototype).error(".createBox()",Y),null;const r=new O(ie(on(),t,e));return e?.imageFace&&e.imageFace!=="all"?an(r,e.imageFace):r}static createSphere(t,e){return t instanceof I?new O(ie(ln(e?.densificationFactor||0),t,e)):(j.getLogger(this.prototype).error(".createSphere()",Y),null)}static createCylinder(t,e){return t instanceof I?new O(ie(cn(e?.densificationFactor||0),t,e)):(j.getLogger(this.prototype).error(".createCylinder()",Y),null)}static createPlane(t,e){if(!(t instanceof I))return j.getLogger(this.prototype).error(".createPlane()",Y),null;const r=e?.facing??"up",n=un(r,e?.size);return new O(ie(pn(r),t,{...e,size:n}))}static createFromPolygon(t,e){if(!(t instanceof nr))return j.getLogger(this.prototype).error(".createFromPolygon()",Er),null;const r=zr(t);return new O({vertexAttributes:new ce({position:r.position}),components:[new T({faces:r.faces,shading:"flat",material:e?.material??null})],spatialReference:t.spatialReference,vertexSpace:new ue})}static async createFromGLTF(t,e,r){if(!(t instanceof I)){const s=new Ir;throw j.getLogger(this.prototype).error(".createfromGLTF()",s.message),s}const{loadGLTFMesh:n}=await Qe(we(()=>import("./loadGLTFMesh-D80RUiG_.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39])),r);return new O((await n(t,e,r)).mesh)}static createWithExternalSource(t,e,r){const n=r?.extent??null,{spatialReference:s}=t,o=r?.transform?.clone()??new ee,i=pe(t,r),a=r?.unitConversionDisabled,c={source:e,extent:n,unitConversionDisabled:a},l=new C;return l.externalSources.push(c),new O({metadata:l,transform:o,vertexSpace:i,spatialReference:s})}static createIncomplete(t,e){const{spatialReference:r}=t,n=e?.transform?.clone()??new ee,s=pe(t,e),o=new O({transform:n,vertexSpace:s,spatialReference:r});return o.addResolvingPromise(Promise.reject(new H("mesh-incomplete","Mesh resources are not complete"))),o}};u([f({type:[T],json:{write:!0}})],A.prototype,"components",void 0),u([f({nonNullable:!0,types:Rn,constructOnly:!0,json:{write:!0},clonable:(t,e)=>oe(e)?.vertexSpace??t.clone(e)})],A.prototype,"vertexSpace",void 0),u([f({type:ee,clonable:(t,e)=>{const r=oe(e);return r&&"transform"in r?r.transform:t?.clone()??t},json:{write:!0}})],A.prototype,"transform",void 0),u([f({constructOnly:!0,type:C,clonable:(t,e)=>oe(e)?.metadata??t.clone()})],A.prototype,"metadata",void 0),u([f()],A.prototype,"hasExtent",null),u([f()],A.prototype,"_transformedExtent",null),u([f()],A.prototype,"_untransformedBounds",null),u([f()],A.prototype,"origin",null),u([f({readOnly:!0,json:{read:!1}})],A.prototype,"extent",null),u([f({readOnly:!0,json:{read:!1,write:!0,default:!0}})],A.prototype,"hasZ",void 0),u([f({readOnly:!0,json:{read:!1,write:!0,default:!1}})],A.prototype,"hasM",void 0),u([f({type:ce,nonNullable:!0,json:{write:!0},clonable:(t,e)=>oe(e)?.vertexAttributes??t.clone(e)})],A.prototype,"vertexAttributes",void 0),A=O=u([B("esri.geometry.Mesh")],A);const Je=tt(),Yn=Object.freeze(Object.defineProperty({__proto__:null,get default(){return A}},Symbol.toStringTag,{value:"Module"}));export{Yn as M,A as Y,R as g,T as h,D as p,L as u};
