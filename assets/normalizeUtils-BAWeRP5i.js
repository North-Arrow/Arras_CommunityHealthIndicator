import{dp as Q,bs as G,dt as O,H as T,b as Z,I as _,eP as k,eQ as B,Z as E,aJ as F,b9 as U,cG as v,U as K,cI as z,S as C,a6 as V,s as Y}from"./MapPage-ILsU69jC.js";import{n as ee}from"./Cyclical-BWQSQaOw.js";import{r as I,i as w,o as L,s as H}from"./normalizeUtilsCommon-yJypF5HT.js";async function te(e,s,c,n){const t=Q(e),i=s[0].spatialReference,r={...n,responseType:"json",query:{...t.query,f:"json",sr:O(i),target:JSON.stringify({geometryType:G(s[0]),geometries:s}),cutter:JSON.stringify(c)}},o=await T(t.path+"/cut",r),{cutIndexes:a,geometries:u=[]}=o.data;return{cutIndexes:a,geometries:u.map(p=>{const x=Z(p);return x.spatialReference=i,x})}}async function se(e,s,c){const n=typeof e=="string"?_(e):e,t=s[0].spatialReference,i=G(s[0]),r={...c,query:{...n.query,f:"json",sr:O(t),geometries:JSON.stringify(k(s))}},{data:o}=await T(n.path+"/simplify",r);return B(o.geometries,i,t)}const X=()=>K.getLogger("esri.geometry.support.normalizeUtils");function ne(e){return e.type==="polygon"}function oe(e){return e[0].type==="polygon"}function re(e){return e[0].type==="polyline"}function ie(e,s){if(!(e instanceof U||e instanceof z)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw X().error(t),new Y("internal:geometry",t)}const c=L(e),n=[];for(const t of c){const i=[];n.push(i),i.push([t[0][0],t[0][1]]);for(let r=0;r<t.length-1;r++){const o=t[r][0],a=t[r][1],u=t[r+1][0],p=t[r+1][1],x=Math.sqrt((u-o)*(u-o)+(p-a)*(p-a)),h=(p-a)/x,d=(u-o)/x,g=x/s;if(g>1){for(let R=1;R<=g-1;R++){const S=R*s,l=d*S+o,f=h*S+a;i.push([l,f])}const b=(x+Math.floor(g-1)*s)/2,A=d*b+o,q=h*b+a;i.push([A,q])}i.push([u,p])}}return ne(e)?new z({rings:n,spatialReference:e.spatialReference}):new U({paths:n,spatialReference:e.spatialReference})}function J(e,s,c){if(s){const n=ie(e,1e6);e=V(n,!0)}return c&&(e=H(e,c)),e}function W(e,s,c){if(Array.isArray(e)){const n=e[0];if(n>s){const t=w(n,s);e[0]=n+t*(-2*s)}else if(n<c){const t=w(n,c);e[0]=n+t*(-2*c)}}else{const n=e.x;if(n>s){const t=w(n,s);e=e.clone().offset(t*(-2*s),0)}else if(n<c){const t=w(n,c);e=e.clone().offset(t*(-2*c),0)}}return e}function le(e,s){let c=-1;for(let n=0;n<s.cutIndexes.length;n++){const t=s.cutIndexes[n],i=s.geometries[n],r=L(i);for(let o=0;o<r.length;o++){const a=r[o];a.some(u=>{if(u[0]<180)return!0;{let p=0;for(let h=0;h<a.length;h++){const d=a[h][0];p=d>p?d:p}p=Number(p.toFixed(9));const x=-360*w(p,180);for(let h=0;h<a.length;h++){const d=i.getPoint(o,h);i.setPoint(o,h,d.clone().offset(x,0))}return!0}})}if(t===c){if(oe(e))for(const o of L(i))e[t]=e[t].addRing(o);else if(re(e))for(const o of L(i))e[t]=e[t].addPath(o)}else c=t,e[t]=i}return e}async function ce(e,s,c){if(!Array.isArray(e))return ce([e],s);s&&typeof s!="string"&&X().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:s?.url??E.geometryServiceUrl;let t,i,r,o,a,u,p,x,h=0;const d=[],g=[];for(const l of e)if(l!=null)if(t||(t=l.spatialReference,i=F(t),r=t.isWebMercator,u=r?102100:4326,o=I[u].maxX,a=I[u].minX,p=I[u].plus180Line,x=I[u].minus180Line),i)if(l.type==="mesh")g.push(l);else if(l.type==="point")g.push(W(l.clone(),o,a));else if(l.type==="multipoint"){const f=l.clone();f.points=f.points.map(m=>W(m,o,a)),g.push(f)}else if(l.type==="extent"){const f=l.clone()._normalize(!1,!1,i);g.push(f.rings?new z(f):f)}else if(l.extent){const f=l.extent,m=w(f.xmin,a)*(2*o);let $=m===0?l.clone():H(l.clone(),m);f.offset(m,0);let{xmin:M,xmax:y}=f;M=Number(M.toFixed(9)),y=Number(y.toFixed(9)),f.intersects(p)&&y!==o?(h=y>h?y:h,$=J($,r),d.push($),g.push("cut")):f.intersects(x)&&M!==a?(h=y*(2*o)>h?y*(2*o):h,$=J($,r,360),d.push($),g.push("cut")):g.push($)}else g.push(l.clone());else g.push(l);else g.push(l);let b=w(h,o),A=-90;const q=b,R=new U;for(;b>0;){const l=360*b-180;R.addPath([[l,A],[l,-1*A]]),A*=-1,b--}if(d.length>0&&q>0){const l=le(d,await te(n,d,R,c)),f=[],m=[];for(let y=0;y<g.length;y++){const N=g[y];if(N!=="cut")m.push(N);else{const j=l.shift(),P=e[y];P!=null&&P.type==="polygon"&&P.rings&&P.rings.length>1&&j.rings.length>=P.rings.length?(f.push(j),m.push("simplify")):m.push(r?v(j):j)}}if(!f.length)return m;const $=await se(n,f,c),M=[];for(let y=0;y<m.length;y++){const N=m[y];N!=="simplify"?M.push(N):M.push(r?v($.shift()):$.shift())}return M}const S=[];for(let l=0;l<g.length;l++){const f=g[l];if(f!=="cut")S.push(f);else{const m=d.shift();S.push(r===!0?v(m):m)}}return S}function pe(e,s,c){const n=F(c);if(n==null)return e;const[t,i]=n.valid,r=2*i;let o=0,a=0;s>i?o=Math.ceil(Math.abs(s-i)/r):s<t&&(o=-Math.ceil(Math.abs(s-t)/r)),e>i?a=Math.ceil(Math.abs(e-i)/r):e<t&&(a=-Math.ceil(Math.abs(e-t)/r));let u=e+(o-a)*r;const p=u-s;return p>i?u-=r:p<t&&(u+=r),u}function D(e){const s=F(e);if(s==null)return null;const[c,n]=s.valid;return new ee(c,n)}const he=D(C.WGS84);D(C.WebMercator);export{he as A,pe as L,ce as P};
