import{jK as In,f7 as An,bS as vt,jL as On,f8 as qe,ee as xt,jM as Rn,aZ as V,dL as te,jN as Tn,b8 as Tr,jO as Xt,b2 as zn,dv as Dn,du as jn,jP as Mn,eS as Fn,i as En,gr as Vn,gh as Bn,jQ as Ln,gD as Un,cJ as wt,cK as Ct,X as Ae,hb as Gn,a$ as zr,c as Zt,_ as C,z as L,A as Dr,$ as kn,jR as Nn,bl as Hn,a_ as qn,fD as Qn,s as Wn,fg as Yn,jj as Jn,g$ as Ft,gF as Xn,dG as jr,b1 as Mr,bO as Fr,bP as Le,hB as Zn,c3 as Kn,ef as ot,U as ei,as as ti,fL as ri,eZ as Er,cU as ni,em as ii,dO as Kt,fK as ai,S as er,c1 as si,bj as oi,eA as li}from"./MapPage-CALCogid.js";import{o as ci,N as di,W as ui}from"./projectionUtils-BKYS76qs.js";import{W as fi}from"./QueryEngine-DgCyHcvs.js";import{b as tr}from"./Query-BX_uPc1E.js";import{o as mi}from"./jsonUtils-C-tJ68sM.js";import{t as hi,s as Vr,e as $t,a as Br,r as pi,u as rr,n as tt}from"./vec4f64-CvoGn1-Y.js";import{o as gi,f as yi,h as rt,n as Lr,s as Ur,p as bi,r as _i}from"./mat4-C6_GXKaz.js";import{m as vi}from"./vec42-DeBO-Kwb.js";import{c as N,_ as lt,A as ee,o as W,s as O,E as U,g as E,r as J,p as Et,u as Y,R as xi,N as wi,P as ae,H as ct,K as Ci,j as nr}from"./vec32-CZ1FeckV.js";import"./MeshLocalVertexSpace-B8cww9B7.js";import{r as k,n as Vt}from"./vec2f64-DCcDeJvX.js";import{g as ir,f as ar,e as $i,j as sr,o as Si,i as or,k as Gr,l as Pi,m as Ii,p as Bt,r as St,q as Qe,u as Ai,v as Oi,w as kr,x as Nr,y as Ri,z as Ti,B as Hr,C as zi,D as Di,E as ji,F as Mi,G as Fi,H as Ei,I as lr,J as dt,K as cr,L as Vi,M as K,N as Bi,O as Li,Q as Ui,R as Gi,T as ki,U as Ni,V as Hi,W as qi,X as Qi,Y as qr,Z as Wi,$ as D,a0 as Yi,a1 as ut,a2 as Ji,a3 as Xi,a4 as Zi,a5 as Ki,a6 as ea,a7 as ta,a8 as ra,a9 as dr,aa as na,ab as ur,ac as fr,ad as ia,ae as aa,P as sa,c as oa,af as la,ag as ca,ah as da,ai as ua,aj as fa}from"./DefaultMaterial-C2bjE7KI.js";import{n as We}from"./projectVectorToVector-BXWPN1Kx.js";import{e as ma,A as ha}from"./Indices-j7lHvrVP.js";import{E as pa,N as ga,_ as mr}from"./enums-CVsE7NBb.js";import{t as q}from"./orientedBoundingBox-js1TSlrS.js";import{f as ya}from"./computeTranslationToOriginAndRotation-MJvxXlwx.js";import{r as Q,n as Re}from"./vec3f32-WCVSSNPR.js";import{c as A}from"./vectorStacks-BvGZr5ox.js";import{s as Lt,f as Ue,c as ba,A as _a,j as va,u as xa}from"./sphere-oIAQ6iUh.js";import{d as hr}from"./asyncUtils-Ckb32D-H.js";import{s as pr}from"./ReactiveMap-CMB2BSyY.js";import{s as xe,t as wa,n as Qr,a as Ca}from"./memoryEstimations-xc4IsuuC.js";import{s as $a,b as Wr}from"./PooledRBush-D16ylHFX.js";import{n as Sa,e as Pt}from"./OptimizedFeature-8eacwtCP.js";import{c as Pa}from"./query-CEM6sV_t.js";import{n as Ia}from"./pbf-Dx1r3pmv.js";import{u as Aa}from"./quantizationUtils-BnuTgpBn.js";import{Z as Oa}from"./FieldsIndex-CVtpKsGR.js";import{b as Ra,h as Ta}from"./pbfQueryUtils-BNeUB-7p.js";import{s as za,g as Da}from"./BufferView-2CheAP_D.js";import"./OperationalLayer-0Pv7ZrZV.js";import{_ as ja}from"./index-BNVKSZrb.js";import{Q as Yr,t as Ma}from"./InterleavedLayout-Cd80vy4J.js";import{a as Fa}from"./VertexAttributeLocations-W6y2attr.js";import{a as Ea}from"./spatialReferenceEllipsoidUtils-BGRhzcmI.js";import{i as Va}from"./projectPointToVector-D3SzrqhN.js";import{a as gr,M as Ba,v as La}from"./frustum-CD1wBBNH.js";import{j as Ut,I as It,d as Ua,k as Ye,G as Ga,R as ka,K as Jr,q as Na,O as Xr,y as Ha,L as qa,N as Qa}from"./plane-DhyorsBR.js";import{t as y,n as j}from"./glsl-B5bJgrnA.js";let X=class Zr{constructor(e,t,r){this.renderCommandContext=e,this.renderCommandBuffer=t,this.pipelineStateCommands=r}append(e){this.appendRenderCommands(e.renderCommandBuffer),this.appendPipelineStateCommands(e.pipelineStateCommands)}appendRenderCommands(e){this.renderCommandBuffer.commands.push(...e.commands),this.renderCommandBuffer.transferList.push(...e.transferList)}appendPipelineStateCommand(e){this.pipelineStateCommands.push(e)}appendPipelineStateCommands(e){for(const t of e)this.appendPipelineStateCommand(t)}async execute(){for(const e of this.pipelineStateCommands)e();await this.renderCommandContext.dispatchRenderCommands(this.renderCommandBuffer)}static create(e,t=[]){return new Zr(e,e.createRenderCommandBuffer(),t)}};function Wa(n){return n.length===0?null:n.reduce((e,t)=>(e.append(t),e))}function Kr(){return new In({material:new An({color:new vt("red")})})}function Ya(){return new On}function Ja(n,e,t=null){const r=hi(Vr);return n!=null&&(r[0]=n[0],r[1]=n[1],r[2]=n[2],n.length>3&&(r[3]=n[3])),e!=null&&(r[3]=e),t&&vi(r,r,t),r}function Xa(n=qe,e,t,r=1){const i=new Array(3);if(e==null||t==null)i[0]=1,i[1]=1,i[2]=1;else{let a,s=0;for(let o=2;o>=0;o--){const c=n[o],d=c!=null,f=o===0&&!a&&!d,l=t[o];let u;c==="symbol-value"||f?u=l!==0?e[o]/l:1:d&&c!=="proportional"&&isFinite(c)&&(u=l!==0?c/l:1),u!=null&&(i[o]=u,a=u,s=Math.max(s,Math.abs(u)))}for(let o=2;o>=0;o--)i[o]==null?i[o]=a:i[o]===0&&(i[o]=.001*s)}for(let a=2;a>=0;a--)i[a]/=r;return xt(i)}const Za=Object.freeze({"bottom-left":k(0,0),bottom:k(.5,0),"bottom-right":k(1,0),left:k(0,.5),center:k(.5,.5),right:k(1,.5),"top-left":k(0,1),top:k(.5,1),"top-right":k(1,1)});function Gt(n){const{featureCount:e}=n;if(e===0)return new Uint32Array;const t=new Uint32Array(e);return n.getObjectIdsArray(t),t}function At(n){const{featureCount:e}=n;if(e===0)return new Float64Array;const t=new Float64Array(3*e);return n.getCoordinatesArray(t),t}function Ka(n,e){const t=n.length/3,r=e.viewSpatialReference,i=e.renderSpatialReference,a=new Float64Array(3*t);if(!ci(n,r,0,a,i,0,t))throw new Error("Failed to project coordinates");return a}function yr(n,e){const t=e.viewSpatialReference,r=e.renderSpatialReference,{extent:i}=n,a=Rn(i),s=V();return We([a[0],a[1],0],t,s,r),s}function en(n){const e=new Map;for(const[t,r]of n)e.set(t,{...r,indices:ma(r.indices)});return e}const tn=128,ge=.5,es=$t(ge/2,ge/2,1-ge/2,1-ge/2);function ts(n){return n==="x"}function rs(n,e=tn,t=e*ge,r=0){return{data:ns(n,e,t,r),parameters:{mipmap:!1,wrap:{s:33071,t:33071},width:e,height:e,noUnpackFlip:!0,dataType:ga.FLOAT,pixelFormat:6403,internalFormat:pa.R16F,reloadable:!0}}}function ns(n,e=tn,t=e*ge,r=0){switch(n){case"circle":default:return is(e,t);case"square":return as(e,t);case"cross":return os(e,t,r);case"x":return ls(e,t,r);case"kite":return ss(e,t);case"triangle":return cs(e,t);case"arrow":return ds(e,t)}}function is(n,e){const t=n/2-.5;return Te(n,an(t,t,e/2))}function as(n,e){return rn(n,e,!1)}function ss(n,e){return rn(n,e,!0)}function os(n,e,t=0){return nn(n,e,!1,t)}function ls(n,e,t=0){return nn(n,e,!0,t)}function cs(n,e){return Te(n,sn(n/2,e,e/2))}function ds(n,e){const t=e,r=e/2,i=n/2,a=.8*t,s=an(i,(n-e)/2-a,Math.sqrt(a*a+r*r)),o=sn(i,t,r);return Te(n,(c,d)=>Math.max(o(c,d),-s(c,d)))}function rn(n,e,t){return t&&(e/=Math.SQRT2),Te(n,(r,i)=>{let a=r-.5*n+.25,s=.5*n-i-.75;if(t){const o=(a+s)/Math.SQRT2;s=(s-a)/Math.SQRT2,a=o}return Math.max(Math.abs(a),Math.abs(s))-.5*e})}function nn(n,e,t,r=0){e-=r,t&&(e*=Math.SQRT2);const i=.5*e;return Te(n,(a,s)=>{let o,c=a-.5*n,d=.5*n-s-1;if(t){const f=(c+d)/Math.SQRT2;d=(d-c)/Math.SQRT2,c=f}return c=Math.abs(c),d=Math.abs(d),o=c>d?c>i?Math.sqrt((c-i)*(c-i)+d*d):d:d>i?Math.sqrt(c*c+(d-i)*(d-i)):c,o-=r/2,o})}function an(n,e,t){return(r,i)=>{const a=r-n,s=i-e;return Math.sqrt(a*a+s*s)-t}}function sn(n,e,t){const r=Math.sqrt(e*e+t*t);return(i,a)=>{const s=Math.abs(i-n)-t,o=a-n+e/2+.75,c=(e*s+t*o)/r,d=-o;return Math.max(c,d)}}function Te(n,e){const t=new Float32Array(n*n);for(let r=0;r<n;r++)for(let i=0;i<n;i++)t[i+n*r]=e(i,r)/n;return t}let Ot=class{constructor(e,t){this._context=null,this._symbolLayer=null,this._draped=!1,this._loaded=!1,this._loadingPromise=null,this._iconTextureID=null,this._materialId=null,this._context=t,this._symbolLayer=e}get loaded(){return this._loaded}load(){return this._loadingPromise==null&&(this._loadingPromise=this._load()),this._loadingPromise}_destroy(){this._iconTextureID=null}async _load(){const e=this._context.renderCommandContext,t=await e.createTexture(()=>rs("circle"));this._iconTextureID=t;const r={anchorPosition:Za.center,occlusionTest:!0,hasSlicePlane:!1,color:this._getFillColor(),outlineColor:this._getOutlineColor(),outlineSize:1,distanceFieldBoundingBox:es,textureId:t,textureIsSignedDistanceField:!0,sampleSignedDistanceFieldTexelCenter:ts("circle")},i=new Uint8Array(8),a=0,s=255;i[0]=a,i[1]=a,i[2]=a,i[3]=s,i[4]=s,i[5]=a,i[6]=s,i[7]=s,this._materialId=await e.createMaterial({type:"hud",parameters:r}),await e.createDirectRenderer(this._materialId),await e.setBaseInstance(this._materialId,{data:i.buffer,elementCount:4}),this._loaded=!0}async createAddCommand(e){const{_materialId:t,_context:r}=this,{renderCommandContext:i}=r;if(t==null)throw new Error("expected material not to be null");const a=await this._createGeometry(e);if(a==null)return r.createPipelineCommand();const s=yr(e,r);return r.createPipelineCommand(i.addDirectRendererGeometry(e.id,a,s,!0))}async _createGeometry(e){const{_materialId:t,_context:r}=this,{mainThreadDelegate:i}=r,{featureCount:a}=e;if(a===0||t==null)return null;const s=Gt(e),o=At(e),c=await i.applyElevationAlignmentTo(o),d=Ka(c,r),f=new Float64Array([0,0,1]),l=new Float64Array([255,255,255,255]),u=new Float64Array([24,24]),p=new Float64Array([0,0,0,1]),_=new Float64Array([0]),w=new Uint32Array(a);for(let v=0;v<a;++v)w[v]=v;const m=new Uint32Array(a);for(let v=0;v<a;++v)m[v]=0;const g=[["position",new q(d,w,3,!0)],["normal",new q(f,m,3,!0)],["color",new q(l,m,4,!0)],["rotation",new q(_,m,1,!0)],["size",new q(u,m,2,!0)],["centerOffsetAndDistance",new q(p,m,4,!0)]],h=new Uint8Array(a);return e.getVisibilityArray(h),{attributes:en(g),olidColor:void 0,transformation:te(),materialId:t,objectIds:s,visibilities:h}}async createRemoveCommand(e){const{_materialId:t,_context:r}=this,i=r.renderCommandContext;return t==null?r.createPipelineCommand():r.createPipelineCommand(i.removeDirectRendererGeometryBuffer(t,e))}async createUpdateVisibilityCommand(e){const{_materialId:t,_context:r}=this,i=r.renderCommandContext;if(t==null)return r.createPipelineCommand();const a=new Uint8Array(e.featureCount);return e.getVisibilityArray(a),r.createPipelineCommand(i.updateVisibility(t,e.id,a))}async createUpdateLayerViewOpacityCommand(e){const{_context:t,_materialId:r}=this,i=t.renderCommandContext;return r==null?t.createPipelineCommand():t.createPipelineCommand(i.updateMaterial({type:"hud",materialId:r,parameters:{color:this._getFillColor(),outlineColor:this._getOutlineColor()}}))}async createUpdateElevationCommand(e){const{_materialId:t,_context:r}=this,{renderCommandContext:i}=r,{featureCount:a,id:s}=e;if(t==null||a===0)return r.createPipelineCommand();const o=await this._createGeometry(e);if(o==null)return r.createPipelineCommand();const c=yr(e,r);return r.createPipelineCommand(i.updateDirectRendererGeometry(s,o,c,!0))}async createDestroyCommand(){const{_iconTextureID:e,_context:t}=this,r=t.renderCommandContext;let i;return i=e!=null?await r.releaseTexture(e):X.create(r),i.appendPipelineStateCommand(()=>this._destroy()),i}_getOutlineColor(){const e=this._getLayerOpacity(),t=this._symbolLayer,r=t?.outline?.color;if(r!=null){const i=vt.toUnitRGB(r),a=r.a*e;return[i[0],i[1],i[2],a]}return[0,0,0,0]}_getFillColor(){if(us(this._getPrimitive()))return ms;const e=this._getPrimitive()==null,t=this._symbolLayer?.material?.color;return this._getCombinedOpacityAndColor(t,{hasIntrinsicColor:e})}_getLayerOpacity(){return this._context.layerViewInfo.fullOpacity}_getCombinedOpacity(e,t=br){const r=this._draped?1:this._getLayerOpacity();return e?r*e.a:t.hasIntrinsicColor?r:0}_getCombinedOpacityAndColor(e,t=br){const r=this._getCombinedOpacity(e,t),i=e!=null?vt.toUnitRGB(e):qe;return Ja(i,r)}_getPrimitive(){return fs(this._symbolLayer)}};function us(n){return n!=null&&(n==="cross"||n==="x")}function fs(n){return n.resource?.href?null:n.resource?.primitive??Tn}const br={hasIntrinsicColor:!1},ms=Br;let hs=class{constructor(e,t){this._loaded=!1,this._loadingPromise=null,this._context=null,this._symbol=null,this._symbolLayerRenderers=[],this._context=t,this._symbol=e}_destroy(){}get loaded(){return this._loaded}load(){return this._loadingPromise==null&&(this._loadingPromise=this._load()),this._loadingPromise}async _load(){const{_context:e,_symbol:t,_symbolLayerRenderers:r}=this,i=[];for(const a of t.symbolLayers){const s=e.symbolRendererFactory.createSymbolRendererFromSymbolLayer(a);s!=null&&(i.push(s.load()),r.push(s))}await Promise.all(i),this._loaded=!0}async createDestroyCommand(){const{_context:e,_symbolLayerRenderers:t}=this,r=[];for(const a of t)r.push(a.createDestroyCommand());const i=e.joinPipelineCommands(await Promise.all(r));return i.appendPipelineStateCommand(()=>this._destroy()),i}async createAddCommand(e){const{_context:t,_symbolLayerRenderers:r}=this,i=[];for(const a of r)i.push(a.createAddCommand(e));return t.joinPipelineCommands(await Promise.all(i))}async createRemoveCommand(e){const{_context:t,_symbolLayerRenderers:r}=this,i=[];for(const a of r)i.push(a.createRemoveCommand(e));return t.joinPipelineCommands(await Promise.all(i))}async createUpdateVisibilityCommand(e){const{_context:t,_symbolLayerRenderers:r}=this,i=[];for(const a of r)i.push(a.createUpdateVisibilityCommand(e));return t.joinPipelineCommands(await Promise.all(i))}async createUpdateLayerViewOpacityCommand(e){const{_context:t,_symbolLayerRenderers:r}=this,i=[];for(const a of r)i.push(a.createUpdateLayerViewOpacityCommand(e));return t.joinPipelineCommands(await Promise.all(i))}async createUpdateElevationCommand(e){const{_context:t,_symbolLayerRenderers:r}=this,i=[];for(const a of r)i.push(a.createUpdateElevationCommand(e));return t.joinPipelineCommands(await Promise.all(i))}},ps=class{constructor(e,t){this._symbol=null,this._featureData=new Map,this._loaded=!1,this._loadingPromise=null,this._renderer=null,this._context=t,this._renderer=e}async load(){return this._loadingPromise==null&&(this._loadingPromise=this._load()),this._loadingPromise}async _load(){const{_renderer:e,_context:t}=this;this._symbol=t.symbolRendererFactory.createSymbolRendererFromSymbol(e.symbol),this._loaded=!0}get loaded(){return this._loaded}async createAddCommand(e){const t=this._context,r=await this._provisionSymbol(),i=r==null?t.createPipelineCommand():await r.createAddCommand(e);return i.appendPipelineStateCommand(()=>this._featureData.set(e.id,e)),i}async createRemoveCommand(e){const t=this._context,r=await this._provisionSymbol(),i=r==null?t.createPipelineCommand():await r.createRemoveCommand(e);return i.appendPipelineStateCommand(()=>this._featureData.delete(e)),i}async createUpdateVisibilityCommand(e){const t=this._context,r=await this._provisionSymbol();return r==null?t.createPipelineCommand():await r.createUpdateVisibilityCommand(e)}async createUpdateLayerViewOpacityCommand(e){const t=this._context,r=await this._provisionSymbol();return r==null?t.createPipelineCommand():await r.createUpdateLayerViewOpacityCommand(e)}async createUpdateElevationCommand(){const{_featureData:e,_context:t}=this,r=await this._provisionSymbol();if(r==null)return t.createPipelineCommand();const i=[];for(const s of e.values())i.push(r.createUpdateElevationCommand(s));const a=await Promise.all(i);return t.joinPipelineCommands(a)}async createDestroyCommand(){const{_symbol:e,_context:t,_featureData:r}=this;if(!e)return t.createPipelineCommand();const i=[];for(const s of r.keys())i.push(this.createRemoveCommand(s));i.push(e.createDestroyCommand());const a=await Promise.all(i);return t.joinPipelineCommands(a)}async _provisionSymbol(){const e=this._symbol;return e?(e.loaded||await e.load(),e):null}};function _r(n,e){const t=n[e],r=n[e+1],i=n[e+2];return Math.sqrt(t*t+r*r+i*i)}function gs(n,e){const t=n[e],r=n[e+1],i=n[e+2],a=1/Math.sqrt(t*t+r*r+i*i);n[e]*=a,n[e+1]*=a,n[e+2]*=a}function vr(n,e,t){n[e]*=t,n[e+1]*=t,n[e+2]*=t}function ys(n,e,t,r,i,a=e){(i=i||n)[a]=n[e]+t[r],i[a+1]=n[e+1]+t[r+1],i[a+2]=n[e+2]+t[r+2]}const bs=new Array(36);for(let n=0;n<6;n++)for(let e=0;e<6;e++)bs[6*n+e]=n;const oe=new Array(36);for(let n=0;n<6;n++)oe[6*n]=0,oe[6*n+1]=1,oe[6*n+2]=2,oe[6*n+3]=2,oe[6*n+4]=3,oe[6*n+5]=0;const ft=Q(-.5,0,-.5),mt=Q(.5,0,-.5),ht=Q(0,0,.5),pt=Q(0,.5,0),le=Re(),ce=Re(),ye=Re(),be=Re(),_e=Re();N(le,ft,pt),N(ce,ft,mt),lt(ye,le,ce),ee(ye,ye),N(le,mt,pt),N(ce,mt,ht),lt(be,le,ce),ee(be,be),N(le,ht,pt),N(ce,ht,ft),lt(_e,le,ce),ee(_e,_e);ye[0],ye[1],ye[2],be[0],be[1],be[2],_e[0],_e[1],_e[2];function _s(n,e,t){let r,i;r=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],i=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];for(let c=0;c<r.length;c+=3)vr(r,c,n/_r(r,c));let a={};function s(c,d){c>d&&([c,d]=[d,c]);const f=c.toString()+"."+d.toString();if(a[f])return a[f];let l=r.length;return r.length+=3,ys(r,3*c,r,3*d,r,l),vr(r,l,n/_r(r,l)),l/=3,a[f]=l,l}for(let c=0;c<e;c++){const d=i.length,f=new Array(4*d);for(let l=0;l<d;l+=3){const u=i[l],p=i[l+1],_=i[l+2],w=s(u,p),m=s(p,_),g=s(_,u),h=4*l;f[h]=u,f[h+1]=w,f[h+2]=g,f[h+3]=p,f[h+4]=m,f[h+5]=w,f[h+6]=_,f[h+7]=g,f[h+8]=m,f[h+9]=w,f[h+10]=m,f[h+11]=g}i=f,a={}}const o=ir(r);for(let c=0;c<o.length;c+=3)gs(o,c);return[["position",new q(ir(r),i,3,!0)],["normal",new q(o,i,3,!0)]]}function vs(n,e,t,r,i=!0,a=!0){let s=0;const o=e,c=n;let d=Q(0,s,0),f=Q(0,s+c,0),l=Q(0,-1,0),u=Q(0,1,0);const p=[f,d],_=[l,u],w=t+2,m=Math.sqrt(c*c+o*o);for(let b=0;b<t;b++){const z=b*(2*Math.PI/t),M=Q(Math.cos(z)*o,s,Math.sin(z)*o);p.push(M);const x=Q(c*Math.cos(z)/m,o/m,c*Math.sin(z)/m);_.push(x)}const g=new Array,h=new Array;if(i){for(let b=3;b<p.length;b++)g.push(1),g.push(b-1),g.push(b),h.push(0),h.push(0),h.push(0);g.push(p.length-1),g.push(2),g.push(1),h.push(0),h.push(0),h.push(0)}if(a){for(let b=3;b<p.length;b++)g.push(b),g.push(b-1),g.push(0),h.push(b),h.push(b-1),h.push(1);g.push(0),g.push(2),g.push(p.length-1),h.push(1),h.push(2),h.push(_.length-1)}const v=ar(3*w);for(let b=0;b<w;b++)v[3*b]=p[b][0],v[3*b+1]=p[b][1],v[3*b+2]=p[b][2];const P=ar(3*w);for(let b=0;b<w;b++)P[3*b]=_[b][0],P[3*b+1]=_[b][1],P[3*b+2]=_[b][2];return[["position",new q(v,g,3,!0)],["normal",new q(P,h,3,!0)]]}function xs(n){switch(n){case"sphere":case"cube":case"diamond":case"cylinder":case"cone":case"inverted-cone":case"tetrahedron":return!0}return!1}function ws(n,e){const t=(r,i,a=!1)=>({levels:r.map(s=>{const o=en(i(s.tesselation));return a&&Cs(o),{components:[{attributes:o,olidColor:void 0,transformation:null,materialId:e,visibilities:new Uint8Array([1]),objectIds:new Uint32Array([-1])}],minScreenSpaceRadius:s.minScreenSpaceRadius}})});switch(n){case"cone":return t($s,r=>vs(1,.5,r),!0);case"sphere":return t([{tesselation:0,minScreenSpaceRadius:0},{tesselation:1,minScreenSpaceRadius:8},{tesselation:2,minScreenSpaceRadius:16},{tesselation:3,minScreenSpaceRadius:50},{tesselation:4,minScreenSpaceRadius:250}],r=>_s(.5,r));case"cube":case"inverted-cone":case"cylinder":case"tetrahedron":case"diamond":throw new Error("not implemented");default:return}}function Cs(n){const e=n,t=e.get("position").data,r=e.get("normal").data;if(r){const i=xr(n,"normal").data;for(let a=0;a<r.length;a+=3){const s=r[a+1];i[a+1]=-r[a+2],i[a+2]=s}}if(t){const i=xr(n,"position").data;for(let a=0;a<t.length;a+=3){const s=t[a+1];i[a+1]=-t[a+2],i[a+2]=s}}}function xr(n,e){let t=n.get(e);return t&&!t.exclusive&&(t={...t,exclusive:!0,data:$i(t.data)},n.set(e,t)),t}const $s=[{tesselation:6,minScreenSpaceRadius:0},{tesselation:18,minScreenSpaceRadius:7},{tesselation:64,minScreenSpaceRadius:65}];function Ss(n,e,t){if(!e.vvSize)return W(n,1,1,1),n;if(Number.isNaN(t[0]))return O(n,e.vvSize.fallback);for(let r=0;r<3;++r){const i=e.vvSize.offset[r]+t[0]*e.vvSize.factor[r];n[r]=Tr(i,e.vvSize.minSize[r],e.vvSize.maxSize[r])}return n}let Ps=class{constructor(e,t){this._loaded=!1,this._loadingPromise=null,this._primitiveMaterialId=null,this._lodRendererId=null,this._context=null,this._symbolLayer=null,this._primitive=null,this._context=t,this._symbolLayer=e}_destroy(){this._lodRendererId=null,this._primitiveMaterialId=null}get loaded(){return this._loaded}get _isPrimitive(){return this._primitive!=null}load(){return this._loadingPromise==null&&(this._loadingPromise=this._load()),this._loadingPromise}async _load(){const e=this._context.renderCommandContext,t={physicalBasedRenderingEnabled:!0,slicePlaneEnabled:!1,castShadows:!0},r=this._getLayerOpacity();let i={usePBR:t.physicalBasedRenderingEnabled,isSchematic:!0,mrrFactors:Si,ambient:qe,diffuse:qe,hasSlicePlane:t.slicePlaneEnabled,castShadows:t.castShadows,layerOpacity:r,offsetTransparentBackfaces:!1,screenSizePerspective:{}};if(i.externalColor=Vr,i.instanced=!0,this._isPrimitive){const c=new sr;c.layerOpacity=r,i={...i,cullFace:wr(or(c))}}const a=await e.createMaterial({type:"default",parameters:i}),s=this._symbolLayer.resource;this._primitive=s&&xs(s?.primitive)?s.primitive:Xt;const o=ws(this._primitive,a);this._lodRendererId=await e.createLodRenderer(o),this._primitiveMaterialId=a,this._loaded=!0}async createDestroyCommand(){const{_lodRendererId:e,_primitiveMaterialId:t,_context:r}=this,i=r.renderCommandContext,a=[];return e!=null&&a.push(i.destroyLodRenderer(e)),t!=null&&a.push(i.destroyMaterial(t)),new X(i,i.mergeRenderCommandBuffers(a),[()=>this._destroy()])}async createAddCommand(e){const t=this._context,{renderCommandContext:r,mainThreadDelegate:i}=t;if(this._lodRendererId==null)throw new Error("expected lod renderer id to not be null");const{featureCount:a}=e;if(a===0)return t.createPipelineCommand();const s=this._isPrimitive,o=this._primitive||Xt,c=zn(Dn(o)),d=xt(jn(c)),f=xt(Mn(d,{isPrimitive:s,width:100,depth:null,height:null})),l=new Float64Array(16*a),u=new Float64Array(16*a),p=At(e),_=await i.applyElevationAlignmentTo(p);for(let h=0;h<a;++h){const v=h,P=_[3*h+0],b=_[3*h+1],z=_[3*h+2],M=this._computeGlobalTransform(P,b,z,this._context.viewSpatialReference,Cr),x=this._computeLocalTransform(f,d,Is);this._writeMatrixToTypedBuffer(l,v,x),this._writeMatrixToTypedBuffer(u,v,M)}const w=Gt(e),m=new Uint8Array(a);e.getVisibilityArray(m);const g={featureIds:new Uint32Array(w),visibility:m,localTransforms:l,globalTransforms:u};return t.createPipelineCommand(r.addLodInstances(this._lodRendererId,e.id,g))}async createRemoveCommand(e){const{_context:t,_lodRendererId:r}=this,i=t.renderCommandContext;return r==null?t.createPipelineCommand():t.createPipelineCommand(i.removeLodInstances(r,e))}async createUpdateVisibilityCommand(e){const{_lodRendererId:t,_context:r}=this,i=r.renderCommandContext;if(t==null)return r.createPipelineCommand();const a=new Uint8Array(e.featureCount);return e.getVisibilityArray(a),r.createPipelineCommand(i.updateVisibility(t,e.id,a))}async createUpdateLayerViewOpacityCommand(e){const{_context:t}=this,r=t.renderCommandContext,i=this._primitiveMaterialId;if(i==null)return t.createPipelineCommand();const a=this._getLayerOpacity();let s={layerOpacity:a};if(this._isPrimitive){const o=new sr;o.layerOpacity=a,s={...s,cullFace:wr(or(o))}}return t.createPipelineCommand(r.updateMaterial({type:"default",materialId:i,parameters:s}))}async createUpdateElevationCommand(e){const{_context:t,_lodRendererId:r}=this,{renderCommandContext:i,mainThreadDelegate:a}=t,{featureCount:s,id:o}=e;if(r==null||s===0)return t.createPipelineCommand();const c=new Float64Array(16*s),d=At(e),f=await a.applyElevationAlignmentTo(d);for(let l=0;l<s;++l){const u=l,p=f[3*l+0],_=f[3*l+1],w=f[3*l+2],m=this._computeGlobalTransform(p,_,w,this._context.viewSpatialReference,Cr);this._writeMatrixToTypedBuffer(c,u,m)}return t.createPipelineCommand(i.updateLodInstancesData(r,o,c))}_writeMatrixToTypedBuffer(e,t,r){let i=16*t;for(let a=0;a<16;a++)e[i++]=r[a]}_computeGlobalTransform(e,t,r,i,a){return Me[0]=e,Me[1]=t,Me[2]=r,ya(i,Me,a,this._context.renderSpatialReference),a}_computeLocalTransform(e,t,r){return gi(r),this._applyObjectScale(e,t,r),r}_applyObjectScale(e,t,r){const i=Xa(e,e,t,this._context.renderCoordsHelper.unitInMeters);i[0]===1&&i[1]===1&&i[2]===1||yi(r,r,i)}_getLayerOpacity(){return this._context.layerViewInfo.fullOpacity}};function wr(n){return n?0:2}const Me=V(),Is=te(),Cr=te();let As=class{constructor(e,t){this._symbols=new Array,this._featureDataPartitioning=new Map,this._loaded=!1,this._loadingPromise=null,this._renderer=null,this._context=t,this._renderer=e}async load(){return this._loadingPromise==null&&(this._loadingPromise=this._load()),this._loadingPromise}async _load(){this._symbols[0]=new Ot(Kr(),this._context),this._symbols[1]=new Ps(Ya(),this._context),this._loaded=!0}get loaded(){return this._loaded}async createAddCommand(e){const t=this._context,r=this._partition(e),i=await Promise.all(r.map(async({index:s,features:o})=>await(await this._provisionSymbol(s))?.createAddCommand(o))),a=t.joinPipelineCommands(i);return a.appendPipelineStateCommand(()=>this._featureDataPartitioning.set(e.id,r)),a}async createRemoveCommand(e){const{_featureDataPartitioning:t,_context:r}=this,i=r.renderCommandContext,a=t.get(e);if(a==null)return new X(i,i.createRenderCommandBuffer(),[]);const s=await Promise.all(a.map(async({index:c,features:d})=>await this._getLoadedSymbol(c)?.createRemoveCommand(d.id))),o=r.joinPipelineCommands(s);return o.appendPipelineStateCommand(()=>t.delete(e)),o}async createUpdateVisibilityCommand(e){const{_featureDataPartitioning:t,_context:r}=this,i=r.renderCommandContext,a=t.get(e.id);if(a==null)return new X(i,i.createRenderCommandBuffer(),[]);const s=await Promise.all(a.map(async({index:o,features:c})=>await this._getLoadedSymbol(o)?.createUpdateVisibilityCommand(c)));return r.joinPipelineCommands(s)}async createUpdateLayerViewOpacityCommand(e){const t=this._context,r=[];for(let a=0;a<this._symbols.length;++a){const s=this._symbols[a];s!=null&&s.loaded&&r.push(s.createUpdateLayerViewOpacityCommand(e))}const i=await Promise.all(r);return t.joinPipelineCommands(i)}async createUpdateElevationCommand(){const{_featureDataPartitioning:e,_context:t}=this,r=[];for(const a of e.values()){const s=a.map(async({index:o,features:c})=>await this._getLoadedSymbol(o)?.createUpdateElevationCommand(c));r.push(...s)}const i=await Promise.all(r);return t.joinPipelineCommands(i)}async createDestroyCommand(){const{_featureDataPartitioning:e,_context:t}=this,r=[];for(const a of e.keys())r.push(this.createRemoveCommand(a));for(const a of this._symbols)r.push(a.createDestroyCommand());const i=await Promise.all(r);return t.joinPipelineCommands(i)}async _provisionSymbol(e){if(e==null)return null;const t=this._symbols[e];return t?(t.loaded||await t.load(),t):null}_getLoadedSymbol(e){if(e==null)return null;const t=this._symbols[e];return t!=null&&t.loaded?t:null}_partition(e){const t=Gt(e);if(t==null)throw new Error("unable to fetch objectIds");const{featureCount:r}=e,i=[[],[]];for(let a=0;a<r;++a)i[t[a]%2].push(a);return i.map((a,s)=>new Os(s,e.subset(new Uint32Array(a)))).filter(a=>a.features.featureCount>0)}},Os=class{constructor(e,t){this.index=e,this.features=t}},Rs=class{constructor(e,t,r,i,a,s,o){this.viewSpatialReference=e,this.renderSpatialReference=t,this.mainThreadDelegate=r,this.renderCoordsHelper=i,this.renderCommandContext=a,this.layerInfo=s,this.layerViewInfo=o,this.symbolRendererFactory=new Ts(this)}createPipelineCommand(e=this.renderCommandContext.createRenderCommandBuffer(),t=[]){return new X(this.renderCommandContext,e,t)}joinPipelineCommands(e){return e.length===0?this.createPipelineCommand():e.filter(t=>t!=null).reduce((t,r)=>(t.append(r),t))}},Ts=class{constructor(e){this.context=e}createSymbolRendererFromJSON(e){const t=mi(e??$r)??void 0;if(!t)throw new Error("Failed to create renderer");const r=t.type;switch(r){case"simple":return new ps(t,this.context);case"unique-value":return new As(t,this.context);default:return console.warn(`Unable to create symbolrenderer for renderer of ${r}`),this.createSymbolRendererFromJSON($r)}}createSymbolRendererFromSymbol(e){const t=e?.type;switch(t){case"point-3d":return new hs(e,this.context);case"picture-marker":case"simple-marker":return new Ot(Kr(),this.context);default:return console.warn(`Unable to create symbolrenderer for symbol of ${t}`),null}}createSymbolRendererFromSymbolLayer(e){const t=e.type;return t==="icon"?new Ot(e,this.context):(console.warn(`Unable to create symbolrenderer for symbolLayer of ${t}`),null)}};const $r={type:"simple"};function Je(n=""){return`${n}${Fn()}`}let zs=class on{constructor(e,t){this._parent=e,this._subsetIndices=t,this.id=Je(`featureDataSubset-${e.id}-`)}get tileId(){return this._parent.tileId}get extent(){return this._parent.extent}get featureCount(){return this._subsetIndices.length}get usedMemory(){return this._parent.usedMemory+xe+this._subsetIndices.byteLength}get isFullyEnabled(){for(const e of this._subsetIndices)if(!this._parent.getEnabled(e))return!1;return!0}getObjectId(e){return this._parent.getObjectId(this._subsetIndices[e])}getAttribute(e,t){return this._parent.getAttribute(this._subsetIndices[e],t)}getAttributeAsTimestamp(e,t){return this._parent.getAttribute(this._subsetIndices[e],t)}getAttributes(e){return this._parent.getAttributes(this._subsetIndices[e])}getCoordinates(e,t,r){return this._parent.getCoordinates(this._subsetIndices[e],t,r)}getOptimizedGeometry(e){return this._parent.getOptimizedGeometry(this._subsetIndices[e])}getCentroid(e,t){return this._parent.getCentroid(this._subsetIndices[e],t)}getBounds(e){return this._parent.getBounds(this._subsetIndices[e])}getBoundingBox(e){return this._parent.getBoundingBox(this._subsetIndices[e])}getObjectIdsArray(e,t,r){return this._parent.getObjectIdsArray(e,this._translatedIndices(t),r)}getCoordinatesArray(e,t,r){return this._parent.getCoordinatesArray(e,this._translatedIndices(t),r)}objectIds(e){return this._parent.objectIds(this._translatedIndices(e))}subset(e){const{_subsetIndices:t}=this,r=new Uint32Array(e.length);for(let i=0;i<r.length;++i)r[i]=t[e[i]];return new on(this._parent,r)}disableObjectIds(e){if(e.size===0)return;const{featureCount:t}=this,r=new Array;for(let i=0;i<t;++i)this.getEnabled(i)&&e.has(this.getObjectId(i))&&r.push(i);if(r.length!==0)for(const i of r)this.setEnabled(i,!1)}setEnabled(e,t){this._parent.setEnabled(this._subsetIndices[e],t)}getEnabled(e){return this._parent.getEnabled(this._subsetIndices[e])}enableAll(){const{_subsetIndices:e,_parent:t}=this;for(const r of e)t.setEnabled(r,!0)}getVisibilityArray(e,t,r){return this._parent.getVisibilityArray(e,this._translatedIndices(t),r)}enabledObjectIds(e){return this._parent.enabledObjectIds(this._translatedIndices(e))}*_translatedIndices(e){const{_subsetIndices:t}=this;if(e!=null)for(const r of e)yield t[r];else yield*t}};class Ds{constructor(e){this._tile=e,this.id=Je(`featureData-${e.id}-`),this._enabled=new Array(e.featureCount).fill(!0)}get tileId(){return this._tile.id}get featureCount(){return this._tile.featureCount}get usedMemory(){return xe+wa(this.id)}get extent(){return this._tile.descriptor.extent}get isFullyEnabled(){return this._enabled.every(e=>e)}getObjectId(e){return this._tile.getObjectId(e)}getAttribute(e,t){return this._tile.getAttribute(e,t)}getAttributeAsTimestamp(e,t){return this._tile.getAttribute(e,t)}getAttributes(e){return this._tile.getAttributes(e)}getCoordinates(e,t,r){return this._tile.getCoordinates(e,t,r)}getOptimizedGeometry(e){return this._tile.getOptimizedGeometry(e)}getCentroid(e,t){return this._tile.getCentroid(e,t)}getBounds(e){return this._tile.getBounds(e)}getBoundingBox(e){return this._tile.getBoundingBox(e)}getObjectIdsArray(e,t,r){return this._tile.getObjectIdsArray(e,t,r)}getCoordinatesArray(e,t,r){return this._tile.getCoordinatesArray(e,t,r)}objectIds(e){return this._tile.objectIds(e)}subset(e){return new zs(this,e)}disableObjectIds(e){if(e.size===0)return;const{_enabled:t}=this,r=new Array;for(const i of this._allFeatureIndices())t[i]&&e.has(this.getObjectId(i))&&r.push(i);if(r.length!==0)for(const i of r)t[i]=!1}setEnabled(e,t){this._enabled[e]=t}getEnabled(e){return this._enabled[e]}enableAll(){this._enabled.fill(!0)}getVisibilityArray(e,t=this._allFeatureIndices(),r=0){const{_enabled:i}=this;for(const a of t)e[r++]=Number(i[a]);return r}*enabledObjectIds(e=this._allFeatureIndices()){const{_enabled:t}=this;for(const r of e)t[r]&&(yield this.getObjectId(r))}*_allFeatureIndices(){const{featureCount:e}=this;for(let t=0;t<e;++t)yield t}}let B=class extends En{constructor(n){super(n),this.extent=null,this._tileHandles=new pr,this._wanted=new pr,this._updateRequested=!1,this._synchronizationTask=null,this._requestedTiles=new Array}destroy(){this._tileHandles.clear(),this._wanted.clear()}get updating(){return this._updateRequested||!(this._synchronizationTask?.finished??1)}get _boundingRect(){const{extent:n}=this;return n==null?null:Vn(n)}get _missingTiles(){const n=new Array,e=this._wanted,t=this._tileHandles;for(const r of e.values())t.get(r.id)?.featureData==null&&n.push(r);return n}onTileTreeChange({tiles:n}){this._requestedTiles=n,this._scheduleTilesSync()}_scheduleTilesSync(){if(this._updateRequested)return;this._updateRequested=!0;const n=this._synchronizationTask,e=hr(async()=>{try{await Bn(()=>n?.finished??!0),await Ln(),this._updateRequested=!1,await this._synchronizeTiles()}finally{this._synchronizationTask===e&&(this._synchronizationTask=null)}});this._synchronizationTask=e}async _synchronizeTiles(){const n=this._requestedTiles,e=this._tileHandles,t=new Array;for(const l of n)e.has(l.id)||t.push(l);const r=new Array;for(const l of e.values()){const{id:u}=l;n.every(p=>p.id!==u)&&r.push(l.descriptor)}const i=this._tileHandles,{_boundingRect:a}=this,s=a!=null?t.filter(l=>!l.extent||Un(a,l.extent)):t,o=this._wanted,c=new Array;for(const{id:l}of r)o.delete(l);for(const l of s)o.set(l.id,l);const d=this._missingTiles;for(const l of r){const{id:u}=l;if(d.some(_=>de(_,l)||de(l,_)))continue;const p=i.get(u);p!=null&&c.push(this._removeTile(p))}for(const l of s)c.push(this._addTile(l));const f=await Promise.allSettled(c);for(const l of f)l.status==="rejected"&&console.error(l.reason)}forEachTile(n){for(const e of this._tileHandles.values()){const t=e.featureData;t!=null&&n(t)}}*loadedTiles(){for(const n of this._tileHandles.values()){const e=n.featureData;e!=null&&(yield e)}}async _removeTile(n){n.loadTask.abort(),this._tileHandles.delete(n.id),this._validate();const{featureData:e}=n;if(e!=null){const t={stack:[],error:void 0,hasError:!1};try{wt(t,await this.tileLocks.lock([e.tileId]),!1),await(await this.createRemoveCommand(e.id))?.execute()}catch(r){t.error=r,t.hasError=!0}finally{Ct(t)}}}async _addTile(n){const{_tileHandles:e}=this,t=e.get(n.id);if(t!=null)return!Ge(t)||t.featureData.isFullyEnabled?void 0:(t.featureData.enableAll(),void await this._onTileLoad(t));const r=new js(n,hr(async i=>{const a=await this.loadTile(n,i);return Ae(i),new Ds(a)}));this._tileHandles.set(r.id,r);try{await r.loadTask.promise}catch(i){return void Gn(i)}Ms(r),await this._onTileLoad(r)}async _onTileLoad(n){const e={stack:[],error:void 0,hasError:!1};try{const{_wanted:t,_tileHandles:r,_missingTiles:i}=this,a=n.descriptor,s=new Array,o=new Array,c=new Array,d=new Set;for(const m of r.values()){if(m===n)continue;const{descriptor:g,id:h}=m;if(!(t.has(h)||i.some(v=>de(v,g)||de(g,v)))){r.delete(h),m.loadTask.abort();const{featureData:v}=m;v!=null&&s.push(v);continue}if(Ge(m)){if(de(a,g)){const v=m.featureData;for(const P of v.objectIds())d.add(P)}if(de(g,a)){const{featureData:v}=m;o.push(v)}}}d.size>0&&(n.featureData.disableObjectIds(d),this._validateRemoval(n.featureData,d)),this._validate(),c.push(n.featureData);const f=[...c,...s,...o].map(m=>m.tileId);if(wt(e,await this.tileLocks.lock(f),!1),o.length!==0){const m=n.featureData,g=new Set(m.objectIds());for(const h of o)h.disableObjectIds(g),this._validateRemoval(h,g)}const l=s.map(m=>this.createRemoveCommand(m.id)),u=c.map(m=>this.createAddCommand(m)),p=o.map(m=>this.createUpdateCommand(m)),_=await Promise.all([...l,...u,...p]);await Wa(_.filter(zr))?.execute()}catch(t){e.error=t,e.hasError=!0}finally{Ct(e)}}_validate(){if(!Zt("feature-pipeline-3d-test-validation"))return;const n=new Array;for(const e of this._tileHandles.values()){if(!Ge(e))continue;const{featureData:t}=e;n.push({featureData:t,objectIds:new Set(t.enabledObjectIds())})}for(let e=0;e<n.length;++e){const{featureData:t,objectIds:r}=n[e];for(let i=e+1;i<n.length;++i){const{featureData:a,objectIds:s}=n[i];for(const o of s)if(r.has(o))throw new Error(`${t.id} and ${a.id} both contain ${o}.`)}}}_validateRemoval(n,e){if(Zt("feature-pipeline-3d-test-validation")){for(const t of n.enabledObjectIds())if(e.has(t))throw new Error(`Failed to remove ${t} from ${n.id}!`)}}};function de({lij:[n,e,t]},{lij:[r,i,a]}){const s=r-n;return s>=0&&e===i>>s&&t===a>>s}C([L()],B.prototype,"updating",null),C([L({constructOnly:!0})],B.prototype,"loadTile",void 0),C([L({constructOnly:!0})],B.prototype,"createAddCommand",void 0),C([L({constructOnly:!0})],B.prototype,"createRemoveCommand",void 0),C([L({constructOnly:!0})],B.prototype,"createUpdateCommand",void 0),C([L({constructOnly:!0})],B.prototype,"tileLocks",void 0),C([L()],B.prototype,"extent",void 0),C([L()],B.prototype,"_boundingRect",null),C([L()],B.prototype,"_missingTiles",null),C([L()],B.prototype,"_updateRequested",void 0),C([L()],B.prototype,"_synchronizationTask",void 0),B=C([Dr("esri.views.3d.layers.graphics.pipeline.Tile3DManager")],B);let js=class{constructor(e,t){this.descriptor=e,this.loadTask=t}get id(){return this.descriptor.id}get featureData(){return this.loadTask.value}};function Ge(n){return n.featureData!=null}function Ms(n){if(!Ge(n))throw new Error}let Fs=class{constructor(){this._previousActions=new Map}async lock(e){const{_previousActions:t}=this,r=e.map(c=>t.get(c)).filter(zr),i=Promise.allSettled(r),a=kn(),s=Hn(()=>a.resolve()),o=a.promise.finally(()=>{for(const c of e)t.get(c)===o&&t.delete(c)});for(const c of e)t.set(c,o);return await i,Nn(s)}},Rt=class{constructor(e,t){this._index=e,this._view=t}get usedMemory(){return xe+Qr}getObjectId(){return this._view.getObjectId(this._index)}getAttribute(e){return this._view.getAttribute(this._index,e)}getAttributeAsTimestamp(e){return this._view.getAttributeAsTimestamp(this._index,e)}getAttributes(){return this._view.getAttributes(this._index)}getOptimizedGeometry(){return this._view.getOptimizedGeometry(this._index)}getCentroid(e){return this._view.getCentroid(this._index,e)}getBounds(){return this._view.getBounds(this._index)}getBoundingBox(){return this._view.getBoundingBox(this._index)}cloneWithGeometry(e){return new Es(this._index,this._view,e)}},Es=class extends Rt{constructor(e,t,r){super(e,t),this._geometryOverride=r}getOptimizedGeometry(){return this._geometryOverride}getCentroid(e){return Sa(new Pt,this._geometryOverride,e.hasZ,e.hasM)}},Vs=class{constructor(e,t){this.featureData=e,this.bounds=t}},Bs=class{constructor(){this._tileBounds=new Map,this.events=new qn,this.featureAdapter=Ls.shared}get usedMemory(){return xe+xe*this._tileBounds.size}addTile(e){const{featureCount:t}=e;if(t===0)return;const r=new $a(9,a=>e.getBounds(a)),i=new Array;for(let a=0;a<t;++a)i[a]=a;r.load(i),this._tileBounds.set(e.id,new Vs(e,r)),this.events.emit("changed")}removeTile(e){this._tileBounds.delete(e),this.events.emit("changed")}clear(){this._tileBounds.clear(),this.events.emit("changed")}forEach(e){for(const{featureData:t,bounds:r}of this._tileBounds.values())r.all(i=>{t.getEnabled(i)&&e(new Rt(i,t))})}forEachInBounds(e,t){Se.minX=e[0],Se.minY=e[1],Se.maxX=e[2],Se.maxY=e[3];for(const{featureData:r,bounds:i}of this._tileBounds.values())i.search(Se,a=>{r.getEnabled(a)&&t(new Rt(a,r))})}forEachBounds(e,t){for(const r of e)t(r.getBoundingBox())}getFullExtent(e){let t=1/0,r=1/0,i=-1/0,a=-1/0;for(const{bounds:s}of this._tileBounds.values()){const{minX:o,minY:c,maxX:d,maxY:f}=s.toJSON();t=Math.min(t,o),r=Math.min(r,c),i=Math.min(i,d),a=Math.min(a,f)}return{xmin:t,ymin:r,xmax:i,ymax:a,spatialReference:e}}};var se;let Ls=(se=class{getObjectId(e){return e.getObjectId()}getAttribute(e,t){return e.getAttribute(t)}getAttributeAsTimestamp(e,t){return e.getAttributeAsTimestamp(t)}getAttributes(e){return e.getAttributes()}getGeometry(e){return e.getOptimizedGeometry()}getCentroid(e,t){return e.getCentroid(t)}cloneWithGeometry(e,t){return e.cloneWithGeometry(t)}},se.shared=new se,se);const Se=new Wr;let Us=class{constructor(e,t,r){this.descriptor=e,this._pages=t,this._pageSize=r;const i=Ca+t.reduce((s,{usedMemory:o})=>s+o,0),a=3*Qr;this.usedMemory=xe+i+a,this.featureCount=t.reduce((s,o)=>s+o.featureCount,0)}get id(){return this.descriptor.id}getObjectId(e){const{pageIndex:t,featurePageIndex:r}=this._translateIndex(e);return this._pages[t].getObjectId(r)}getAttribute(e,t){const{pageIndex:r,featurePageIndex:i}=this._translateIndex(e);return this._pages[r].getAttribute(i,t)}getAttributeAsTimestamp(e,t){const{pageIndex:r,featurePageIndex:i}=this._translateIndex(e);return this._pages[r].getAttributeAsTimestamp(i,t)}getAttributes(e){const{pageIndex:t,featurePageIndex:r}=this._translateIndex(e);return this._pages[t].getAttributes(r)}getCoordinates(e,t,r){const{pageIndex:i,featurePageIndex:a}=this._translateIndex(e);this._pages[i].getCoordinates(a,t,r)}getOptimizedGeometry(e){const{pageIndex:t,featurePageIndex:r}=this._translateIndex(e);return this._pages[t].getOptimizedGeometry(r)}getCentroid(e,t){const{pageIndex:r,featurePageIndex:i}=this._translateIndex(e);return this._pages[r].getCentroid(i,t)}getBounds(e){const{pageIndex:t,featurePageIndex:r}=this._translateIndex(e);return this._pages[t].getBounds(r)}getBoundingBox(e){const{pageIndex:t,featurePageIndex:r}=this._translateIndex(e);return this._pages[t].getBoundingBox(r)}getObjectIdsArray(e,t=this._allFeatureIndices(),r=0){let i=r;for(const{page:a,indices:s}of this._batchPageIndices(t))i=a.getObjectIdsArray(e,s,i);return i}getCoordinatesArray(e,t=this._allFeatureIndices(),r=0){let i=r;for(const{page:a,indices:s}of this._batchPageIndices(t))i=a.getCoordinatesArray(e,s,i);return i}*objectIds(e=this._allFeatureIndices()){for(const{page:t,indices:r}of this._batchPageIndices(e))for(const i of t.objectIds(r))yield i}*_allFeatureIndices(){const{featureCount:e}=this;for(let t=0;t<e;++t)yield t}_translateIndex(e){const{_pageSize:t}=this;return{pageIndex:Math.floor(e/t),featurePageIndex:e%t}}*_batchPageIndices(e){const t=new Array;{let i=0,a=new Array;for(const s of e){const{pageIndex:o,featurePageIndex:c}=this._translateIndex(s);i!==o&&(a.length!==0&&t.push({pageIndex:i,indices:a}),i=o,a=[]),a.push(c)}a.length!==0&&t.push({pageIndex:i,indices:a})}const{_pages:r}=this;for(const{pageIndex:i,indices:a}of t)yield{page:r[i],indices:a}}},Gs=class{constructor(e){this._reader=new Ia(new Uint8Array(e),new DataView(e)),this._index=ks(this._reader)}get featureCount(){return this._index.featureIndices.length}get exceededTransferLimit(){return this._index.exceededTransferLimit}get usedMemory(){return this._reader.usedMemory}getObjectId(e){return this.getAttribute(e,this._index.objectIdFieldName)}getAttribute(e,t){const{_index:{fieldsIndex:r,attributeIndices:i}}=this,a=r.get(t)?.index;if(a==null)return;const s=i[e*r.fields.length+a],o=this._reader;return o.move(s),Fe(o)}getAttributeAsTimestamp(e,t){const r=this.getAttribute(e,t);return typeof r=="string"?new Date(r).getTime():typeof r=="number"||r==null?r:null}getAttributes(e){const{_index:{fieldsIndex:t,attributeIndices:r}}=this,i=e*t.fields.length,a=this._reader,s={};for(const o of t.fields){const c=r[i+o.index];a.move(c),s[o.name]=Fe(a)}return s}getCoordinates(e,t,r=0){const i=this._reader,{transform:a,featureIndices:s}=this._index,{scale:o,translate:c}=a;i.move(s[e]),this._readCoordinates(o,c,t,r)}getOptimizedGeometry(e){const t=V();return this.getCoordinates(e,t),new Pt([],t)}getCentroid(e,{hasZ:t,hasM:r}){this.getCoordinates(e,ue);const[i,a,s]=ue,o=[i,a];return t&&(o[3]=s),r&&(o[t?4:3]=0),new Pt([],o)}getBounds(e){this.getCoordinates(e,ue);const[t,r]=ue,i=new Wr;return i.minX=t,i.minY=r,i.maxX=t,i.maxY=r,i}getBoundingBox(e){this.getCoordinates(e,ue);const[t,r,i]=ue;return Qn(t,r,i,t,r,i)}getObjectIdsArray(e,t=this._allFeatureIndices(),r=0){const i=this._reader,{objectIdFieldName:a,attributeIndices:s,fieldsIndex:o}=this._index,c=o.get(a).index,d=o.fields.length;for(const f of t){const l=s[f*d+c];i.move(l),e[r++]=Fe(i)}return r}getCoordinatesArray(e,t=this._allFeatureIndices(),r=0){const i=this._reader,{transform:a,featureIndices:s}=this._index,{scale:o,translate:c}=a;for(const d of t){const f=s[d];i.move(f),r=this._readCoordinates(o,c,e,r)}return r}*objectIds(e=this._allFeatureIndices()){const t=this._reader,{objectIdFieldName:r,attributeIndices:i,fieldsIndex:a}=this._index,s=a.get(r).index,o=a.fields.length;for(const c of e){const d=i[c*o+s];t.move(d),yield Fe(t)}}*_allFeatureIndices(){const{featureCount:e}=this;for(let t=0;t<e;++t)yield t}_readCoordinates([e,t,r],[i,a,s],o,c){const l=this._reader,u=l.getLength(),p=l.pos()+u;for(;l.pos()<p&&l.next();)switch(l.tag()){case 2:{const _=l.getLength(),w=l.pos()+_;for(;l.pos()<w&&l.next();)l.tag()===3?(l.getUInt32(),o[c++]=i+e*l.getSInt64(),o[c++]=a+t*l.getSInt64(),o[c++]=s+r*l.getSInt64()):l.skip();break}default:l.skip()}return c}};function ks(n){for(;n.next();){if(n.tag()===2)return Ns(n.getMessage());n.skip()}Xe()}function Ns(n){for(;n.next();){if(n.tag()===1)return Hs(n.getMessage());n.skip()}Xe()}function Hs(n){let f,l,u=!1,p=!1,_=0;const w=new Array,m=new Array,g=new Array;for(;n.next();)switch(n.tag()){case 1:l=n.getString();break;case 7:n.getEnum()!==0&&Xe();break;case 9:u=n.getBool()??!1;break;case 12:f=Aa(n.processMessage(Ta));break;case 13:{const v=n.processMessage(Ra);v.index=_++,w.push(v);break}case 15:{m.push(n.pos());const v=n.getUInt32(),P=n.pos()+v;for(;n.pos()<P&&n.next();)n.tag()===1&&g.push(n.pos()),n.skip();break}case 10:p=n.getBool()??!1;break;default:n.skip()}const h=new Oa(w);return f!=null&&p&&l!=null&&h.has(l)||Xe(),{transform:f,exceededTransferLimit:u,fieldsIndex:h,objectIdFieldName:l,featureIndices:m,attributeIndices:g}}function Xe(){const n=new Wn("pbf-parsing-failed","Error while parsing PBF",new Error);throw console.error(n),n}function Fe(n){const f=n.getLength(),l=n.pos()+f;for(;n.pos()<l&&n.next();)switch(n.tag()){case 1:return n.getString();case 2:return n.getFloat();case 3:return n.getDouble();case 4:return n.getSInt32();case 5:return n.getUInt32();case 6:return n.getInt64();case 7:return n.getUInt64();case 8:return n.getSInt64();case 9:return n.getBool();default:return n.skip(),null}return null}const ue=V(),Sr=8e3,qs=4,Qs=4;let Ws=class{constructor(e,t,r,i,a){this.spatialReference=e,this.url=r,this.objectIdField=i,this.capabilities=a;const{supportsMaxRecordCountFactor:s,maxRecordCount:o}=this.capabilities.query,c=s?qs:1,d=(o??Sr)*c;this._pageSize=Math.min(Sr,d);const f=t.clone();f.cacheHint=!0,f.resultType="tile",f.outSpatialReference=e,f.returnGeometry=!0,f.returnZ=!0,f.maxRecordCountFactor=c,f.num=this._pageSize,f.outFields=[i],this._baseQuery=f}async fetch(e,t){const{spatialReference:r,_pageSize:i}=this,a=Yn(e.extent,r),s=this._baseQuery.clone();s.geometry=a;const o=new Array;let c=0,d=!1,f=1;for(;!d;){const l=[];for(let p=0;p<f;++p)l.push(this._fetchPage(s,c++,t));const u=await Promise.all(l);Ae(t);for(const p of u){const _=p.featureCount!==0;d||=!p.exceededTransferLimit||!_,_&&o.push(p)}f=Math.min(f+1,Qs)}return new Us(e,o,i)}async _fetchPage(e,t,r){const i=e.clone();i.start=t*this._pageSize;const a=(await Pa(this.url,i,{signal:r})).data;return Ae(r),new Gs(a)}};function Ys(n){return n instanceof Float32Array&&n.length>=16}function Js(n){return Array.isArray(n)&&n.length>=16}function Xs(n){return Ys(n)||Js(n)}const ln=.5;function Zs(n,e){n.include(Gr),n.attributes.add("position","vec3"),n.attributes.add("normal","vec3"),n.attributes.add("centerOffsetAndDistance","vec4");const t=n.vertex;Pi(t,e),Ii(t,e),t.uniforms.add(new Bt("viewport",r=>r.camera.fullViewport),new St("polygonOffset",r=>r.shaderPolygonOffset),new Qe("cameraGroundRelative",r=>r.camera.aboveGround?1:-1)),e.hasVerticalOffset&&Ai(t),t.code.add(y`struct ProjectHUDAux {
vec3 posModel;
vec3 posView;
vec3 vnormal;
float distanceToCamera;
float absCosAngle;
};`),t.code.add(y`
    float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {
      float pointGroundSign = ${e.terrainDepthTest?y.float(0):y`sign(pointGroundDistance)`};
      if (pointGroundSign == 0.0) {
        pointGroundSign = cameraGroundRelative;
      }

      // cameraGroundRelative is -1 if camera is below ground, 1 if above ground
      // groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise
      float groundRelative = cameraGroundRelative * pointGroundSign;

      // view angle dependent part of polygon offset emulation: we take the absolute value because the sign that is
      // dropped is instead introduced using the ground-relative position of the symbol and the camera
      if (polygonOffset > .0) {
        float cosAlpha = clamp(absCosAngle, 0.01, 1.0);
        float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;
        float factor = (1.0 - tanAlpha / viewport[2]);

        // same side of the terrain
        if (groundRelative > 0.0) {
          posView *= factor;
        }
        // opposite sides of the terrain
        else {
          posView /= factor;
        }
      }

      return groundRelative;
    }
  `),e.draped&&!e.hasVerticalOffset||Oi(t),e.draped||(t.uniforms.add(new Qe("perDistancePixelRatio",r=>Math.tan(r.camera.fovY/2)/(r.camera.fullViewport[2]/2))),t.code.add(y`
    void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {
      float distanceToCamera = length(posView);

      // Compute offset in world units for a half pixel shift
      float pixelOffset = distanceToCamera * perDistancePixelRatio * ${y.float(ln)};

      // Apply offset along normal in the direction away from the ground surface
      vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;

      // Apply the same offset also on the view space position
      vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;

      posModel += modelOffset;
      posView += viewOffset;
    }
  `)),e.screenCenterOffsetUnitsEnabled&&kr(t),e.hasScreenSizePerspective&&Nr(t),t.code.add(y`
    vec4 projectPositionHUD(out ProjectHUDAux aux) {
      vec3 centerOffset = centerOffsetAndDistance.xyz;
      float pointGroundDistance = centerOffsetAndDistance.w;

      aux.posModel = position;
      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;
      aux.vnormal = normal;
      ${e.draped?"":"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);"}

      // Screen sized offset in world space, used for example for line callouts
      // Note: keep this implementation in sync with the CPU implementation, see
      //   - MaterialUtil.verticalOffsetAtDistance
      //   - HUDMaterial.applyVerticalOffsetTransformation

      aux.distanceToCamera = length(aux.posView);

      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);
      float cosAngle = dot(aux.vnormal, viewDirObjSpace);

      aux.absCosAngle = abs(cosAngle);

      ${e.hasScreenSizePerspective&&(e.hasVerticalOffset||e.screenCenterOffsetUnitsEnabled)?"vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);":""}

      ${e.hasVerticalOffset?e.hasScreenSizePerspective?"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);":"float verticalOffsetScreenHeight = verticalOffset.x;":""}

      ${e.hasVerticalOffset?y`
            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);
            vec3 modelOffset = aux.vnormal * worldOffset;
            aux.posModel += modelOffset;
            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
            aux.posView += viewOffset;
            // Since we elevate the object, we need to take that into account
            // in the distance to ground
            pointGroundDistance += worldOffset;`:""}

      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);

      ${e.screenCenterOffsetUnitsEnabled?"":y`
            // Apply x/y in view space, but z in screen space (i.e. along posView direction)
            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);

            // Same material all have same z != 0.0 condition so should not lead to
            // branch fragmentation and will save a normalization if it's not needed
            if (centerOffset.z != 0.0) {
              aux.posView -= normalize(aux.posView) * centerOffset.z;
            }
          `}

      vec4 posProj = proj * vec4(aux.posView, 1.0);

      ${e.screenCenterOffsetUnitsEnabled?e.hasScreenSizePerspective?"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);":"float centerOffsetY = centerOffset.y;":""}

      ${e.screenCenterOffsetUnitsEnabled?"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;":""}

      // constant part of polygon offset emulation
      posProj.z -= groundRelative * polygonOffset * posProj.w;
      return posProj;
    }
  `)}function kt(n){n.uniforms.add(new Ri("alignPixelEnabled",e=>e.alignPixelEnabled)),n.code.add(y`vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {
if (!alignPixelEnabled)
return clipCoord;
vec2 xy = vec2(0.500123) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`),n.code.add(y`vec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {
if (!alignPixelEnabled)
return clipCoord;
vec2 xy = vec2(0.5) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = floor((xy + 0.5 * pixelSz) * widthHeight) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`)}function Ks(n,e){const{vertex:t,fragment:r}=n;n.include(Ti,e),t.include(kt),t.main.add(y`vec4 posProjCenter;
if (dot(position, position) > 0.0) {
ProjectHUDAux projectAux;
vec4 posProj = projectPositionHUD(projectAux);
posProjCenter = alignToPixelCenter(posProj, viewport.zw);
forwardViewPosDepth(projectAux.posView);
vec3 vpos = projectAux.posModel;
if (rejectBySlice(vpos)) {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
} else {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
gl_Position = posProjCenter;
gl_PointSize = 1.0;`),r.main.add(y`fragColor = vec4(1);
if(discardByTerrainDepth()) {
fragColor.g = 0.5;
}`)}function eo(n){n.vertex.uniforms.add(new Qe("renderTransparentlyOccludedHUD",e=>e.hudRenderStyle===0?1:e.hudRenderStyle===1?0:.75),new Bt("viewport",e=>e.camera.fullViewport),new Hr("hudVisibilityTexture",e=>e.hudVisibility?.getTexture())),n.vertex.include(kt),n.vertex.code.add(y`bool testHUDVisibility(vec4 posProj) {
vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);
vec4 occlusionPixel = texture(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);
if (renderTransparentlyOccludedHUD > 0.5) {
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * renderTransparentlyOccludedHUD < 1.0;
}
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;
}`)}class to extends zi{constructor(e,t,r){super(e,"vec4",2,(i,a,s)=>i.setUniform4fv(e,t(a,s),r))}}function cn(n){const e=new Di,{signedDistanceFieldEnabled:t,occlusionTestEnabled:r,horizonCullingEnabled:i,pixelSnappingEnabled:a,hasScreenSizePerspective:s,debugDrawLabelBorder:o,hasVVSize:c,hasVVColor:d,hasRotation:f,occludedFragmentFade:l,sampleSignedDistanceFieldTexelCenter:u}=n;e.include(Zs,n),e.vertex.include(ji,n);const{occlusionPass:p,output:_,oitPass:w}=n;if(p)return e.include(Ks,n),e;const{vertex:m,fragment:g}=e;e.include(Gr),e.include(Mi,n),e.include(Fi,n),r&&e.include(eo),g.include(Ei),e.varyings.add("vcolor","vec4"),e.varyings.add("vtc","vec2"),e.varyings.add("vsize","vec2");const h=_===9,v=h&&r;v&&e.varyings.add("voccluded","float"),m.uniforms.add(new Bt("viewport",x=>x.camera.fullViewport),new lr("screenOffset",(x,H)=>Ft(ke,2*x.screenOffset[0]*H.camera.pixelRatio,2*x.screenOffset[1]*H.camera.pixelRatio)),new lr("anchorPosition",x=>we(x)),new dt("materialColor",x=>x.color),new St("materialRotation",x=>x.rotation),new cr("tex",x=>x.texture)),kr(m),t&&(m.uniforms.add(new dt("outlineColor",x=>x.outlineColor)),g.uniforms.add(new dt("outlineColor",x=>Pr(x)?x.outlineColor:Br),new St("outlineSize",x=>Pr(x)?x.outlineSize:0))),i&&m.uniforms.add(new to("pointDistanceSphere",(x,H)=>{const F=H.camera.eye,G=x.origin;return pi(G[0]-F[0],G[1]-F[1],G[2]-F[2],Xn.radius)})),a&&m.include(kt),s&&(Vi(m),Nr(m)),o&&e.varyings.add("debugBorderCoords","vec4"),e.attributes.add("uv0","vec2"),e.attributes.add("uvi","vec4"),e.attributes.add("color","vec4"),e.attributes.add("size","vec2"),e.attributes.add("rotation","float"),(c||d)&&e.attributes.add("featureAttribute","vec4"),m.code.add(i?y`bool behindHorizon(vec3 posModel) {
vec3 camToEarthCenter = pointDistanceSphere.xyz - localOrigin;
vec3 camToPos = pointDistanceSphere.xyz + posModel;
float earthRadius = pointDistanceSphere.w;
float a = dot(camToPos, camToPos);
float b = dot(camToPos, camToEarthCenter);
float c = dot(camToEarthCenter, camToEarthCenter) - earthRadius * earthRadius;
return b > 0.0 && b < a && b * b  > a * c;
}`:y`bool behindHorizon(vec3 posModel) { return false; }`),m.main.add(y`
    ProjectHUDAux projectAux;
    vec4 posProj = projectPositionHUD(projectAux);
    forwardObjectAndLayerIdColor();

    if (rejectBySlice(projectAux.posModel)) {
      // Project outside of clip plane
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
      return;
    }

    if (behindHorizon(projectAux.posModel)) {
      // Project outside of clip plane
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
      return;
    }

    vec2 inputSize;
    ${j(s,y`
        inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
        vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);`,y`
        inputSize = size;
        vec2 screenOffsetScaled = screenOffset;`)}
    ${j(c,y`inputSize *= vvScale(featureAttribute).xx;`)}

    vec2 combinedSize = inputSize * pixelRatio;
    vec4 quadOffset = vec4(0.0);

    ${j(r,y`
    bool visible = testHUDVisibility(posProj);
    if (!visible) {
      vtc = vec2(0.0);
      ${j(o,"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);")}
      return;
    }`)}
    ${j(v,y`voccluded = visible ? 0.0 : 1.0;`)}
  `);const P=y`
      vec2 uv = mix(uvi.xy, uvi.zw, bvec2(uv0));
      vec2 texSize = vec2(textureSize(tex, 0));
      uv = mix(vec2(1.0), uv / texSize, lessThan(uv, vec2(${no})));
      quadOffset.xy = (uv0 - anchorPosition) * 2.0 * combinedSize;

      ${j(f,y`
          float angle = radians(materialRotation + rotation);
          float cosAngle = cos(angle);
          float sinAngle = sin(angle);
          mat2 rotate = mat2(cosAngle, -sinAngle, sinAngle,  cosAngle);

          quadOffset.xy = rotate * quadOffset.xy;
        `)}

      quadOffset.xy = (quadOffset.xy + screenOffsetScaled) / viewport.zw * posProj.w;
  `,b=a?t?y`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;`:y`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`:y`posProj += quadOffset;`;m.main.add(y`
    ${P}
    ${d?"vcolor = interpolateVVColor(featureAttribute.y) * materialColor;":"vcolor = color / 255.0 * materialColor;"}

    ${j(_===10,y`vcolor.a = 1.0;`)}

    bool alphaDiscard = vcolor.a < ${y.float(K)};
    ${j(t,`alphaDiscard = alphaDiscard && outlineColor.a < ${y.float(K)};`)}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${b}
      gl_Position = posProj;
    }

    vtc = uv;

    ${j(o,y`debugBorderCoords = vec4(uv01, 1.5 / combinedSize);`)}
    vsize = inputSize;
  `),g.uniforms.add(new cr("tex",x=>x.texture)),l&&!h&&g.uniforms.add(new Hr("depthMap",x=>x.mainDepth),new Qe("occludedOpacity",x=>x.hudOccludedFragmentOpacity));const z=o?y`(isBorder > 0.0 ? 0.0 : ${y.float(K)})`:y.float(K),M=y`
    ${j(o,y`float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`)}

    vec2 samplePos = vtc;

    ${j(u,y`
      float txSize = float(textureSize(tex, 0).x);
      float texelSize = 1.0 / txSize;

      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      samplePos += (vec2(1.0, -1.0) * texelSize) * scaleFactor;`)}

    ${t?y`
      vec4 fillPixelColor = vcolor;

      // Get distance in output units (i.e. pixels)

      float sdf = texture(tex, samplePos).r;
      float pixelDistance = sdf * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - pixelDistance, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(pixelDistance) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${z} ||
          fillPixelColor.a + outlinePixelColor.a < ${y.float(K)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        ${j(!h,y`fragColor = vec4(compositeColor, compositeAlpha);`)}
      } else {
        if (fillAlphaFactor < ${z}) {
          discard;
        }

        ${j(!h,y`fragColor = premultiplyAlpha(fillPixelColor);`)}
      }

      // visualize SDF:
      // fragColor = vec4(clamp(-pixelDistance/vsize.x*2.0, 0.0, 1.0), clamp(pixelDistance/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `:y`
          vec4 texColor = texture(tex, samplePos, -0.5);
          if (texColor.a < ${z}) {
            discard;
          }
          ${j(!h,y`fragColor = texColor * premultiplyAlpha(vcolor);`)}
          `}

    ${j(l&&!h,y`
        float zSample = texelFetch(depthMap, ivec2(gl_FragCoord.xy), 0).x;
        if (zSample < gl_FragCoord.z) {
          fragColor *= occludedOpacity;
        }
        `)}

    ${j(!h&&o,y`fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);`)}
  `;switch(_){case 0:case 1:e.outputs.add("fragColor","vec4",0),_===1&&e.outputs.add("fragEmission","vec4",1),w===1&&e.outputs.add("fragAlpha","float",_===1?2:1),g.main.add(y`
        ${M}
        ${j(w===2,y`fragColor.rgb /= fragColor.a;`)}
        ${j(_===1,y`fragEmission = vec4(0.0);`)}
        ${j(w===1,y`fragAlpha = fragColor.a;`)}`);break;case 10:g.main.add(y`
        ${M}
        outputObjectAndLayerIdColor();`);break;case 9:e.include(Bi,n),g.main.add(y`
        ${M}
        outputHighlight(${j(v,y`voccluded == 1.0`,y`false`)});`)}return e}function Pr(n){return n.outlineColor[3]>0&&n.outlineSize>0}function we(n){return n.textureIsSignedDistanceField?ro(n.anchorPosition,n.distanceFieldBoundingBox,ke):Jn(ke,n.anchorPosition),ke}function ro(n,e,t){Ft(t,n[0]*(e[2]-e[0])+e[0],n[1]*(e[3]-e[1])+e[1])}const ke=Vt(),Oe=32e3,no=y.float(Oe),io=Object.freeze(Object.defineProperty({__proto__:null,build:cn,calculateAnchorPosition:we,fullUV:Oe},Symbol.toStringTag,{value:"Module"}));let ao=class extends Ui{constructor(e,t){super(e,t,new Gi(io,()=>ja(()=>Promise.resolve().then(()=>Ko),void 0)),Fa([dn,fn()].map(Ma))),this.primitiveType=t.occlusionPass?mr.POINTS:mr.TRIANGLE_STRIP}initializePipeline(e){const{oitPass:t,hasPolygonOffset:r,draped:i,output:a,depthTestEnabled:s,occlusionPass:o}=e,c=s&&!i&&t!==1&&!o&&a!==9;return ki({blending:qr(a)?Qi(t,!0):null,depthTest:s&&!i?{func:515}:null,depthWrite:c?qi:null,drawBuffers:Hi(t,a),colorWrite:Ni,polygonOffset:r?so:null})}};const so={factor:0,units:-4},dn=Yr().vec2u8("uv0",{glNormalized:!0}),un=Yr().vec3f("position").vec3f("normal").vec4i16("uvi").vec4u8("color").vec2f("size").f32("rotation").vec4f("centerOffsetAndDistance").vec4f("featureAttribute"),oo=un.clone().vec4u8("olidColor");function fn(){return Li()?oo:un}let R=class extends Wi{constructor(e){super(),this.spherical=e,this.screenCenterOffsetUnitsEnabled=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.hasVVSize=!1,this.hasVVColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.hasRotation=!1,this.debugDrawLabelBorder=!1,this.hasPolygonOffset=!1,this.depthTestEnabled=!0,this.pixelSnappingEnabled=!0,this.draped=!1,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.occlusionPass=!1,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!0,this.isFocused=!0,this.olidColorInstanced=!1,this.textureCoordinateType=0,this.emissionSource=0,this.discardInvisibleFragments=!0,this.hasVVInstancing=!1,this.snowCover=!1}};C([D()],R.prototype,"screenCenterOffsetUnitsEnabled",void 0),C([D()],R.prototype,"occlusionTestEnabled",void 0),C([D()],R.prototype,"signedDistanceFieldEnabled",void 0),C([D()],R.prototype,"sampleSignedDistanceFieldTexelCenter",void 0),C([D()],R.prototype,"hasVVSize",void 0),C([D()],R.prototype,"hasVVColor",void 0),C([D()],R.prototype,"hasVerticalOffset",void 0),C([D()],R.prototype,"hasScreenSizePerspective",void 0),C([D()],R.prototype,"hasRotation",void 0),C([D()],R.prototype,"debugDrawLabelBorder",void 0),C([D()],R.prototype,"hasPolygonOffset",void 0),C([D()],R.prototype,"depthTestEnabled",void 0),C([D()],R.prototype,"pixelSnappingEnabled",void 0),C([D()],R.prototype,"draped",void 0),C([D()],R.prototype,"terrainDepthTest",void 0),C([D()],R.prototype,"cullAboveTerrain",void 0),C([D()],R.prototype,"occlusionPass",void 0),C([D()],R.prototype,"occludedFragmentFade",void 0),C([D()],R.prototype,"horizonCullingEnabled",void 0),C([D()],R.prototype,"isFocused",void 0);class lo extends Yi{constructor(e,t){super(e,go),this.produces=new Map([[13,r=>ut(r)&&!this.parameters.drawAsLabel],[14,r=>ut(r)&&this.parameters.drawAsLabel],[12,()=>this.parameters.occlusionTest],[18,r=>this.parameters.draped&&ut(r)]]),this._visible=!0,this._configuration=new R(t)}getConfiguration(e,t){const r=this.parameters.draped;return super.getConfiguration(e,t,this._configuration),this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled=this.parameters.centerOffsetUnits==="screen",this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=r,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.hasRotation=this.parameters.hasRotation,this._configuration.hasVVSize=!!this.parameters.vvSize,this._configuration.hasVVColor=!!this.parameters.vvColor,this._configuration.occlusionPass=t.slot===12,this._configuration.occludedFragmentFade=!r&&this.parameters.occludedFragmentFade,this._configuration.horizonCullingEnabled=this.parameters.horizonCullingEnabled,this._configuration.isFocused=this.parameters.isFocused,this._configuration.depthTestEnabled=this.parameters.depthEnabled||t.slot===12,qr(e)&&(this._configuration.debugDrawLabelBorder=!!Ji.LABELS_SHOW_BORDER),this._configuration.oitPass=t.oitPass,this._configuration.terrainDepthTest=t.terrainDepthTest,this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration}intersect(e,t,r,i,a,s){const{options:{selectionMode:o,hud:c,excludeLabels:d},point:f,camera:l}=r,{parameters:u}=this;if(!o||!c||d&&u.isLabel||!e.visible||!f||!l)return;const p=e.attributes.get("featureAttribute"),_=p==null?null:rr(p.data,Dt),{scaleX:w,scaleY:m}=jt(_,u,l.pixelRatio);jr(Ne,t),e.attributes.has("featureAttribute")&&fo(Ne);const g=e.attributes.get("position"),h=e.attributes.get("size"),v=e.attributes.get("normal"),P=e.attributes.get("rotation"),b=e.attributes.get("centerOffsetAndDistance");za(g.size>=3);const z=we(u),M=this.parameters.centerOffsetUnits==="screen";for(let x=0;x<g.data.length/g.size;x++){const H=x*g.size;W($,g.data[H],g.data[H+1],g.data[H+2]),U($,$,t),U($,$,l.viewMatrix);const F=x*b.size;if(W(I,b.data[F],b.data[F+1],b.data[F+2]),!M&&($[0]+=I[0],$[1]+=I[1],I[2]!==0)){const re=I[2];ee(I,$),N($,$,E(I,I,re))}const G=x*v.size;if(W(ie,v.data[G],v.data[G+1],v.data[G+2]),Tt(ie,Ne,l,Ie),Mt(this.parameters,$,Ie,l,ve),l.applyProjection($,S),S[0]>-1){M&&(I[0]||I[1])&&(S[0]+=I[0]*l.pixelRatio,I[1]!==0&&(S[1]+=ve.alignmentEvaluator.apply(I[1])*l.pixelRatio),l.unapplyProjection(S,$)),S[0]+=this.parameters.screenOffset[0]*l.pixelRatio,S[1]+=this.parameters.screenOffset[1]*l.pixelRatio,S[0]=Math.floor(S[0]),S[1]=Math.floor(S[1]);const re=x*h.size;T[0]=h.data[re],T[1]=h.data[re+1],ve.evaluator.applyVec2(T,T);const st=pn*l.pixelRatio;let De=0;u.textureIsSignedDistanceField&&(De=Math.min(u.outlineSize,.5*T[0])*l.pixelRatio/2),T[0]*=w,T[1]*=m;const je=x*P.size,ne=u.rotation+P.data[je];if(zt(f,S[0],S[1],T,st,De,ne,u,z)){const Ce=r.ray;if(U(Ze,$,rt(hn,l.viewMatrix)),S[0]=f[0],S[1]=f[1],l.unprojectFromRenderScreen(S,$)){const $e=V();O($e,Ce.direction);const Jt=1/J($e);E($e,$e,Jt),s(Et(Ce.origin,$)*Jt,$e,-1,Ze)}}}}}intersectDraped(e,t,r,i,a){const s=e.attributes.get("position"),o=e.attributes.get("size"),c=e.attributes.get("rotation"),d=this.parameters,f=we(d),l=e.attributes.get("featureAttribute"),u=l==null?null:rr(l.data,Dt),{scaleX:p,scaleY:_}=jt(u,d,e.screenToWorldRatio),w=ho*e.screenToWorldRatio;for(let m=0;m<s.data.length/s.size;m++){const g=m*s.size,h=s.data[g],v=s.data[g+1],P=m*o.size;T[0]=o.data[P],T[1]=o.data[P+1];let b=0;d.textureIsSignedDistanceField&&(b=Math.min(d.outlineSize,.5*T[0])*e.screenToWorldRatio/2),T[0]*=p,T[1]*=_;const z=m*c.size,M=d.rotation+c.data[z];zt(r,h,v,T,w,b,M,d,f)&&i(a.distance,a.normal,-1)}}createBufferWriter(){return new yo}applyShaderOffsetsView(e,t,r,i,a,s,o){const c=Tt(t,r,a,Ie);return this._applyVerticalGroundOffsetView(e,c,a,o),Mt(this.parameters,o,c,a,s),this._applyPolygonOffsetView(o,c,i[3],a,o),this._applyCenterOffsetView(o,i,o),o}applyShaderOffsetsNDC(e,t,r,i,a){return this._applyCenterOffsetNDC(e,t,r,i),a!=null&&O(a,i),this._applyPolygonOffsetNDC(i,t,r,i),i}_applyPolygonOffsetView(e,t,r,i,a){const s=i.aboveGround?1:-1;let o=Math.sign(r);o===0&&(o=s);const c=s*o;if(this.parameters.shaderPolygonOffset<=0)return O(a,e);const d=Tr(Math.abs(t.cosAngle),.01,1),f=1-Math.sqrt(1-d*d)/d/i.viewport[2];return E(a,e,c>0?f:1/f),a}_applyVerticalGroundOffsetView(e,t,r,i){const a=J(e),s=r.aboveGround?1:-1,o=r.computeRenderPixelSizeAtDist(a)*ln,c=E($,t.normal,s*o);return Y(i,e,c),i}_applyCenterOffsetView(e,t,r){const i=this.parameters.centerOffsetUnits!=="screen";return r!==e&&O(r,e),i&&(r[0]+=t[0],r[1]+=t[1],t[2]&&(ee(ie,r),xi(r,r,E(ie,ie,t[2])))),r}_applyCenterOffsetNDC(e,t,r,i){const a=this.parameters.centerOffsetUnits!=="screen";return i!==e&&O(i,e),a||(i[0]+=t[0]/r.fullWidth*2,i[1]+=t[1]/r.fullHeight*2),i}_applyPolygonOffsetNDC(e,t,r,i){const a=this.parameters.shaderPolygonOffset;if(e!==i&&O(i,e),a){const s=r.aboveGround?1:-1,o=s*Math.sign(t[3]);i[2]-=(o||s)*a}return i}set visible(e){this._visible=e}get visible(){const{color:e,outlineSize:t,outlineColor:r}=this.parameters,i=e[3]>=K||t>=K&&r[3]>=K;return this._visible&&i}createGLMaterial(e){return new co(e)}calculateRelativeScreenBounds(e,t,r=Mr()){return uo(this.parameters,e,t,r),r[2]=r[0]+e[0],r[3]=r[1]+e[1],r}}class co extends aa{constructor(e){super({...e,...e.material.parameters})}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.getTechnique(ao,e)}}function uo(n,e,t,r){r[0]=n.anchorPosition[0]*-e[0]+n.screenOffset[0]*t,r[1]=n.anchorPosition[1]*-e[1]+n.screenOffset[1]*t}function Tt(n,e,t,r){return Xs(e)&&(e=jr(mo,e)),wi(r.normal,n,e),U(r.normal,r.normal,t.viewInverseTransposeMatrix),r.cosAngle=ae(mn,po),r}function fo(n){const e=n[0],t=n[1],r=n[2],i=n[3],a=n[4],s=n[5],o=n[6],c=n[7],d=n[8],f=1/Math.sqrt(e*e+t*t+r*r),l=1/Math.sqrt(i*i+a*a+s*s),u=1/Math.sqrt(o*o+c*c+d*d);return n[0]=e*f,n[1]=t*f,n[2]=r*f,n[3]=i*l,n[4]=a*l,n[5]=s*l,n[6]=o*u,n[7]=c*u,n[8]=d*u,n}function zt(n,e,t,r,i,a,s,o,c){let d=e-i-r[0]*c[0],f=d+r[0]+2*i,l=t-i-r[1]*c[1],u=l+r[1]+2*i;const p=o.distanceFieldBoundingBox;return o.textureIsSignedDistanceField&&p!=null&&(d+=r[0]*p[0],l+=r[1]*p[1],f-=r[0]*(1-p[2]),u-=r[1]*(1-p[3]),d-=a,f+=a,l-=a,u+=a),Ft(Ir,e,t),Zn(Pe,n,Ir,Kn(s)),Pe[0]>d&&Pe[0]<f&&Pe[1]>l&&Pe[1]<u}const ve=new Xi,$=V(),ie=V(),S=tt(),mn=V(),Ze=V(),Pe=Vt(),Ir=Vt(),Ne=Fr(),mo=Fr(),hn=te(),Ee=tt(),I=V(),gt=V(),Dt=tt(),Ie={normal:mn,cosAngle:0},pn=1,ho=2,T=k(0,0),po=Le(0,0,1);class go extends Zi{constructor(){super(...arguments),this.renderOccluded=1,this.isDecoration=!1,this.color=$t(1,1,1,1),this.polygonOffset=!1,this.anchorPosition=k(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=$t(1,1,1,1),this.outlineSize=0,this.distanceFieldBoundingBox=tt(),this.rotation=0,this.hasRotation=!1,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!1,this.centerOffsetUnits="world",this.drawAsLabel=!1,this.depthEnabled=!0,this.isFocused=!0,this.focusStyle="bright",this.draped=!1,this.isLabel=!1}get hasVVSize(){return!!this.vvSize}get hasVVColor(){return!!this.vvColor}get hasVVOpacity(){return!!this.vvOpacity}}class yo{constructor(){this.layout=dn,this.instanceLayout=fn()}elementCount(e){return e.get("position").indices.length}elementCountBaseInstance(e){return e.get("uv0").indices.length}write(e,t,r,i,a,s){const{position:o,normal:c,color:d,size:f,rotation:l,centerOffsetAndDistance:u,featureAttribute:p,uvi:_}=a;ea(r.get("position"),e,o,s),ta(r.get("normal"),t,c,s);const w=r.get("position").indices.length;let m=0,g=0,h=Oe,v=Oe;const P=r.get("uvi")?.data;P&&P.length>=4&&(m=P[0],g=P[1],h=P[2],v=P[3]);for(let b=0;b<w;++b){const z=s+b;_.setValues(z,m,g,h,v)}if(ra(r.get("color"),4,d,s),dr(r.get("size"),f,s),na(r.get("rotation"),l,s),r.get("centerOffsetAndDistance")?ur(r.get("centerOffsetAndDistance"),u,s):fr(u,s,w),r.get("featureAttribute")?ur(r.get("featureAttribute"),p,s):fr(p,s,w),i!=null){const b=r.get("position")?.indices;if(b){const z=b.length,M=a.getField("olidColor",Da);ia(i,M,z,s)}}return{numVerticesPerItem:1,numItems:w}}writeBaseInstance(e,t){const{uv0:r}=t;dr(e.get("uv0"),r,0)}intersect(e,t,r,i,a,s,o){const{options:{selectionMode:c,hud:d,excludeLabels:f},point:l,camera:u}=i;if(!c||!d||f&&t.isLabel||!l)return;const p=this.instanceLayout.createView(e),{position:_,normal:w,rotation:m,size:g,featureAttribute:h,centerOffsetAndDistance:v}=p,P=t.centerOffsetUnits==="screen",b=we(t);if(_==null||w==null||m==null||g==null||v==null||u==null)return;const z=h==null?null:h.getVec(0,Dt),{scaleX:M,scaleY:x}=jt(z,t,u.pixelRatio),H=_.count;for(let F=0;F<H;F++){if(_.getVec(F,$),r!=null&&Y($,$,r),U($,$,u.viewMatrix),v.getVec(F,Ee),W(I,Ee[0],Ee[1],Ee[2]),!P&&($[0]+=I[0],$[1]+=I[1],I[2]!==0)){const G=I[2];ee(I,$),N($,$,E(I,I,G))}if(w.getVec(F,ie),Tt(ie,Ne,u,Ie),Mt(t,$,Ie,u,ve),u.applyProjection($,S),S[0]>-1){P&&(I[0]||I[1])&&(S[0]+=I[0]*u.pixelRatio,I[1]!==0&&(S[1]+=ve.alignmentEvaluator.apply(I[1])*u.pixelRatio),u.unapplyProjection(S,$)),S[0]+=t.screenOffset[0]*u.pixelRatio,S[1]+=t.screenOffset[1]*u.pixelRatio,S[0]=Math.floor(S[0]),S[1]=Math.floor(S[1]),g.getVec(F,T),ve.evaluator.applyVec2(T,T);const G=pn*u.pixelRatio;let re=0;t.textureIsSignedDistanceField&&(re=Math.min(t.outlineSize,.5*T[0])*u.pixelRatio/2),T[0]*=M,T[1]*=x;const st=m.get(F),De=t.rotation+st;if(zt(l,S[0],S[1],T,G,re,De,t,b)){const je=i.ray;if(U(Ze,$,rt(hn,u.viewMatrix)),S[0]=l[0],S[1]=l[1],u.unprojectFromRenderScreen(S,$)){const ne=V();O(ne,je.direction);const Ce=1/J(ne);E(ne,ne,Ce),o(Et(je.origin,$)*Ce,ne,F,Ze)}}}}}}function jt(n,e,t){return n==null||e.vvSize==null?{scaleX:t,scaleY:t}:(Ss(gt,e,n),{scaleX:gt[0]*t,scaleY:gt[1]*t})}function Mt(n,e,t,r,i){if(!n.verticalOffset?.screenLength){const c=J(e);return i.update(t.cosAngle,c,n.screenSizePerspective,n.screenSizePerspectiveMinPixelReferenceSize,n.screenSizePerspectiveAlignment,null),e}const a=J(e),s=n.screenSizePerspectiveAlignment??n.screenSizePerspective,o=Ki(r,a,n.verticalOffset,t.cosAngle,s,n.screenSizePerspectiveMinPixelReferenceSize);return i.update(t.cosAngle,a,n.screenSizePerspective,n.screenSizePerspectiveMinPixelReferenceSize,n.screenSizePerspectiveAlignment,null),E(t.normal,t.normal,o),Y(e,e,t.normal)}class bo{constructor(e,t){this._mainThreadDelegate=t,this._bufferWriters=new Map,this.globalViewingMode=e===1}createRenderCommandBuffer(e=[],t=[]){return{commands:e,transferList:t}}mergeRenderCommandBuffers(e){const t=this.createRenderCommandBuffer();for(const r of e)r!=null&&(t.commands.push(...r.commands),t.transferList.push(...r.transferList));return t}async createTexture(e){const{data:t,parameters:r}=e();return await this._mainThreadDelegate.createTexture(t,r)}async releaseTexture(e){const t=this._destroyTexture(e);return new X(this,t,[])}_destroyTexture(e){return{commands:[{id:"destroy-texture",textureId:e}],transferList:[]}}async createMaterial(e){const{type:t,parameters:r}=e,i=Je("material");let a,s;switch(t){case"default":a=new sa(e.parameters,{spherical:this.globalViewingMode}),s={type:t,materialId:i,parameters:e.parameters};break;case"hud":a=new lo(r,this.globalViewingMode),s={type:t,materialId:i,parameters:e.parameters}}return this._bufferWriters.set(i,a.createBufferWriter()),await this._mainThreadDelegate.createMaterial(s),i}destroyMaterial(e){return{commands:[{id:"destroy-material",materialId:e}],transferList:[]}}updateMaterial(e){return{commands:[{...e,id:"update-material"}],transferList:[]}}async createDirectRenderer(e){return await this._mainThreadDelegate.createDirectRenderer(e),e}async destroyDirectRenderer(e){await this._mainThreadDelegate.destroyDirectRenderer(e)}addDirectRendererGeometry(e,t,r,i){const{materialId:a}=t;if(this._bufferWriters.get(a)==null)throw new Error(`no bufferwriter found for material ${a}`);const{renderGeometryBuffer:s,renderGeometryBufferItems:o}=this.createRenderGeometryBuffer(t,r,i);return this.addDirectRendererGeometryBuffer(a,e,s,o,r)}updateDirectRendererGeometry(e,t,r,i){const{materialId:a}=t;if(this._bufferWriters.get(a)==null)throw new Error(`no bufferwriter found for material ${a}`);const{renderGeometryBuffer:s,renderGeometryBufferItems:o}=this.createRenderGeometryBuffer(t,r,i);return this.updateDirectRendererGeometryBuffer(a,e,s,o,r)}addDirectRendererGeometryBuffer(e,t,r,i,a){const{objectIds:s,visibilities:o}=i;return{commands:[{id:"add-direct-renderer-geometry-buffer",rendererId:e,groupId:t,renderGeometryBuffer:r,renderGeometryBufferItems:i,localOrigin:a}],transferList:[r.data,s.buffer,o.buffer]}}updateDirectRendererGeometryBuffer(e,t,r,i,a){const{objectIds:s,visibilities:o}=i;return{commands:[{id:"update-direct-renderer-geometry-buffer",rendererId:e,groupId:t,renderGeometryBuffer:r,renderGeometryBufferItems:i,localOrigin:a}],transferList:[r.data,s.buffer,o.buffer]}}removeDirectRendererGeometryBuffer(e,t){return{commands:[{id:"remove-direct-renderer-geometry-buffer",rendererId:e,groupId:t}],transferList:[]}}async createLodRenderer(e){const t=Je("lod-renderer"),r=new Set,i={levels:e.levels.map(a=>({components:a.components.map(s=>{const o=s.attributes.get("position");if(!o||o.indices.length===0)throw new Error("positions attribute expected");const c=3,d=ha(o.indices.length/c),f=new oa(d,c,o);if(this._bufferWriters.get(s.materialId)==null)throw new Error("writer not found");const{renderGeometryBuffer:l}=this.createRenderGeometryBuffer(s,null);return r.add(l.data),{materialId:s.materialId,renderGeometryBuffer:l,boundingInfo:{bbMax:f.bbMax,bbMin:f.bbMin}}}),minScreenSpaceRadius:a.minScreenSpaceRadius}))};return await this._mainThreadDelegate.createLodRenderer(t,i,Array.from(r)),t}destroyLodRenderer(e){return{commands:[{id:"destroy-lod-renderer",rendererId:e}],transferList:[]}}addLodInstances(e,t,r){return{commands:[{id:"add-lod-instances",rendererId:e,groupId:t,data:r}],transferList:[r.featureIds.buffer,r.globalTransforms.buffer,r.localTransforms.buffer,r.visibility.buffer]}}removeLodInstances(e,t){return{commands:[{id:"remove-lod-instances",rendererId:e,groupId:t}],transferList:[]}}updateLodInstancesData(e,t,r){return{commands:[{id:"update-lod-instance-data",rendererId:e,groupId:t,globalTransforms:r}],transferList:[r.buffer]}}updateVisibility(e,t,r){return{commands:[{id:"update-visibility",rendererId:e,groupId:t,visibility:r}],transferList:[r.buffer]}}async dispatchRenderCommands(e){e.commands.length!==0&&await this._mainThreadDelegate.executeRenderCommands(e)}createRenderGeometryBuffer(e,t,r){const{materialId:i,visibilities:a,objectIds:s}=e,o=this._bufferWriters.get(i);if(o==null)throw new Error("no registered bufferWriter for material found");let c=null;if(e.transformation&&t)Lr(fe,e.transformation),fe[12]-=t[0],fe[13]-=t[1],fe[14]-=t[2],c=fe;else{if(t)throw new Error("not implemented");e.transformation&&(c=e.transformation)}let d=null;c&&(rt(Ve,fe),Ur(Ve,Ve),d=Ve);const f=e.attributes,l=o.elementCount(f),u=r?o.instanceLayout:o.layout;if(!u)throw new Error("Missing layout");const p=u.stride/4;l>Math.floor(_o/p)&&console.warn("geometry with very large number of elements encountered");const _=u.createBuffer(l),w=0,m=o.write(c,d,f,e.olidColor,_,w);if(m==null)throw new Error("Bufferwriter.write does not provide item information.");if(a.length!==m.numItems||s.length!==m.numItems)throw new Error("Unexpected mismatch between number of RenderGeometryBufferItems and provided objectIds/visibility flags.");return{renderGeometryBuffer:{data:_.buffer,elementCount:l},renderGeometryBufferItems:{objectIds:s,visibilities:a,ranges:{numVertices:m.numVerticesPerItem,numItems:m.numItems}}}}async setBaseInstance(e,t){await this._mainThreadDelegate.setBaseInstance(e,t)}}const fe=te(),Ve=te(),_o=16777216/4;function vo(n,e,t){return!!We(n,e,Be,t.spatialReference)&&(t.x=Be[0],t.y=Be[1],t.z=Be[2],!0)}const Be=V(),yt=()=>ei.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");function ze(n=$n){return{plane:Ut(n.plane),origin:ot(n.origin),basis1:ot(n.basis1),basis2:ot(n.basis2)}}function xo(n,e,t){const r=Vo.get();return r.origin=n,r.basis1=e,r.basis2=t,r.plane=Ua(0,0,0,0),it(r),r}function nt(n,e=ze()){return Nt(n.origin,n.basis1,n.basis2,e)}function wo(n,e){O(e.origin,n.origin),O(e.basis1,n.basis1),O(e.basis2,n.basis2),Ha(e.plane,n.plane)}function Nt(n,e,t,r=ze()){return O(r.origin,n),O(r.basis1,e),O(r.basis2,t),it(r),Fo(r,"fromValues()"),r}function it(n){It(n.basis2,n.basis1,n.origin,n.plane)}function gn(n,e,t){n!==t&&nt(n,t);const r=E(A.get(),Z(n),e);return Y(t.origin,t.origin,r),t.plane[3]-=e,t}function Co(n,e,t){return yn(e,t),gn(t,Qt(n,n.origin),t),t}function $o(n,e){const t=n.basis1[0],r=n.basis2[1],[i,a]=n.origin;return ti(i-t,a-r,i+t,a+r,e)}function yn(n,e=ze()){const t=(n[2]-n[0])/2,r=(n[3]-n[1])/2;return W(e.origin,n[0]+t,n[1]+r,0),W(e.basis1,t,0,0),W(e.basis2,0,r,0),Na(0,0,1,0,e.plane),e}function Ht(n,e,t){return!!Jr(n.plane,e,t)&&wn(n,t)}function So(n,e,t){if(Ht(n,e,t))return t;const r=bn(n,e,A.get());return Y(t,e.origin,E(A.get(),e.direction,Et(e.origin,r)/J(e.direction))),t}function bn(n,e,t){const r=Ke.get();Cn(n,e,r,Ke.get());let i=Number.POSITIVE_INFINITY;for(const a of Yt){const s=Wt(n,a,at.get()),o=A.get();if(qa(r,s,o)){const c=Ci(A.get(),e.origin,o),d=Math.abs(ri(ae(e.direction,c)));d<i&&(i=d,O(t,o))}}return i===Number.POSITIVE_INFINITY?_n(n,e,t):t}function Po(n,e){return(e-n)/e}function _n(n,e,t){if(Ht(n,e,t))return t;const r=Ke.get(),i=Ke.get();Cn(n,e,r,i);let a=Number.POSITIVE_INFINITY;for(const s of Yt){const o=Wt(n,s,at.get()),c=A.get();if(Qa(r,o,c)){const d=ba(e,c);if(!Xr(i,c))continue;d<a&&(a=d,O(t,c))}}return qt(n,e.origin)<a&&vn(n,e.origin,t),t}function vn(n,e,t){const r=ka(n.plane,e,A.get()),i=gr(Ar(n,n.basis1),r,-1,1,A.get()),a=gr(Ar(n,n.basis2),r,-1,1,A.get());return N(t,Y(A.get(),i,a),n.origin),t}function xn(n,e,t){const{origin:r,basis1:i,basis2:a}=n,s=N(A.get(),e,r),o=Ue(i,s),c=Ue(a,s),d=Ue(Z(n),s);return W(t,o,c,d)}function qt(n,e){const t=xn(n,e,A.get()),{basis1:r,basis2:i}=n,a=J(r),s=J(i),o=Math.max(Math.abs(t[0])-a,0),c=Math.max(Math.abs(t[1])-s,0),d=t[2];return o*o+c*c+d*d}function Io(n,e){return Math.sqrt(qt(n,e))}function Ao(n,e){let t=Number.NEGATIVE_INFINITY;for(const r of Yt){const i=Wt(n,r,at.get()),a=Ba(i,e);a>t&&(t=a)}return Math.sqrt(t)}function Oo(n,e){return Xr(n.plane,e)&&wn(n,e)}function Ro(n,e,t,r){return Mo(n,t,r)}function Qt(n,e){const t=-n.plane[3];return Ue(Z(n),e)-t}function To(n,e,t,r){const i=Qt(n,e),a=E(Eo,Z(n),t-i);return Y(r,e,a),r}function zo(n,e){return ct(n.basis1,e.basis1)&&ct(n.basis2,e.basis2)&&ct(n.origin,e.origin)}function Do(n,e,t){return n!==t&&nt(n,t),rt(me,e),Ur(me,me),U(t.basis1,n.basis1,me),U(t.basis2,n.basis2,me),U(Ye(t.plane),Ye(n.plane),me),U(t.origin,n.origin,e),Ga(t.plane,t.plane,t.origin),t}function jo(n,e,t,r){return n!==r&&nt(n,r),bi(bt,e,t),U(r.basis1,n.basis1,bt),U(r.basis2,n.basis2,bt),it(r),r}function Z(n){return Ye(n.plane)}function Mo(n,e,t){switch(e){case 0:O(t,n.basis1),ee(t,t);break;case 1:O(t,n.basis2),ee(t,t);break;case 2:O(t,Z(n))}return t}function wn(n,e){const t=N(A.get(),e,n.origin),r=nr(n.basis1),i=nr(n.basis2),a=ae(n.basis1,t),s=ae(n.basis2,t);return-a-r<0&&a-r<0&&-s-i<0&&s-i<0}function Ar(n,e){const t=at.get();return O(t.origin,n.origin),O(t.vector,e),t}function Wt(n,e,t){const{basis1:r,basis2:i,origin:a}=n,s=E(A.get(),r,e.origin[0]),o=E(A.get(),i,e.origin[1]);Y(t.origin,s,o),Y(t.origin,t.origin,a);const c=E(A.get(),r,e.direction[0]),d=E(A.get(),i,e.direction[1]);return E(t.vector,Y(c,c,d),2),t}function Fo(n,e){Math.abs(ae(n.basis1,n.basis2)/(J(n.basis1)*J(n.basis2)))>1e-6&&yt().warn(e,"Provided basis vectors are not perpendicular"),Math.abs(ae(n.basis1,Z(n)))>1e-6&&yt().warn(e,"Basis vectors and plane normal are not perpendicular"),Math.abs(-ae(Z(n),n.origin)-n.plane[3])>1e-6&&yt().warn(e,"Plane offset is not consistent with plane origin")}function Cn(n,e,t,r){const i=Z(n);It(i,e.direction,e.origin,t),It(Ye(t),i,e.origin,r)}const $n={plane:Ut(),origin:Le(0,0,0),basis1:Le(1,0,0),basis2:Le(0,1,0)},Ke=new Lt(Ut),at=new Lt(La),Eo=V(),Vo=new Lt(()=>ze()),Yt=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],me=te(),bt=te(),Bo=Object.freeze(Object.defineProperty({__proto__:null,altitudeAt:Qt,axisAt:Ro,cameraFrustumCoverage:Po,closestPoint:_n,closestPointOnSilhouette:bn,copy:nt,copyWithoutVerify:wo,create:ze,distance:Io,distance2:qt,distanceToSilhouette:Ao,elevate:gn,equals:zo,extrusionContainsPoint:Oo,fromAABoundingRect:yn,fromValues:Nt,getExtent:$o,intersectRay:Ht,intersectRayClosestSilhouette:So,normal:Z,projectPoint:vn,projectPointLocal:xn,rotate:jo,setAltitudeAt:To,setExtent:Co,transform:Do,up:$n,updateUnboundedPlane:it,wrap:xo},Symbol.toStringTag,{value:"Module"}));function Lo(n){const{value:e,operations:t}=n;return{operations:t,value:t.create(e)}}function Uo(n,e,t){return n.operations.setExtent(n.value,e,t.value),t}function Go(n,e){return n.operations.getExtent(n.value,e),e}function ko(n){return{operations:n,value:n.create()}}function Sn(n,e,t=ko(n)){return t.operations=n,n.copy(e,t.value),t}function No(n){return Sn(va,_a(0,0,0,Er(n).radius))}const Or=2**50;function Ho(){return Sn(Bo,Nt([0,0,0],[Or,0,0],[0,Or,0]))}function qo(n,e,t){return n.operations.axisAt(n.value,e,2,t)}function Qo(n,e,t,r){return n.operations.axisAt(n.value,e,t,r)}function Wo(n,e,t){return n.operations.intersectRay(n.value,e,t)}function Yo(n,e,t){return n.operations.intersectRayClosestSilhouette(n.value,e,t)}function Jo(n,e){return n.operations.altitudeAt(n.value,e)}function Pn(n,e,t,r){return n.operations.setAltitudeAt(n.value,e,t,r)}function Xo(n,e,t,r){return e!==r&&Lr(r,e),W(he,r[12],r[13],r[14]),Pn(n,he,t,he),r[12]=he[0],r[13]=he[1],r[14]=he[2],r}function _t(n,e,t){return n.operations.elevate(n.value,e,t.value)}const he=V();function Rr(n){return n.type==="point"}class et{constructor(e,t,r,i){this.viewingMode=e,this.spatialReference=t,this.unitInMeters=r,this._coordinateSystem=i,this._tmpCoordinateSystem=Lo(i),this.referenceEllipsoid=Er(t),this.sphericalPCPF=Ea(t)}set extent(e){e&&Uo(this._coordinateSystem,e,this._coordinateSystem)}get extent(){return Go(this._coordinateSystem,Mr())}getAltitude(e){return Jo(this._coordinateSystem,e)}setAltitude(e,t,r=e){return Pn(this._coordinateSystem,r,t,e)}setAltitudeOfTransformation(e,t){Xo(this._coordinateSystem,t,e,t)}worldUpAtPosition(e,t){return qo(this._coordinateSystem,e,t)}worldBasisAtPosition(e,t,r){return Qo(this._coordinateSystem,e,t,r)}basisMatrixAtPosition(e,t){const r=this.worldBasisAtPosition(e,0,A.get()),i=this.worldBasisAtPosition(e,1,A.get()),a=this.worldBasisAtPosition(e,2,A.get());return _i(t,r[0],r[1],r[2],0,i[0],i[1],i[2],0,a[0],a[1],a[2],0,0,0,0,1),t}headingAtPosition(e,t){const r=this.worldUpAtPosition(e,A.get()),i=this.worldBasisAtPosition(e,1,A.get()),a=xa(t,i,r);return ni(a)}intersectManifoldClosestSilhouette(e,t,r){return _t(this._coordinateSystem,t,this._tmpCoordinateSystem),Yo(this._tmpCoordinateSystem,e,r),r}intersectManifold(e,t,r){_t(this._coordinateSystem,t,this._tmpCoordinateSystem);const i=A.get();return Wo(this._tmpCoordinateSystem,e,i)?O(r,i):null}intersectInfiniteManifold(e,t,r){if(this.viewingMode===1)return this.intersectManifold(e,t,r);_t(this._coordinateSystem,t,this._tmpCoordinateSystem);const i=this._tmpCoordinateSystem.value,a=A.get();return Jr(i.plane,e,a)?O(r,a):null}toRenderCoords(e,t,r){return Rr(e)?Va(e,t,this.spatialReference):We(e,t,r,this.spatialReference)}fromRenderCoords(e,t,r=null){return Rr(t)?(r!=null&&(t.spatialReference=r),vo(e,this.spatialReference,t)?t:null):We(e,this.spatialReference,t,r)?t:null}static create(e,t){switch(e){case 2:return new et(2,t,ii(t),Ho());case 1:return new et(1,t,1,No(t))}}static renderUnitScaleFactor(e,t){return Kt(e)/Kt(t)}}let He=class extends ai{constructor(){super(...arguments),this.remoteClient=null,this._featureStore=new Bs,this._tileLocks=new Fs,this._tileManager=null,this._renderer=null,this._fetcher=null,this._queryEngine=null,this._defaultQueryJSON=null,this._mainThreadDelegate=null,this._viewSpatialReference=null,this._renderCommandContext=null,this._context=null}get updating(){return this._tileManager.updating}destroy(){this._featureStore.clear(),this._tileManager?.destroy()}async setup({viewSpatialReference:n,renderSpatialReference:e,viewingMode:t,layerInfo:r,layerViewInfo:i}){const a=er.fromJSON(n);this._viewSpatialReference=a;const s=er.fromJSON(e);this._fetcher=new Ws(this._viewSpatialReference,tr.fromJSON(r.baseQuery),r.url,r.objectIdField,r.capabilities),this._queryEngine=new fi({hasZ:!0,hasM:!1,geometryType:"esriGeometryPoint",featureIdInfo:{type:"object-id",fieldName:r.objectIdField},fieldsIndex:r.fieldIndex,availableFields:[r.objectIdField],spatialReference:n,featureStore:this._featureStore,timeInfo:r.timeInfo}),this._mainThreadDelegate={createTexture:async(l,u)=>{const p={data:l,parameters:u};return await this.remoteClient.invoke("createTexture",p,{transferList:[l.buffer]})},releaseTexture:async l=>{const u={uid:l};await this.remoteClient.invoke("releaseTexture",u)},createMaterial:async l=>{const u={materialJSON:l};await this.remoteClient.invoke("createMaterial",u)},destroyMaterial:async l=>{const u={materialId:l};await this.remoteClient.invoke("destroyMaterial",u)},createDirectRenderer:async l=>{const u={materialId:l};await this.remoteClient.invoke("createDirectRenderer",u)},destroyDirectRenderer:async l=>{const u={materialId:l};await this.remoteClient.invoke("destroyDirectRenderer",u)},createLodRenderer:async(l,u,p)=>{const _={rendererId:l,lodRenderGeometry:u};await this.remoteClient.invoke("createLoDRenderer",_,{transferList:p})},destroyLodRenderer:async l=>{const u={rendererId:l};await this.remoteClient.invoke("destroyLoDRenderer",u)},executeRenderCommands:async l=>{const u={commands:l.commands};await this.remoteClient.invoke("dispatchRenderCommands",u,{transferList:l.transferList})},applyElevationAlignmentTo:async l=>{const u={mapPoints:l};return await this.remoteClient.invoke("applyElevationAlignment",u,{transferList:[l.buffer]})},setBaseInstance:async(l,u)=>{const p={rendererId:l,baseInstance:u};await this.remoteClient.invoke("setBaseInstance",p,{transferList:u!=null?[u.data]:void 0})}};const o=et.create(t,s),c=new bo(t,this._mainThreadDelegate);this._renderCommandContext=c;const d=new Rs(a,s,this._mainThreadDelegate,o,c,r,i);this._context=d,this._renderer=d.symbolRendererFactory.createSymbolRendererFromJSON(r.renderer),this._defaultQueryJSON=new tr({outSpatialReference:a}).toJSON();let f=null;if(r.fullExtent!=null){const l=si.fromJSON(r.fullExtent);await di(l.spatialReference,a),f=ui(l,a)}return this._tileManager=new B({loadTile:(l,u)=>this._fetcher.fetch(l,u),createAddCommand:(l,u)=>this._createAddFeatureDataCommand(l,u),createRemoveCommand:l=>this._createRemoveFeatureDataCommand(l),createUpdateCommand:(l,u)=>this._createUpdateFeatureDataVisibilityCommand(l,u),tileLocks:this._tileLocks,extent:f}),this.addHandles(oi(()=>this.updating,l=>{this.emit("notify-updating",{updating:l})}),li),this._renderer!=null&&await this._renderer.load(),pe}async executeQuery(n,e){return{result:await this._queryEngine.executeQuery(this._ensureQuery(n),e)}}async executeQueryForIds(n,e){const t=await this._queryEngine.executeQueryForIdSet(this._ensureQuery(n),e);return{result:Array.from(t)}}async executeQueryForCount(n,e){return{result:await this._queryEngine.executeQueryForCount(this._ensureQuery(n),e)}}async executeQueryForExtent(n,e){return{result:await this._queryEngine.executeQueryForExtent(this._ensureQuery(n),e)}}async executeQueryForLatestObservations(n,e){return{result:await this._queryEngine.executeQueryForLatestObservations(this._ensureQuery(n),e)}}async executeAttributeBinsQuery(n,e){return{result:await this._queryEngine.executeAttributeBinsQuery(n,e)}}onTileTreeChange(n){return this._tileManager.onTileTreeChange(n),Promise.resolve(pe)}async onElevationChange(n){return pe}async onLayerViewOpacityChange(n){const{_context:e,_renderer:t}=this;return e.layerViewInfo.fullOpacity=n,t==null||await(await t.createUpdateLayerViewOpacityCommand(n)).execute(),pe}async onRendererChange(n){const{_context:e}=this,t=e.symbolRendererFactory.createSymbolRendererFromJSON(n);await t.load();const r=this._renderer;this._renderer=t;const i=[...this._tileManager.loadedTiles()],a=i.map(o=>o.tileId);{const o={stack:[],error:void 0,hasError:!1};try{wt(o,await this._tileLocks.lock(a),!1);const c=i.flatMap(l=>[r.createRemoveCommand(l.id),t.createAddCommand(l)]),d=await Promise.all(c);await e.joinPipelineCommands(d).execute()}catch(c){o.error=c,o.hasError=!0}finally{Ct(o)}}return await(await r.createDestroyCommand()).execute(),pe}async _createAddFeatureDataCommand(n,e){const t=this._featureStore,r=this._renderer;let i;return i=r!=null?await r.createAddCommand(n):X.create(this._renderCommandContext),Ae(e),i.appendPipelineStateCommand(()=>{t.addTile(n)}),i}async _createRemoveFeatureDataCommand(n){const e=this._featureStore,t=this._renderer;let r;return r=t!=null?await t.createRemoveCommand(n):X.create(this._renderCommandContext),r.appendPipelineStateCommand(()=>{e.removeTile(n)}),r}async _createUpdateFeatureDataVisibilityCommand(n,e){const t=this._renderer;let r;return r=t!=null?await t.createUpdateVisibilityCommand(n):X.create(this._renderCommandContext),Ae(e),r}_ensureQuery(n){return n??this._defaultQueryJSON}};C([L()],He.prototype,"updating",null),He=C([Dr("esri.views.3d.layers.graphics.pipeline.Feature3DPipelineWorker")],He);const Zo=He,pe={result:void 0},ac=Object.freeze(Object.defineProperty({__proto__:null,default:Zo},Symbol.toStringTag,{value:"Module"})),sc=Object.freeze(Object.defineProperty({__proto__:null,build:la},Symbol.toStringTag,{value:"Module"})),oc=Object.freeze(Object.defineProperty({__proto__:null,build:ca,getRadius:da},Symbol.toStringTag,{value:"Module"})),lc=Object.freeze(Object.defineProperty({__proto__:null,build:ua},Symbol.toStringTag,{value:"Module"})),cc=Object.freeze(Object.defineProperty({__proto__:null,build:fa},Symbol.toStringTag,{value:"Module"})),Ko=Object.freeze(Object.defineProperty({__proto__:null,build:cn,calculateAnchorPosition:we,fullUV:Oe},Symbol.toStringTag,{value:"Module"}));export{lc as D,ac as F,cc as R,sc as S,oc as a};
